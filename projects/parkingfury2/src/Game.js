!function (a) {
    if ("object" == typeof exports) {
      module.exports = a();
    } else {
      var b;
      if ("undefined" != typeof window) {
        b = window;
      } else if ("undefined" != typeof global) {
        b = global;
      } else if ("undefined" != typeof self) {
        b = self;
      }
      b.p2 = a();
    }
  }(function () {
    return function a(b, c, d) {
      function e(g, h) {
        if (!c[g]) {
          if (!b[g]) {
            var i = "function" == typeof require && require;
            if (!h && i) {
              return i(g, true);
            }
            if (f) {
              return f(g, true);
            }
            throw new Error("Cannot find module '" + g + "'");
          }
          var j = c[g] = {
            exports: {}
          };
          b[g][0].call(j.exports, function (a) {
            var c = b[g][1][a];
            return e(c || a);
          }, j, j.exports, a, b, c, d);
        }
        return c[g].exports;
      }
      var f = "function" == typeof require && require;
      for (var g = 0; g < d.length; g++) {
        e(d[g]);
      }
      return e;
    }({
      1: [function (a, b, c) {
        function e() {}
        var d = a("./Scalar");
        b.exports = e;
        e.lineInt = function (a, b, c) {
          c = c || 0;
          var f;
          var g;
          var h;
          var i;
          var j;
          var k;
          var l;
          var e = [0, 0];
          f = a[1][1] - a[0][1];
          g = a[0][0] - a[1][0];
          h = f * a[0][0] + g * a[0][1];
          i = b[1][1] - b[0][1];
          j = b[0][0] - b[1][0];
          k = i * b[0][0] + j * b[0][1];
          l = f * j - i * g;
          if (!d.eq(l, 0, c)) {
            e[0] = (j * h - g * k) / l;
            e[1] = (f * k - i * h) / l;
          }
          return e;
        };
        e.segmentsIntersect = function (a, b, c, d) {
          var e = b[0] - a[0];
          var f = b[1] - a[1];
          var g = d[0] - c[0];
          var h = d[1] - c[1];
          if (g * f - h * e == 0) {
            return false;
          }
          var i = (e * (c[1] - a[1]) + f * (a[0] - c[0])) / (g * f - h * e);
          var j = (g * (a[1] - c[1]) + h * (c[0] - a[0])) / (h * e - g * f);
          return i >= 0 && i <= 1 && j >= 0 && j <= 1;
        };
      }, {
        "./Scalar": 4
      }],
      2: [function (a, b, c) {
        function d() {}
        b.exports = d;
        d.area = function (a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
        };
        d.left = function (a, b, c) {
          return d.area(a, b, c) > 0;
        };
        d.leftOn = function (a, b, c) {
          return d.area(a, b, c) >= 0;
        };
        d.right = function (a, b, c) {
          return d.area(a, b, c) < 0;
        };
        d.rightOn = function (a, b, c) {
          return d.area(a, b, c) <= 0;
        };
        var e = [];
        var f = [];
        d.collinear = function (a, b, c, g) {
          if (g) {
            e[0] = b[0] - a[0];
            e[1] = b[1] - a[1];
            f[0] = c[0] - b[0];
            f[1] = c[1] - b[1];
            var j = e[0] * f[0] + e[1] * f[1];
            var k = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
            var l = Math.sqrt(f[0] * f[0] + f[1] * f[1]);
            return Math.acos(j / (k * l)) < g;
          }
          return 0 == d.area(a, b, c);
        };
        d.sqdist = function (a, b) {
          var c = b[0] - a[0];
          var d = b[1] - a[1];
          return c * c + d * d;
        };
      }, {}],
      3: [function (a, b, c) {
        function g() {
          this.vertices = [];
        }
        function j(a, b, c, d, e) {
          e = e || 0;
          var g = b[1] - a[1];
          var h = a[0] - b[0];
          var i = g * a[0] + h * a[1];
          var j = d[1] - c[1];
          var k = c[0] - d[0];
          var l = j * c[0] + k * c[1];
          var m = g * k - j * h;
          return f.eq(m, 0, e) ? [0, 0] : [(k * i - h * l) / m, (g * l - j * i) / m];
        }
        var d = a("./Line");
        var e = a("./Point");
        var f = a("./Scalar");
        b.exports = g;
        g.prototype.at = function (a) {
          var b = this.vertices;
          var c = b.length;
          return b[a < 0 ? a % c + c : a % c];
        };
        g.prototype.first = function () {
          return this.vertices[0];
        };
        g.prototype.last = function () {
          return this.vertices[this.vertices.length - 1];
        };
        g.prototype.clear = function () {
          this.vertices.length = 0;
        };
        g.prototype.append = function (a, b, c) {
          if (undefined === b) {
            throw new Error("From is not given!");
          }
          if (undefined === c) {
            throw new Error("To is not given!");
          }
          if (c - 1 < b) {
            throw new Error("lol1");
          }
          if (c > a.vertices.length) {
            throw new Error("lol2");
          }
          if (b < 0) {
            throw new Error("lol3");
          }
          for (var d = b; d < c; d++) {
            this.vertices.push(a.vertices[d]);
          }
        };
        g.prototype.makeCCW = function () {
          var a = 0;
          var b = this.vertices;
          for (var c = 1; c < this.vertices.length; ++c) {
            if (b[c][1] < b[a][1] || b[c][1] == b[a][1] && b[c][0] > b[a][0]) {
              a = c;
            }
          }
          if (!e.left(this.at(a - 1), this.at(a), this.at(a + 1))) {
            this.reverse();
          }
        };
        g.prototype.reverse = function () {
          var a = [];
          var b = 0;
          for (var c = this.vertices.length; b !== c; b++) {
            a.push(this.vertices.pop());
          }
          this.vertices = a;
        };
        g.prototype.isReflex = function (a) {
          return e.right(this.at(a - 1), this.at(a), this.at(a + 1));
        };
        var h = [];
        var i = [];
        g.prototype.canSee = function (a, b) {
          var c;
          var f;
          if (e.leftOn(this.at(a + 1), this.at(a), this.at(b)) && e.rightOn(this.at(a - 1), this.at(a), this.at(b))) {
            return false;
          }
          f = e.sqdist(this.at(a), this.at(b));
          for (var k = 0; k !== this.vertices.length; ++k) {
            if ((k + 1) % this.vertices.length !== a && k !== a && e.leftOn(this.at(a), this.at(b), this.at(k + 1)) && e.rightOn(this.at(a), this.at(b), this.at(k)) && (h[0] = this.at(a), h[1] = this.at(b), i[0] = this.at(k), i[1] = this.at(k + 1), c = d.lineInt(h, i), e.sqdist(this.at(a), c) < f)) {
              return false;
            }
          }
          return true;
        };
        g.prototype.copy = function (a, b, c) {
          var d = c || new g();
          d.clear();
          if (a < b) {
            for (var e = a; e <= b; e++) {
              d.vertices.push(this.vertices[e]);
            }
          } else {
            for (var e = 0; e <= b; e++) {
              d.vertices.push(this.vertices[e]);
            }
            for (var e = a; e < this.vertices.length; e++) {
              d.vertices.push(this.vertices[e]);
            }
          }
          return d;
        };
        g.prototype.getCutEdges = function () {
          var a = [];
          var b = [];
          var c = [];
          var d = new g();
          var e = Number.MAX_VALUE;
          for (var f = 0; f < this.vertices.length; ++f) {
            if (this.isReflex(f)) {
              for (var h = 0; h < this.vertices.length; ++h) {
                if (this.canSee(f, h)) {
                  b = this.copy(f, h, d).getCutEdges();
                  c = this.copy(h, f, d).getCutEdges();
                  for (var i = 0; i < c.length; i++) {
                    b.push(c[i]);
                  }
                  if (b.length < e) {
                    a = b;
                    e = b.length;
                    a.push([this.at(f), this.at(h)]);
                  }
                }
              }
            }
          }
          return a;
        };
        g.prototype.decomp = function () {
          var a = this.getCutEdges();
          return a.length > 0 ? this.slice(a) : [this];
        };
        g.prototype.slice = function (a) {
          if (0 == a.length) {
            return [this];
          }
          if (a instanceof Array && a.length && a[0] instanceof Array && 2 == a[0].length && a[0][0] instanceof Array) {
            var b = [this];
            for (var c = 0; c < a.length; c++) {
              var d = a[c];
              for (var e = 0; e < b.length; e++) {
                var f = b[e];
                var g = f.slice(d);
                if (g) {
                  b.splice(e, 1);
                  b.push(g[0], g[1]);
                  break;
                }
              }
            }
            return b;
          }
          var d = a;
          var c = this.vertices.indexOf(d[0]);
          var e = this.vertices.indexOf(d[1]);
          return -1 != c && -1 != e && [this.copy(c, e), this.copy(e, c)];
        };
        g.prototype.isSimple = function () {
          var a = this.vertices;
          for (var b = 0; b < a.length - 1; b++) {
            for (var c = 0; c < b - 1; c++) {
              if (d.segmentsIntersect(a[b], a[b + 1], a[c], a[c + 1])) {
                return false;
              }
            }
          }
          for (var b = 1; b < a.length - 2; b++) {
            if (d.segmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1])) {
              return false;
            }
          }
          return true;
        };
        g.prototype.quickDecomp = function (a, b, c, d, f, h) {
          f = f || 100;
          h = h || 0;
          d = d || 25;
          a = undefined !== a ? a : [];
          b = b || [];
          c = c || [];
          var i = [0, 0];
          var k = [0, 0];
          var l = [0, 0];
          var m = 0;
          var n = 0;
          var o = 0;
          var p = 0;
          var q = 0;
          var r = 0;
          var s = 0;
          var t = new g();
          var u = new g();
          var v = this;
          var w = this.vertices;
          if (w.length < 3) {
            return a;
          }
          if (++h > f) {
            console.warn("quickDecomp: max level (" + f + ") reached.");
            return a;
          }
          for (var x = 0; x < this.vertices.length; ++x) {
            if (v.isReflex(x)) {
              b.push(v.vertices[x]);
              m = n = Number.MAX_VALUE;
              for (var y = 0; y < this.vertices.length; ++y) {
                if (e.left(v.at(x - 1), v.at(x), v.at(y)) && e.rightOn(v.at(x - 1), v.at(x), v.at(y - 1))) {
                  l = j(v.at(x - 1), v.at(x), v.at(y), v.at(y - 1));
                  if (e.right(v.at(x + 1), v.at(x), l) && (o = e.sqdist(v.vertices[x], l)) < n) {
                    n = o;
                    k = l;
                    r = y;
                  }
                }
                if (e.left(v.at(x + 1), v.at(x), v.at(y + 1)) && e.rightOn(v.at(x + 1), v.at(x), v.at(y))) {
                  l = j(v.at(x + 1), v.at(x), v.at(y), v.at(y + 1));
                  if (e.left(v.at(x - 1), v.at(x), l) && (o = e.sqdist(v.vertices[x], l)) < m) {
                    m = o;
                    i = l;
                    q = y;
                  }
                }
              }
              if (r == (q + 1) % this.vertices.length) {
                l[0] = (k[0] + i[0]) / 2;
                l[1] = (k[1] + i[1]) / 2;
                c.push(l);
                if (x < q) {
                  t.append(v, x, q + 1);
                  t.vertices.push(l);
                  u.vertices.push(l);
                  if (0 != r) {
                    u.append(v, r, v.vertices.length);
                  }
                  u.append(v, 0, x + 1);
                } else {
                  if (0 != x) {
                    t.append(v, x, v.vertices.length);
                  }
                  t.append(v, 0, q + 1);
                  t.vertices.push(l);
                  u.vertices.push(l);
                  u.append(v, r, x + 1);
                }
              } else {
                if (r > q) {
                  q += this.vertices.length;
                }
                p = Number.MAX_VALUE;
                if (q < r) {
                  return a;
                }
                for (var y = r; y <= q; ++y) {
                  if (e.leftOn(v.at(x - 1), v.at(x), v.at(y)) && e.rightOn(v.at(x + 1), v.at(x), v.at(y)) && (o = e.sqdist(v.at(x), v.at(y))) < p) {
                    p = o;
                    s = y % this.vertices.length;
                  }
                }
                if (x < s) {
                  t.append(v, x, s + 1);
                  if (0 != s) {
                    u.append(v, s, w.length);
                  }
                  u.append(v, 0, x + 1);
                } else {
                  if (0 != x) {
                    t.append(v, x, w.length);
                  }
                  t.append(v, 0, s + 1);
                  u.append(v, s, x + 1);
                }
              }
              if (t.vertices.length < u.vertices.length) {
                t.quickDecomp(a, b, c, d, f, h);
                u.quickDecomp(a, b, c, d, f, h);
              } else {
                u.quickDecomp(a, b, c, d, f, h);
                t.quickDecomp(a, b, c, d, f, h);
              }
              return a;
            }
          }
          a.push(this);
          return a;
        };
        g.prototype.removeCollinearPoints = function (a) {
          var b = 0;
          for (var c = this.vertices.length - 1; this.vertices.length > 3 && c >= 0; --c) {
            if (e.collinear(this.at(c - 1), this.at(c), this.at(c + 1), a)) {
              this.vertices.splice(c % this.vertices.length, 1);
              c--;
              b++;
            }
          }
          return b;
        };
      }, {
        "./Line": 1,
        "./Point": 2,
        "./Scalar": 4
      }],
      4: [function (a, b, c) {
        function d() {}
        b.exports = d;
        d.eq = function (a, b, c) {
          c = c || 0;
          return Math.abs(a - b) < c;
        };
      }, {}],
      5: [function (a, b, c) {
        b.exports = {
          Polygon: a("./Polygon"),
          Point: a("./Point")
        };
      }, {
        "./Point": 2,
        "./Polygon": 3
      }],
      6: [function (a, b, c) {
        b.exports = {
          name: "p2",
          version: "0.7.0",
          description: "A JavaScript 2D physics engine.",
          author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
          keywords: ["p2.js", "p2", "physics", "engine", "2d"],
          main: "./src/p2.js",
          engines: {
            node: "*"
          },
          repository: {
            type: "git",
            url: "https://github.com/schteppe/p2.js.git"
          },
          bugs: {
            url: "https://github.com/schteppe/p2.js/issues"
          },
          licenses: [{
            type: "MIT"
          }],
          devDependencies: {
            grunt: "^0.4.5",
            "grunt-contrib-jshint": "^0.11.2",
            "grunt-contrib-nodeunit": "^0.4.1",
            "grunt-contrib-uglify": "~0.4.0",
            "grunt-contrib-watch": "~0.5.0",
            "grunt-browserify": "~2.0.1",
            "grunt-contrib-concat": "^0.4.0"
          },
          dependencies: {
            "poly-decomp": "0.1.0"
          }
        };
      }, {}],
      7: [function (a, b, c) {
        function f(a) {
          this.lowerBound = d.create();
          if (a && a.lowerBound) {
            d.copy(this.lowerBound, a.lowerBound);
          }
          this.upperBound = d.create();
          if (a && a.upperBound) {
            d.copy(this.upperBound, a.upperBound);
          }
        }
        var d = a("../math/vec2");
        a("../utils/Utils");
        b.exports = f;
        var g = d.create();
        f.prototype.setFromPoints = function (a, b, c, e) {
          var f = this.lowerBound;
          var h = this.upperBound;
          if ("number" != typeof c) {
            c = 0;
          }
          if (0 !== c) {
            d.rotate(f, a[0], c);
          } else {
            d.copy(f, a[0]);
          }
          d.copy(h, f);
          var i = Math.cos(c);
          var j = Math.sin(c);
          for (var k = 1; k < a.length; k++) {
            var l = a[k];
            if (0 !== c) {
              var m = l[0];
              var n = l[1];
              g[0] = i * m - j * n;
              g[1] = j * m + i * n;
              l = g;
            }
            for (var o = 0; o < 2; o++) {
              if (l[o] > h[o]) {
                h[o] = l[o];
              }
              if (l[o] < f[o]) {
                f[o] = l[o];
              }
            }
          }
          if (b) {
            d.add(this.lowerBound, this.lowerBound, b);
            d.add(this.upperBound, this.upperBound, b);
          }
          if (e) {
            this.lowerBound[0] -= e;
            this.lowerBound[1] -= e;
            this.upperBound[0] += e;
            this.upperBound[1] += e;
          }
        };
        f.prototype.copy = function (a) {
          d.copy(this.lowerBound, a.lowerBound);
          d.copy(this.upperBound, a.upperBound);
        };
        f.prototype.extend = function (a) {
          for (var b = 2; b--;) {
            var c = a.lowerBound[b];
            if (this.lowerBound[b] > c) {
              this.lowerBound[b] = c;
            }
            var d = a.upperBound[b];
            if (this.upperBound[b] < d) {
              this.upperBound[b] = d;
            }
          }
        };
        f.prototype.overlaps = function (a) {
          var b = this.lowerBound;
          var c = this.upperBound;
          var d = a.lowerBound;
          var e = a.upperBound;
          return (d[0] <= c[0] && c[0] <= e[0] || b[0] <= e[0] && e[0] <= c[0]) && (d[1] <= c[1] && c[1] <= e[1] || b[1] <= e[1] && e[1] <= c[1]);
        };
        f.prototype.containsPoint = function (a) {
          var b = this.lowerBound;
          var c = this.upperBound;
          return b[0] <= a[0] && a[0] <= c[0] && b[1] <= a[1] && a[1] <= c[1];
        };
        f.prototype.overlapsRay = function (a) {
          var c = 1 / a.direction[0];
          var d = 1 / a.direction[1];
          var e = (this.lowerBound[0] - a.from[0]) * c;
          var f = (this.upperBound[0] - a.from[0]) * c;
          var g = (this.lowerBound[1] - a.from[1]) * d;
          var h = (this.upperBound[1] - a.from[1]) * d;
          var i = Math.max(Math.max(Math.min(e, f), Math.min(g, h)));
          var j = Math.min(Math.min(Math.max(e, f), Math.max(g, h)));
          return j < 0 ? -1 : i > j ? -1 : i;
        };
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57
      }],
      8: [function (a, b, c) {
        function f(a) {
          this.type = a;
          this.result = [];
          this.world = null;
          this.boundingVolumeType = f.AABB;
        }
        var d = a("../math/vec2");
        var e = a("../objects/Body");
        b.exports = f;
        f.AABB = 1;
        f.BOUNDING_CIRCLE = 2;
        f.prototype.setWorld = function (a) {
          this.world = a;
        };
        f.prototype.getCollisionPairs = function (a) {};
        var g = d.create();
        f.boundingRadiusCheck = function (a, b) {
          d.sub(g, a.position, b.position);
          var c = d.squaredLength(g);
          var e = a.boundingRadius + b.boundingRadius;
          return c <= e * e;
        };
        f.aabbCheck = function (a, b) {
          return a.getAABB().overlaps(b.getAABB());
        };
        f.prototype.boundingVolumeCheck = function (a, b) {
          var c;
          switch (this.boundingVolumeType) {
            case f.BOUNDING_CIRCLE:
              c = f.boundingRadiusCheck(a, b);
              break;
            case f.AABB:
              c = f.aabbCheck(a, b);
              break;
            default:
              throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType);
          }
          return c;
        };
        f.canCollide = function (a, b) {
          var c = e.KINEMATIC;
          var d = e.STATIC;
          return (a.type !== d || b.type !== d) && !(a.type === c && b.type === d || a.type === d && b.type === c) && (a.type !== c || b.type !== c) && (a.sleepState !== e.SLEEPING || b.sleepState !== e.SLEEPING) && !(a.sleepState === e.SLEEPING && b.type === d || b.sleepState === e.SLEEPING && a.type === d);
        };
        f.NAIVE = 1;
        f.SAP = 2;
      }, {
        "../math/vec2": 30,
        "../objects/Body": 31
      }],
      9: [function (a, b, c) {
        function j() {
          h.call(this, h.NAIVE);
        }
        a("../shapes/Circle");
        a("../shapes/Plane");
        a("../shapes/Shape");
        a("../shapes/Particle");
        var h = a("../collision/Broadphase");
        a("../math/vec2");
        b.exports = j;
        j.prototype = new h();
        j.prototype.constructor = j;
        j.prototype.getCollisionPairs = function (a) {
          var b = a.bodies;
          var c = this.result;
          c.length = 0;
          var d = 0;
          for (var e = b.length; d !== e; d++) {
            var f = b[d];
            for (var g = 0; g < d; g++) {
              var i = b[g];
              if (h.canCollide(f, i) && this.boundingVolumeCheck(f, i)) {
                c.push(f, i);
              }
            }
          }
          return c;
        };
        j.prototype.aabbQuery = function (a, b, c) {
          c = c || [];
          var d = a.bodies;
          for (var e = 0; e < d.length; e++) {
            var f = d[e];
            if (f.aabbNeedsUpdate) {
              f.updateAABB();
            }
            if (f.aabb.overlaps(b)) {
              c.push(f);
            }
          }
          return c;
        };
      }, {
        "../collision/Broadphase": 8,
        "../math/vec2": 30,
        "../shapes/Circle": 39,
        "../shapes/Particle": 43,
        "../shapes/Plane": 44,
        "../shapes/Shape": 45
      }],
      10: [function (a, b, c) {
        function N() {
          this.contactEquations = [];
          this.frictionEquations = [];
          this.enableFriction = true;
          this.enabledEquations = true;
          this.slipForce = 10;
          this.frictionCoefficient = .3;
          this.surfaceVelocity = 0;
          this.contactEquationPool = new i({
            size: 32
          });
          this.frictionEquationPool = new j({
            size: 64
          });
          this.restitution = 0;
          this.stiffness = l.DEFAULT_STIFFNESS;
          this.relaxation = l.DEFAULT_RELAXATION;
          this.frictionStiffness = l.DEFAULT_STIFFNESS;
          this.frictionRelaxation = l.DEFAULT_RELAXATION;
          this.enableFrictionReduction = true;
          this.collidingBodiesLastStep = new k();
          this.contactSkinSize = .01;
        }
        function Q(a, b) {
          d.set(a.vertices[0], .5 * -b.length, -b.radius);
          d.set(a.vertices[1], .5 * b.length, -b.radius);
          d.set(a.vertices[2], .5 * b.length, b.radius);
          d.set(a.vertices[3], .5 * -b.length, b.radius);
        }
        function $(a, b, c, g) {
          var m = b.vertices;
          var n = null;
          for (var o = 0; o !== m.length + 1; o++) {
            var p = m[o % m.length];
            var q = m[(o + 1) % m.length];
            d.rotate(W, p, g);
            d.rotate(X, q, g);
            f(W, W, c);
            f(X, X, c);
            e(Y, W, a);
            e(Z, X, a);
            var r = d.crossLength(Y, Z);
            if (null === n) {
              n = r;
            }
            if (r * n <= 0) {
              return false;
            }
            n = r;
          }
          return true;
        }
        var d = a("../math/vec2");
        var e = d.sub;
        var f = d.add;
        var g = d.dot;
        a("../utils/Utils");
        var i = a("../utils/ContactEquationPool");
        var j = a("../utils/FrictionEquationPool");
        var k = a("../utils/TupleDictionary");
        var l = a("../equations/Equation");
        a("../equations/ContactEquation");
        a("../equations/FrictionEquation");
        var o = a("../shapes/Circle");
        var p = a("../shapes/Convex");
        var q = a("../shapes/Shape");
        a("../objects/Body");
        var s = a("../shapes/Box");
        b.exports = N;
        var t = d.fromValues(0, 1);
        var u = d.fromValues(0, 0);
        var v = d.fromValues(0, 0);
        var w = d.fromValues(0, 0);
        var x = d.fromValues(0, 0);
        var y = d.fromValues(0, 0);
        var z = d.fromValues(0, 0);
        var A = d.fromValues(0, 0);
        var B = d.fromValues(0, 0);
        var C = d.fromValues(0, 0);
        var D = d.fromValues(0, 0);
        var E = d.fromValues(0, 0);
        var F = d.fromValues(0, 0);
        var G = d.fromValues(0, 0);
        var H = d.fromValues(0, 0);
        var I = d.fromValues(0, 0);
        var J = d.fromValues(0, 0);
        var K = d.fromValues(0, 0);
        var L = d.fromValues(0, 0);
        var M = [];
        var O = d.create();
        var P = d.create();
        N.prototype.bodiesOverlap = function (a, b) {
          var e = 0;
          for (var f = a.shapes.length; e !== f; e++) {
            var g = a.shapes[e];
            a.toWorldFrame(O, g.position);
            var h = 0;
            for (var i = b.shapes.length; h !== i; h++) {
              var j = b.shapes[h];
              b.toWorldFrame(P, j.position);
              if (this[g.type | j.type](a, g, O, g.angle + a.angle, b, j, P, j.angle + b.angle, true)) {
                return true;
              }
            }
          }
          return false;
        };
        N.prototype.collidedLastStep = function (a, b) {
          var c = 0 | a.id;
          var d = 0 | b.id;
          return !!this.collidingBodiesLastStep.get(c, d);
        };
        N.prototype.reset = function () {
          this.collidingBodiesLastStep.reset();
          var a = this.contactEquations;
          for (var b = a.length; b--;) {
            var c = a[b];
            var d = c.bodyA.id;
            var e = c.bodyB.id;
            this.collidingBodiesLastStep.set(d, e, true);
          }
          var f = this.contactEquations;
          var g = this.frictionEquations;
          for (var h = 0; h < f.length; h++) {
            this.contactEquationPool.release(f[h]);
          }
          for (var h = 0; h < g.length; h++) {
            this.frictionEquationPool.release(g[h]);
          }
          this.contactEquations.length = this.frictionEquations.length = 0;
        };
        N.prototype.createContactEquation = function (a, b, c, d) {
          var e = this.contactEquationPool.get();
          e.bodyA = a;
          e.bodyB = b;
          e.shapeA = c;
          e.shapeB = d;
          e.restitution = this.restitution;
          e.firstImpact = !this.collidedLastStep(a, b);
          e.stiffness = this.stiffness;
          e.relaxation = this.relaxation;
          e.needsUpdate = true;
          e.enabled = this.enabledEquations;
          e.offset = this.contactSkinSize;
          return e;
        };
        N.prototype.createFrictionEquation = function (a, b, c, d) {
          var e = this.frictionEquationPool.get();
          e.bodyA = a;
          e.bodyB = b;
          e.shapeA = c;
          e.shapeB = d;
          e.setSlipForce(this.slipForce);
          e.frictionCoefficient = this.frictionCoefficient;
          e.relativeVelocity = this.surfaceVelocity;
          e.enabled = this.enabledEquations;
          e.needsUpdate = true;
          e.stiffness = this.frictionStiffness;
          e.relaxation = this.frictionRelaxation;
          e.contactEquations.length = 0;
          return e;
        };
        N.prototype.createFrictionFromContact = function (a) {
          var b = this.createFrictionEquation(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
          d.copy(b.contactPointA, a.contactPointA);
          d.copy(b.contactPointB, a.contactPointB);
          d.rotate90cw(b.t, a.normalA);
          b.contactEquations.push(a);
          return b;
        };
        N.prototype.createFrictionFromAverage = function (a) {
          var b = this.contactEquations[this.contactEquations.length - 1];
          var c = this.createFrictionEquation(b.bodyA, b.bodyB, b.shapeA, b.shapeB);
          var e = b.bodyA;
          b.bodyB;
          d.set(c.contactPointA, 0, 0);
          d.set(c.contactPointB, 0, 0);
          d.set(c.t, 0, 0);
          for (var g = 0; g !== a; g++) {
            b = this.contactEquations[this.contactEquations.length - 1 - g];
            if (b.bodyA === e) {
              d.add(c.t, c.t, b.normalA);
              d.add(c.contactPointA, c.contactPointA, b.contactPointA);
              d.add(c.contactPointB, c.contactPointB, b.contactPointB);
            } else {
              d.sub(c.t, c.t, b.normalA);
              d.add(c.contactPointA, c.contactPointA, b.contactPointB);
              d.add(c.contactPointB, c.contactPointB, b.contactPointA);
            }
            c.contactEquations.push(b);
          }
          var h = 1 / a;
          d.scale(c.contactPointA, c.contactPointA, h);
          d.scale(c.contactPointB, c.contactPointB, h);
          d.normalize(c.t, c.t);
          d.rotate90cw(c.t, c.t);
          return c;
        };
        N.prototype[q.LINE | q.CONVEX] = N.prototype.convexLine = function (a, b, c, d, e, f, g, h, i) {
          return !i && 0;
        };
        N.prototype[q.LINE | q.BOX] = N.prototype.lineBox = function (a, b, c, d, e, f, g, h, i) {
          return !i && 0;
        };
        var R = new s({
          width: 1,
          height: 1
        });
        var S = d.create();
        N.prototype[q.CAPSULE | q.CONVEX] = N.prototype[q.CAPSULE | q.BOX] = N.prototype.convexCapsule = function (a, b, c, e, f, g, h, i, j) {
          d.set(S, g.length / 2, 0);
          d.rotate(S, S, i);
          d.add(S, S, h);
          var l = this.circleConvex(f, g, S, i, a, b, c, e, j, g.radius);
          d.set(S, -g.length / 2, 0);
          d.rotate(S, S, i);
          d.add(S, S, h);
          var m = this.circleConvex(f, g, S, i, a, b, c, e, j, g.radius);
          if (j && (l || m)) {
            return true;
          }
          Q(R, g);
          return this.convexConvex(a, b, c, e, f, R, h, i, j) + l + m;
        };
        N.prototype[q.CAPSULE | q.LINE] = N.prototype.lineCapsule = function (a, b, c, d, e, f, g, h, i) {
          return !i && 0;
        };
        var T = d.create();
        var U = d.create();
        var V = new s({
          width: 1,
          height: 1
        });
        N.prototype[q.CAPSULE | q.CAPSULE] = N.prototype.capsuleCapsule = function (a, b, c, e, f, g, h, i, j) {
          var k;
          var n = 0;
          for (var o = 0; o < 2; o++) {
            d.set(T, (0 === o ? -1 : 1) * b.length / 2, 0);
            d.rotate(T, T, e);
            d.add(T, T, c);
            for (var p = 0; p < 2; p++) {
              d.set(U, (0 === p ? -1 : 1) * g.length / 2, 0);
              d.rotate(U, U, i);
              d.add(U, U, h);
              if (this.enableFrictionReduction) {
                k = this.enableFriction;
                this.enableFriction = false;
              }
              var q = this.circleCircle(a, b, T, e, f, g, U, i, j, b.radius, g.radius);
              if (this.enableFrictionReduction) {
                this.enableFriction = k;
              }
              if (j && q) {
                return true;
              }
              n += q;
            }
          }
          if (this.enableFrictionReduction) {
            k = this.enableFriction;
            this.enableFriction = false;
          }
          Q(V, b);
          var s = this.convexCapsule(a, V, c, e, f, g, h, i, j);
          if (this.enableFrictionReduction) {
            this.enableFriction = k;
          }
          if (j && s) {
            return true;
          }
          n += s;
          if (this.enableFrictionReduction) {
            var k = this.enableFriction;
            this.enableFriction = false;
          }
          Q(V, g);
          var t = this.convexCapsule(f, V, h, i, a, b, c, e, j);
          if (this.enableFrictionReduction) {
            this.enableFriction = k;
          }
          return !(!j || !t) || (n += t, this.enableFrictionReduction && n && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(n)), n);
        };
        N.prototype[q.LINE | q.LINE] = N.prototype.lineLine = function (a, b, c, d, e, f, g, h, i) {
          return !i && 0;
        };
        N.prototype[q.PLANE | q.LINE] = N.prototype.planeLine = function (a, b, c, h, i, j, k, l, m) {
          var H = 0;
          d.set(u, -j.length / 2, 0);
          d.set(v, j.length / 2, 0);
          d.rotate(w, u, l);
          d.rotate(x, v, l);
          f(w, w, k);
          f(x, x, k);
          d.copy(u, w);
          d.copy(v, x);
          e(y, v, u);
          d.normalize(z, y);
          d.rotate90cw(C, z);
          d.rotate(B, t, h);
          M[0] = u;
          M[1] = v;
          for (var I = 0; I < M.length; I++) {
            var J = M[I];
            e(A, J, c);
            var K = g(A, B);
            if (K < 0) {
              if (m) {
                return true;
              }
              var L = this.createContactEquation(a, i, b, j);
              H++;
              d.copy(L.normalA, B);
              d.normalize(L.normalA, L.normalA);
              d.scale(A, B, K);
              e(L.contactPointA, J, A);
              e(L.contactPointA, L.contactPointA, a.position);
              e(L.contactPointB, J, k);
              f(L.contactPointB, L.contactPointB, k);
              e(L.contactPointB, L.contactPointB, i.position);
              this.contactEquations.push(L);
              if (!this.enableFrictionReduction) {
                if (this.enableFriction) {
                  this.frictionEquations.push(this.createFrictionFromContact(L));
                }
              }
            }
          }
          return !m && (this.enableFrictionReduction || H && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(H)), H);
        };
        N.prototype[q.PARTICLE | q.CAPSULE] = N.prototype.particleCapsule = function (a, b, c, d, e, f, g, h, i) {
          return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius, 0);
        };
        N.prototype[q.CIRCLE | q.LINE] = N.prototype.circleLine = function (a, b, c, h, i, j, k, l, m, n, o) {
          var n = n || 0;
          var o = undefined !== o ? o : b.radius;
          d.set(B, -j.length / 2, 0);
          d.set(C, j.length / 2, 0);
          d.rotate(D, B, l);
          d.rotate(E, C, l);
          f(D, D, k);
          f(E, E, k);
          d.copy(B, D);
          d.copy(C, E);
          e(z, C, B);
          d.normalize(A, z);
          d.rotate90cw(y, A);
          e(F, c, B);
          var T = g(F, y);
          e(x, B, k);
          e(G, c, k);
          var U = o + n;
          if (Math.abs(T) < U) {
            d.scale(u, y, T);
            e(w, c, u);
            d.scale(v, y, g(y, G));
            d.normalize(v, v);
            d.scale(v, v, n);
            f(w, w, v);
            var V = g(A, w);
            var W = g(A, B);
            var X = g(A, C);
            if (V > W && V < X) {
              if (m) {
                return true;
              }
              var Y = this.createContactEquation(a, i, b, j);
              d.scale(Y.normalA, u, -1);
              d.normalize(Y.normalA, Y.normalA);
              d.scale(Y.contactPointA, Y.normalA, o);
              f(Y.contactPointA, Y.contactPointA, c);
              e(Y.contactPointA, Y.contactPointA, a.position);
              e(Y.contactPointB, w, k);
              f(Y.contactPointB, Y.contactPointB, k);
              e(Y.contactPointB, Y.contactPointB, i.position);
              this.contactEquations.push(Y);
              if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(Y));
              }
              return 1;
            }
          }
          M[0] = B;
          M[1] = C;
          for (var Z = 0; Z < M.length; Z++) {
            var $ = M[Z];
            e(F, $, c);
            if (d.squaredLength(F) < Math.pow(U, 2)) {
              if (m) {
                return true;
              }
              var Y = this.createContactEquation(a, i, b, j);
              d.copy(Y.normalA, F);
              d.normalize(Y.normalA, Y.normalA);
              d.scale(Y.contactPointA, Y.normalA, o);
              f(Y.contactPointA, Y.contactPointA, c);
              e(Y.contactPointA, Y.contactPointA, a.position);
              e(Y.contactPointB, $, k);
              d.scale(H, Y.normalA, -n);
              f(Y.contactPointB, Y.contactPointB, H);
              f(Y.contactPointB, Y.contactPointB, k);
              e(Y.contactPointB, Y.contactPointB, i.position);
              this.contactEquations.push(Y);
              if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(Y));
              }
              return 1;
            }
          }
          return 0;
        };
        N.prototype[q.CIRCLE | q.CAPSULE] = N.prototype.circleCapsule = function (a, b, c, d, e, f, g, h, i) {
          return this.circleLine(a, b, c, d, e, f, g, h, i, f.radius);
        };
        N.prototype[q.CIRCLE | q.CONVEX] = N.prototype[q.CIRCLE | q.BOX] = N.prototype.circleConvex = function (a, b, c, g, h, i, j, k, l, m) {
          var m = "number" == typeof m ? m : b.radius;
          var V = false;
          var W = Number.MAX_VALUE;
          var Y = i.vertices;
          for (var Z = 0; Z !== Y.length + 1; Z++) {
            var _ = Y[Z % Y.length];
            var aa = Y[(Z + 1) % Y.length];
            d.rotate(u, _, k);
            d.rotate(v, aa, k);
            f(u, u, j);
            f(v, v, j);
            e(w, v, u);
            d.normalize(x, w);
            d.rotate90cw(y, x);
            d.scale(H, y, -b.radius);
            f(H, H, c);
            if ($(H, i, j, k)) {
              d.sub(I, u, H);
              var ba = Math.abs(d.dot(I, y));
              if (ba < W) {
                d.copy(J, H);
                W = ba;
                d.scale(G, y, ba);
                d.add(G, G, H);
                V = true;
              }
            }
          }
          if (V) {
            if (l) {
              return true;
            }
            var ca = this.createContactEquation(a, h, b, i);
            d.sub(ca.normalA, J, c);
            d.normalize(ca.normalA, ca.normalA);
            d.scale(ca.contactPointA, ca.normalA, m);
            f(ca.contactPointA, ca.contactPointA, c);
            e(ca.contactPointA, ca.contactPointA, a.position);
            e(ca.contactPointB, G, j);
            f(ca.contactPointB, ca.contactPointB, j);
            e(ca.contactPointB, ca.contactPointB, h.position);
            this.contactEquations.push(ca);
            if (this.enableFriction) {
              this.frictionEquations.push(this.createFrictionFromContact(ca));
            }
            return 1;
          }
          if (m > 0) {
            for (var Z = 0; Z < Y.length; Z++) {
              var da = Y[Z];
              d.rotate(E, da, k);
              f(E, E, j);
              e(D, E, c);
              if (d.squaredLength(D) < Math.pow(m, 2)) {
                if (l) {
                  return true;
                }
                var ca = this.createContactEquation(a, h, b, i);
                d.copy(ca.normalA, D);
                d.normalize(ca.normalA, ca.normalA);
                d.scale(ca.contactPointA, ca.normalA, m);
                f(ca.contactPointA, ca.contactPointA, c);
                e(ca.contactPointA, ca.contactPointA, a.position);
                e(ca.contactPointB, E, j);
                f(ca.contactPointB, ca.contactPointB, j);
                e(ca.contactPointB, ca.contactPointB, h.position);
                this.contactEquations.push(ca);
                if (this.enableFriction) {
                  this.frictionEquations.push(this.createFrictionFromContact(ca));
                }
                return 1;
              }
            }
          }
          return 0;
        };
        var W = d.create();
        var X = d.create();
        var Y = d.create();
        var Z = d.create();
        N.prototype[q.PARTICLE | q.CONVEX] = N.prototype[q.PARTICLE | q.BOX] = N.prototype.particleConvex = function (a, b, c, h, i, j, k, l, m) {
          var Z = Number.MAX_VALUE;
          var aa = false;
          var ba = j.vertices;
          if (!$(c, j, k, l)) {
            return 0;
          }
          if (m) {
            return true;
          }
          for (var da = 0; da !== ba.length + 1; da++) {
            var ea = ba[da % ba.length];
            var fa = ba[(da + 1) % ba.length];
            d.rotate(u, ea, l);
            d.rotate(v, fa, l);
            f(u, u, k);
            f(v, v, k);
            e(w, v, u);
            d.normalize(x, w);
            d.rotate90cw(y, x);
            e(D, c, u);
            g(D, y);
            e(z, u, k);
            e(A, c, k);
            d.sub(K, u, c);
            var ha = Math.abs(d.dot(K, y));
            if (ha < Z) {
              Z = ha;
              d.scale(G, y, ha);
              d.add(G, G, c);
              d.copy(L, y);
              aa = true;
            }
          }
          if (aa) {
            var ia = this.createContactEquation(a, i, b, j);
            d.scale(ia.normalA, L, -1);
            d.normalize(ia.normalA, ia.normalA);
            d.set(ia.contactPointA, 0, 0);
            f(ia.contactPointA, ia.contactPointA, c);
            e(ia.contactPointA, ia.contactPointA, a.position);
            e(ia.contactPointB, G, k);
            f(ia.contactPointB, ia.contactPointB, k);
            e(ia.contactPointB, ia.contactPointB, i.position);
            this.contactEquations.push(ia);
            if (this.enableFriction) {
              this.frictionEquations.push(this.createFrictionFromContact(ia));
            }
            return 1;
          }
          return 0;
        };
        N.prototype[q.CIRCLE] = N.prototype.circleCircle = function (a, b, c, g, h, i, j, k, l, m, n) {
          var m = m || b.radius;
          var n = n || i.radius;
          e(u, c, j);
          var p = m + n;
          if (d.squaredLength(u) > Math.pow(p, 2)) {
            return 0;
          }
          if (l) {
            return true;
          }
          var q = this.createContactEquation(a, h, b, i);
          e(q.normalA, j, c);
          d.normalize(q.normalA, q.normalA);
          d.scale(q.contactPointA, q.normalA, m);
          d.scale(q.contactPointB, q.normalA, -n);
          f(q.contactPointA, q.contactPointA, c);
          e(q.contactPointA, q.contactPointA, a.position);
          f(q.contactPointB, q.contactPointB, j);
          e(q.contactPointB, q.contactPointB, h.position);
          this.contactEquations.push(q);
          if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(q));
          }
          return 1;
        };
        N.prototype[q.PLANE | q.CONVEX] = N.prototype[q.PLANE | q.BOX] = N.prototype.planeConvex = function (a, b, c, h, i, j, k, l, m) {
          var q = 0;
          d.rotate(v, t, h);
          for (var r = 0; r !== j.vertices.length; r++) {
            var s = j.vertices[r];
            d.rotate(u, s, l);
            f(u, u, k);
            e(w, u, c);
            if (g(w, v) <= 0) {
              if (m) {
                return true;
              }
              q++;
              var x = this.createContactEquation(a, i, b, j);
              e(w, u, c);
              d.copy(x.normalA, v);
              var y = g(w, x.normalA);
              d.scale(w, x.normalA, y);
              e(x.contactPointB, u, i.position);
              e(x.contactPointA, u, w);
              e(x.contactPointA, x.contactPointA, a.position);
              this.contactEquations.push(x);
              if (!this.enableFrictionReduction) {
                if (this.enableFriction) {
                  this.frictionEquations.push(this.createFrictionFromContact(x));
                }
              }
            }
          }
          if (this.enableFrictionReduction && this.enableFriction && q) {
            this.frictionEquations.push(this.createFrictionFromAverage(q));
          }
          return q;
        };
        N.prototype[q.PARTICLE | q.PLANE] = N.prototype.particlePlane = function (a, b, c, f, h, i, j, k, l) {
          k = k || 0;
          e(u, c, j);
          d.rotate(v, t, k);
          var o = g(u, v);
          if (o > 0) {
            return 0;
          }
          if (l) {
            return true;
          }
          var p = this.createContactEquation(h, a, i, b);
          d.copy(p.normalA, v);
          d.scale(u, p.normalA, o);
          e(p.contactPointA, c, u);
          e(p.contactPointA, p.contactPointA, h.position);
          e(p.contactPointB, c, a.position);
          this.contactEquations.push(p);
          if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(p));
          }
          return 1;
        };
        N.prototype[q.CIRCLE | q.PARTICLE] = N.prototype.circleParticle = function (a, b, c, g, h, i, j, k, l) {
          e(u, j, c);
          if (d.squaredLength(u) > Math.pow(b.radius, 2)) {
            return 0;
          }
          if (l) {
            return true;
          }
          var n = this.createContactEquation(a, h, b, i);
          d.copy(n.normalA, u);
          d.normalize(n.normalA, n.normalA);
          d.scale(n.contactPointA, n.normalA, b.radius);
          f(n.contactPointA, n.contactPointA, c);
          e(n.contactPointA, n.contactPointA, a.position);
          e(n.contactPointB, j, h.position);
          this.contactEquations.push(n);
          if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(n));
          }
          return 1;
        };
        var _ = new o({
          radius: 1
        });
        var aa = d.create();
        var ba = d.create();
        d.create();
        N.prototype[q.PLANE | q.CAPSULE] = N.prototype.planeCapsule = function (a, b, c, e, g, h, i, j, k) {
          d.set(aa, -h.length / 2, 0);
          d.rotate(aa, aa, j);
          f(aa, aa, i);
          d.set(ba, h.length / 2, 0);
          d.rotate(ba, ba, j);
          f(ba, ba, i);
          _.radius = h.radius;
          var p;
          if (this.enableFrictionReduction) {
            p = this.enableFriction;
            this.enableFriction = false;
          }
          var q = this.circlePlane(g, _, aa, 0, a, b, c, e, k);
          var r = this.circlePlane(g, _, ba, 0, a, b, c, e, k);
          if (this.enableFrictionReduction) {
            this.enableFriction = p;
          }
          if (k) {
            return q || r;
          }
          var s = q + r;
          if (this.enableFrictionReduction && s) {
            this.frictionEquations.push(this.createFrictionFromAverage(s));
          }
          return s;
        };
        N.prototype[q.CIRCLE | q.PLANE] = N.prototype.circlePlane = function (a, b, c, h, i, j, k, l, m) {
          var x = l;
          x = x || 0;
          e(u, c, k);
          d.rotate(v, t, x);
          var B = g(v, u);
          if (B > b.radius) {
            return 0;
          }
          if (m) {
            return true;
          }
          var C = this.createContactEquation(i, a, j, b);
          d.copy(C.normalA, v);
          d.scale(C.contactPointB, C.normalA, -b.radius);
          f(C.contactPointB, C.contactPointB, c);
          e(C.contactPointB, C.contactPointB, a.position);
          d.scale(w, C.normalA, B);
          e(C.contactPointA, u, w);
          f(C.contactPointA, C.contactPointA, k);
          e(C.contactPointA, C.contactPointA, i.position);
          this.contactEquations.push(C);
          if (this.enableFriction) {
            this.frictionEquations.push(this.createFrictionFromContact(C));
          }
          return 1;
        };
        N.prototype[q.CONVEX] = N.prototype[q.CONVEX | q.BOX] = N.prototype[q.BOX] = N.prototype.convexConvex = function (a, b, c, h, i, j, k, l, m, n) {
          var G = 0;
          var n = "number" == typeof n ? n : 0;
          if (!N.findSeparatingAxis(b, c, h, j, k, l, u)) {
            return 0;
          }
          e(B, k, c);
          if (g(u, B) > 0) {
            d.scale(u, u, -1);
          }
          var I = N.getClosestEdge(b, h, u, true);
          var J = N.getClosestEdge(j, l, u);
          if (-1 === I || -1 === J) {
            return 0;
          }
          for (var K = 0; K < 2; K++) {
            var L = I;
            var M = J;
            var O = b;
            var P = j;
            var Q = c;
            var R = k;
            var S = h;
            var T = l;
            var U = a;
            var V = i;
            if (0 === K) {
              var W;
              W = L;
              L = M;
              M = W;
              W = O;
              O = P;
              P = W;
              W = Q;
              Q = R;
              R = W;
              W = S;
              S = T;
              T = W;
              W = U;
              U = V;
              V = W;
            }
            for (var X = M; X < M + 2; X++) {
              var Y = P.vertices[(X + P.vertices.length) % P.vertices.length];
              d.rotate(v, Y, T);
              f(v, v, R);
              var Z = 0;
              for (var $ = L - 1; $ < L + 2; $++) {
                var _ = O.vertices[($ + O.vertices.length) % O.vertices.length];
                var aa = O.vertices[($ + 1 + O.vertices.length) % O.vertices.length];
                d.rotate(w, _, S);
                d.rotate(x, aa, S);
                f(w, w, Q);
                f(x, x, Q);
                e(y, x, w);
                d.rotate90cw(C, y);
                d.normalize(C, C);
                e(B, v, w);
                var ba = g(C, B);
                if ($ === L && ba <= n || $ !== L && ba <= 0) {
                  Z++;
                }
              }
              if (Z >= 3) {
                if (m) {
                  return true;
                }
                var ca = this.createContactEquation(U, V, O, P);
                G++;
                var _ = O.vertices[L % O.vertices.length];
                var aa = O.vertices[(L + 1) % O.vertices.length];
                d.rotate(w, _, S);
                d.rotate(x, aa, S);
                f(w, w, Q);
                f(x, x, Q);
                e(y, x, w);
                d.rotate90cw(ca.normalA, y);
                d.normalize(ca.normalA, ca.normalA);
                e(B, v, w);
                var ba = g(ca.normalA, B);
                d.scale(A, ca.normalA, ba);
                e(ca.contactPointA, v, Q);
                e(ca.contactPointA, ca.contactPointA, A);
                f(ca.contactPointA, ca.contactPointA, Q);
                e(ca.contactPointA, ca.contactPointA, U.position);
                e(ca.contactPointB, v, R);
                f(ca.contactPointB, ca.contactPointB, R);
                e(ca.contactPointB, ca.contactPointB, V.position);
                this.contactEquations.push(ca);
                if (!this.enableFrictionReduction) {
                  if (this.enableFriction) {
                    this.frictionEquations.push(this.createFrictionFromContact(ca));
                  }
                }
              }
            }
          }
          if (this.enableFrictionReduction && this.enableFriction && G) {
            this.frictionEquations.push(this.createFrictionFromAverage(G));
          }
          return G;
        };
        var da = d.fromValues(0, 0);
        N.projectConvexOntoAxis = function (a, b, c, e, f) {
          var j;
          var k;
          var h = null;
          var i = null;
          d.rotate(da, e, -c);
          for (var m = 0; m < a.vertices.length; m++) {
            j = a.vertices[m];
            k = g(j, da);
            if (null === h || k > h) {
              h = k;
            }
            if (null === i || k < i) {
              i = k;
            }
          }
          if (i > h) {
            i = h;
            h = i;
          }
          var o = g(b, e);
          d.set(f, i + o, h + o);
        };
        var ea = d.fromValues(0, 0);
        var fa = d.fromValues(0, 0);
        var ga = d.fromValues(0, 0);
        var ha = d.fromValues(0, 0);
        var ia = d.fromValues(0, 0);
        var ja = d.fromValues(0, 0);
        N.findSeparatingAxis = function (a, b, c, f, g, h, i) {
          var j = null;
          var k = false;
          var l = false;
          if (a instanceof s && f instanceof s) {
            for (var t = 0; 2 !== t; t++) {
              var u = a;
              var v = c;
              if (1 === t) {
                u = f;
                v = h;
              }
              for (var w = 0; 2 !== w; w++) {
                if (0 === w) {
                  d.set(ha, 0, 1);
                } else if (1 === w) {
                  d.set(ha, 1, 0);
                }
                if (0 !== v) {
                  d.rotate(ha, ha, v);
                }
                N.projectConvexOntoAxis(a, b, c, ha, ia);
                N.projectConvexOntoAxis(f, g, h, ha, ja);
                var x = ia;
                var y = ja;
                if (ia[0] > ja[0]) {
                  y = ia;
                  x = ja;
                  true;
                }
                var A = y[0] - x[1];
                k = A <= 0;
                if (null === j || A > j) {
                  d.copy(i, ha);
                  j = A;
                  l = k;
                }
              }
            }
          } else {
            for (var t = 0; 2 !== t; t++) {
              var u = a;
              var v = c;
              if (1 === t) {
                u = f;
                v = h;
              }
              for (var w = 0; w !== u.vertices.length; w++) {
                d.rotate(fa, u.vertices[w], v);
                d.rotate(ga, u.vertices[(w + 1) % u.vertices.length], v);
                e(ea, ga, fa);
                d.rotate90cw(ha, ea);
                d.normalize(ha, ha);
                N.projectConvexOntoAxis(a, b, c, ha, ia);
                N.projectConvexOntoAxis(f, g, h, ha, ja);
                var x = ia;
                var y = ja;
                if (ia[0] > ja[0]) {
                  y = ia;
                  x = ja;
                  true;
                }
                var A = y[0] - x[1];
                k = A <= 0;
                if (null === j || A > j) {
                  d.copy(i, ha);
                  j = A;
                  l = k;
                }
              }
            }
          }
          return l;
        };
        var ka = d.fromValues(0, 0);
        var la = d.fromValues(0, 0);
        var ma = d.fromValues(0, 0);
        N.getClosestEdge = function (a, b, c, f) {
          d.rotate(ka, c, -b);
          if (f) {
            d.scale(ka, ka, -1);
          }
          var k = -1;
          var l = a.vertices.length;
          var m = -1;
          for (var n = 0; n !== l; n++) {
            e(la, a.vertices[(n + 1) % l], a.vertices[n % l]);
            d.rotate90cw(ma, la);
            d.normalize(ma, ma);
            var o = g(ma, ka);
            if (-1 === k || o > m) {
              k = n % l;
              m = o;
            }
          }
          return k;
        };
        var na = d.create();
        var oa = d.create();
        var pa = d.create();
        var qa = d.create();
        var ra = d.create();
        var sa = d.create();
        var ta = d.create();
        N.prototype[q.CIRCLE | q.HEIGHTFIELD] = N.prototype.circleHeightfield = function (a, b, c, g, h, i, j, k, l, m) {
          var n = i.heights;
          var m = m || b.radius;
          var o = i.elementWidth;
          var w = Math.floor((c[0] - m - j[0]) / o);
          var x = Math.ceil((c[0] + m - j[0]) / o);
          if (w < 0) {
            w = 0;
          }
          if (x >= n.length) {
            x = n.length - 1;
          }
          var y = n[w];
          var z = n[x];
          for (var A = w; A < x; A++) {
            if (n[A] < z) {
              z = n[A];
            }
            if (n[A] > y) {
              y = n[A];
            }
          }
          if (c[1] - m > y) {
            return !l && 0;
          }
          var B = false;
          for (var A = w; A < x; A++) {
            d.set(pa, A * o, n[A]);
            d.set(qa, (A + 1) * o, n[A + 1]);
            d.add(pa, pa, j);
            d.add(qa, qa, j);
            d.sub(sa, qa, pa);
            d.rotate(sa, sa, Math.PI / 2);
            d.normalize(sa, sa);
            d.scale(na, sa, -m);
            d.add(na, na, c);
            d.sub(oa, na, pa);
            var C = d.dot(oa, sa);
            if (na[0] >= pa[0] && na[0] < qa[0] && C <= 0) {
              if (l) {
                return true;
              }
              B = true;
              d.scale(oa, sa, -C);
              d.add(ra, na, oa);
              d.copy(ta, sa);
              var D = this.createContactEquation(h, a, i, b);
              d.copy(D.normalA, ta);
              d.scale(D.contactPointB, D.normalA, -m);
              f(D.contactPointB, D.contactPointB, c);
              e(D.contactPointB, D.contactPointB, a.position);
              d.copy(D.contactPointA, ra);
              d.sub(D.contactPointA, D.contactPointA, h.position);
              this.contactEquations.push(D);
              if (this.enableFriction) {
                this.frictionEquations.push(this.createFrictionFromContact(D));
              }
            }
          }
          B = false;
          if (m > 0) {
            for (var A = w; A <= x; A++) {
              d.set(pa, A * o, n[A]);
              d.add(pa, pa, j);
              d.sub(oa, c, pa);
              if (d.squaredLength(oa) < Math.pow(m, 2)) {
                if (l) {
                  return true;
                }
                B = true;
                var D = this.createContactEquation(h, a, i, b);
                d.copy(D.normalA, oa);
                d.normalize(D.normalA, D.normalA);
                d.scale(D.contactPointB, D.normalA, -m);
                f(D.contactPointB, D.contactPointB, c);
                e(D.contactPointB, D.contactPointB, a.position);
                e(D.contactPointA, pa, j);
                f(D.contactPointA, D.contactPointA, j);
                e(D.contactPointA, D.contactPointA, h.position);
                this.contactEquations.push(D);
                if (this.enableFriction) {
                  this.frictionEquations.push(this.createFrictionFromContact(D));
                }
              }
            }
          }
          return B ? 1 : 0;
        };
        var ua = d.create();
        var va = d.create();
        var wa = d.create();
        var xa = new p({
          vertices: [d.create(), d.create(), d.create(), d.create()]
        });
        N.prototype[q.BOX | q.HEIGHTFIELD] = N.prototype[q.CONVEX | q.HEIGHTFIELD] = N.prototype.convexHeightfield = function (a, b, c, e, f, g, h, i, j) {
          var k = g.heights;
          var l = g.elementWidth;
          var q = Math.floor((a.aabb.lowerBound[0] - h[0]) / l);
          var r = Math.ceil((a.aabb.upperBound[0] - h[0]) / l);
          if (q < 0) {
            q = 0;
          }
          if (r >= k.length) {
            r = k.length - 1;
          }
          var s = k[q];
          var t = k[r];
          for (var u = q; u < r; u++) {
            if (k[u] < t) {
              t = k[u];
            }
            if (k[u] > s) {
              s = k[u];
            }
          }
          if (a.aabb.lowerBound[1] > s) {
            return !j && 0;
          }
          var w = 0;
          for (var u = q; u < r; u++) {
            d.set(ua, u * l, k[u]);
            d.set(va, (u + 1) * l, k[u + 1]);
            d.add(ua, ua, h);
            d.add(va, va, h);
            var x = 100;
            d.set(wa, .5 * (va[0] + ua[0]), .5 * (va[1] + ua[1] - 100));
            d.sub(xa.vertices[0], va, wa);
            d.sub(xa.vertices[1], ua, wa);
            d.copy(xa.vertices[2], xa.vertices[1]);
            d.copy(xa.vertices[3], xa.vertices[0]);
            xa.vertices[2][1] -= 100;
            xa.vertices[3][1] -= 100;
            w += this.convexConvex(a, b, c, e, f, xa, wa, 0, j);
          }
          return w;
        };
      }, {
        "../equations/ContactEquation": 21,
        "../equations/Equation": 22,
        "../equations/FrictionEquation": 23,
        "../math/vec2": 30,
        "../objects/Body": 31,
        "../shapes/Box": 37,
        "../shapes/Circle": 39,
        "../shapes/Convex": 40,
        "../shapes/Shape": 45,
        "../utils/ContactEquationPool": 48,
        "../utils/FrictionEquationPool": 49,
        "../utils/TupleDictionary": 56,
        "../utils/Utils": 57
      }],
      11: [function (a, b, c) {
        function h(a) {
          a = a || {};
          this.from = a.from ? d.fromValues(a.from[0], a.from[1]) : d.create();
          this.to = a.to ? d.fromValues(a.to[0], a.to[1]) : d.create();
          this.checkCollisionResponse = undefined === a.checkCollisionResponse || a.checkCollisionResponse;
          this.skipBackfaces = !!a.skipBackfaces;
          this.collisionMask = undefined !== a.collisionMask ? a.collisionMask : -1;
          this.collisionGroup = undefined !== a.collisionGroup ? a.collisionGroup : -1;
          this.mode = undefined !== a.mode ? a.mode : h.ANY;
          this.callback = a.callback || function (a) {};
          this.direction = d.create();
          this.length = 1;
          this.update();
        }
        function m(a, b, c) {
          d.sub(k, c, a);
          var e = d.dot(k, b);
          d.scale(l, b, e);
          d.add(l, l, a);
          return d.squaredDistance(c, l);
        }
        b.exports = h;
        var d = a("../math/vec2");
        a("../collision/RaycastResult");
        a("../shapes/Shape");
        a("../collision/AABB");
        h.prototype.constructor = h;
        h.CLOSEST = 1;
        h.ANY = 2;
        h.ALL = 4;
        h.prototype.update = function () {
          var a = this.direction;
          d.sub(a, this.to, this.from);
          this.length = d.length(a);
          d.normalize(a, a);
        };
        h.prototype.intersectBodies = function (a, b) {
          var c = 0;
          for (var d = b.length; !a.shouldStop(this) && c < d; c++) {
            var e = b[c];
            var f = e.getAABB();
            if (f.overlapsRay(this) >= 0 || f.containsPoint(this.from)) {
              this.intersectBody(a, e);
            }
          }
        };
        var i = d.create();
        h.prototype.intersectBody = function (a, b) {
          var c = this.checkCollisionResponse;
          if (!c || b.collisionResponse) {
            var f = 0;
            for (var g = b.shapes.length; f < g; f++) {
              var h = b.shapes[f];
              if ((!c || h.collisionResponse) && 0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask)) {
                d.rotate(i, h.position, b.angle);
                d.add(i, i, b.position);
                var j = h.angle + b.angle;
                this.intersectShape(a, h, j, i, b);
                if (a.shouldStop(this)) {
                  break;
                }
              }
            }
          }
        };
        h.prototype.intersectShape = function (a, b, c, d, e) {
          if (!(m(this.from, this.direction, d) > b.boundingRadius * b.boundingRadius)) {
            this._currentBody = e;
            this._currentShape = b;
            b.raycast(a, this, d, c);
            this._currentBody = this._currentShape = null;
          }
        };
        h.prototype.getAABB = function (a) {
          var b = this.to;
          var c = this.from;
          d.set(a.lowerBound, Math.min(b[0], c[0]), Math.min(b[1], c[1]));
          d.set(a.upperBound, Math.max(b[0], c[0]), Math.max(b[1], c[1]));
        };
        d.create();
        h.prototype.reportIntersection = function (a, b, c, e) {
          this.from;
          this.to;
          var i = this._currentShape;
          var j = this._currentBody;
          if (!(this.skipBackfaces && d.dot(c, this.direction) > 0)) {
            switch (this.mode) {
              case h.ALL:
                a.set(c, i, j, b, e);
                this.callback(a);
                break;
              case h.CLOSEST:
                if (b < a.fraction || !a.hasHit()) {
                  a.set(c, i, j, b, e);
                }
                break;
              case h.ANY:
                a.set(c, i, j, b, e);
            }
          }
        };
        var k = d.create();
        var l = d.create();
      }, {
        "../collision/AABB": 7,
        "../collision/RaycastResult": 12,
        "../math/vec2": 30,
        "../shapes/Shape": 45
      }],
      12: [function (a, b, c) {
        function f() {
          this.normal = d.create();
          this.shape = null;
          this.body = null;
          this.faceIndex = -1;
          this.fraction = -1;
          this.isStopped = false;
        }
        var d = a("../math/vec2");
        var e = a("../collision/Ray");
        b.exports = f;
        f.prototype.reset = function () {
          d.set(this.normal, 0, 0);
          this.shape = null;
          this.body = null;
          this.faceIndex = -1;
          this.fraction = -1;
          this.isStopped = false;
        };
        f.prototype.getHitDistance = function (a) {
          return d.distance(a.from, a.to) * this.fraction;
        };
        f.prototype.hasHit = function () {
          return -1 !== this.fraction;
        };
        f.prototype.getHitPoint = function (a, b) {
          d.lerp(a, b.from, b.to, this.fraction);
        };
        f.prototype.stop = function () {
          this.isStopped = true;
        };
        f.prototype.shouldStop = function (a) {
          return this.isStopped || -1 !== this.fraction && a.mode === e.ANY;
        };
        f.prototype.set = function (a, b, c, e, f) {
          d.copy(this.normal, a);
          this.shape = b;
          this.body = c;
          this.fraction = e;
          this.faceIndex = f;
        };
      }, {
        "../collision/Ray": 11,
        "../math/vec2": 30
      }],
      13: [function (a, b, c) {
        function f() {
          e.call(this, e.SAP);
          this.axisList = [];
          this.axisIndex = 0;
          var a = this;
          this._addBodyHandler = function (b) {
            a.axisList.push(b.body);
          };
          this._removeBodyHandler = function (b) {
            var c = a.axisList.indexOf(b.body);
            if (-1 !== c) {
              a.axisList.splice(c, 1);
            }
          };
        }
        var d = a("../utils/Utils");
        var e = a("../collision/Broadphase");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.setWorld = function (a) {
          this.axisList.length = 0;
          d.appendArray(this.axisList, a.bodies);
          a.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler);
          a.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler);
          this.world = a;
        };
        f.sortAxisList = function (a, b) {
          b |= 0;
          var c = 1;
          for (var d = a.length; c < d; c++) {
            var e = a[c];
            for (var f = c - 1; f >= 0 && !(a[f].aabb.lowerBound[b] <= e.aabb.lowerBound[b]); f--) {
              a[f + 1] = a[f];
            }
            a[f + 1] = e;
          }
          return a;
        };
        f.prototype.sortList = function () {
          var a = this.axisList;
          var b = this.axisIndex;
          f.sortAxisList(a, b);
        };
        f.prototype.getCollisionPairs = function (a) {
          var b = this.axisList;
          var c = this.result;
          var d = this.axisIndex;
          c.length = 0;
          for (var f = b.length; f--;) {
            var g = b[f];
            if (g.aabbNeedsUpdate) {
              g.updateAABB();
            }
          }
          this.sortList();
          var h = 0;
          for (var i = 0 | b.length; h !== i; h++) {
            var j = b[h];
            for (var k = h + 1; k < i; k++) {
              var l = b[k];
              var m = l.aabb.lowerBound[d] <= j.aabb.upperBound[d];
              if (!m) {
                break;
              }
              if (e.canCollide(j, l) && this.boundingVolumeCheck(j, l)) {
                c.push(j, l);
              }
            }
          }
          return c;
        };
        f.prototype.aabbQuery = function (a, b, c) {
          c = c || [];
          this.sortList();
          var d = this.axisIndex;
          var e = "x";
          if (1 === d) {
            e = "y";
          }
          if (2 === d) {
            e = "z";
          }
          var f = this.axisList;
          for (var i = 0; i < f.length; i++) {
            var f;
            var i;
            var j = f[i];
            if (j.aabbNeedsUpdate) {
              j.updateAABB();
            }
            if (j.aabb.overlaps(b)) {
              c.push(j);
            }
          }
          return c;
        };
      }, {
        "../collision/Broadphase": 8,
        "../utils/Utils": 57
      }],
      14: [function (a, b, c) {
        function e(a, b, c, e) {
          this.type = c;
          e = d.defaults(e, {
            collideConnected: true,
            wakeUpBodies: true
          });
          this.equations = [];
          this.bodyA = a;
          this.bodyB = b;
          this.collideConnected = e.collideConnected;
          if (e.wakeUpBodies) {
            if (a) {
              a.wakeUp();
            }
            if (b) {
              b.wakeUp();
            }
          }
        }
        b.exports = e;
        var d = a("../utils/Utils");
        e.prototype.update = function () {
          throw new Error("method update() not implmemented in this Constraint subclass!");
        };
        e.DISTANCE = 1;
        e.GEAR = 2;
        e.LOCK = 3;
        e.PRISMATIC = 4;
        e.REVOLUTE = 5;
        e.prototype.setStiffness = function (a) {
          var b = this.equations;
          for (var c = 0; c !== b.length; c++) {
            var d = b[c];
            d.stiffness = a;
            d.needsUpdate = true;
          }
        };
        e.prototype.setRelaxation = function (a) {
          var b = this.equations;
          for (var c = 0; c !== b.length; c++) {
            var d = b[c];
            d.relaxation = a;
            d.needsUpdate = true;
          }
        };
      }, {
        "../utils/Utils": 57
      }],
      15: [function (a, b, c) {
        function h(a, b, c) {
          c = g.defaults(c, {
            localAnchorA: [0, 0],
            localAnchorB: [0, 0]
          });
          d.call(this, a, b, d.DISTANCE, c);
          this.localAnchorA = f.fromValues(c.localAnchorA[0], c.localAnchorA[1]);
          this.localAnchorB = f.fromValues(c.localAnchorB[0], c.localAnchorB[1]);
          var h = this.localAnchorA;
          var i = this.localAnchorB;
          this.distance = 0;
          if ("number" == typeof c.distance) {
            this.distance = c.distance;
          } else {
            var j = f.create();
            var k = f.create();
            var l = f.create();
            f.rotate(j, h, a.angle);
            f.rotate(k, i, b.angle);
            f.add(l, b.position, k);
            f.sub(l, l, j);
            f.sub(l, l, a.position);
            this.distance = f.length(l);
          }
          var m;
          m = undefined === c.maxForce ? Number.MAX_VALUE : c.maxForce;
          var n = new e(a, b, -m, m);
          this.equations = [n];
          this.maxForce = m;
          var l = f.create();
          var o = f.create();
          var p = f.create();
          var q = this;
          n.computeGq = function () {
            var a = this.bodyA;
            var b = this.bodyB;
            var c = a.position;
            var d = b.position;
            f.rotate(o, h, a.angle);
            f.rotate(p, i, b.angle);
            f.add(l, d, p);
            f.sub(l, l, o);
            f.sub(l, l, c);
            return f.length(l) - q.distance;
          };
          this.setMaxForce(m);
          this.upperLimitEnabled = false;
          this.upperLimit = 1;
          this.lowerLimitEnabled = false;
          this.lowerLimit = 0;
          this.position = 0;
        }
        var d = a("./Constraint");
        var e = a("../equations/Equation");
        var f = a("../math/vec2");
        var g = a("../utils/Utils");
        b.exports = h;
        h.prototype = new d();
        h.prototype.constructor = h;
        var i = f.create();
        var j = f.create();
        var k = f.create();
        h.prototype.update = function () {
          var a = this.equations[0];
          var b = this.bodyA;
          var c = this.bodyB;
          this.distance;
          var e = b.position;
          var g = c.position;
          var h = this.equations[0];
          var l = a.G;
          f.rotate(j, this.localAnchorA, b.angle);
          f.rotate(k, this.localAnchorB, c.angle);
          f.add(i, g, k);
          f.sub(i, i, j);
          f.sub(i, i, e);
          this.position = f.length(i);
          var m = false;
          if (this.upperLimitEnabled && this.position > this.upperLimit) {
            h.maxForce = 0;
            h.minForce = -this.maxForce;
            this.distance = this.upperLimit;
            m = true;
          }
          if (this.lowerLimitEnabled && this.position < this.lowerLimit) {
            h.maxForce = this.maxForce;
            h.minForce = 0;
            this.distance = this.lowerLimit;
            m = true;
          }
          if ((this.lowerLimitEnabled || this.upperLimitEnabled) && !m) {
            return void (h.enabled = false);
          }
          h.enabled = true;
          f.normalize(i, i);
          var n = f.crossLength(j, i);
          var o = f.crossLength(k, i);
          l[0] = -i[0];
          l[1] = -i[1];
          l[2] = -n;
          l[3] = i[0];
          l[4] = i[1];
          l[5] = o;
        };
        h.prototype.setMaxForce = function (a) {
          var b = this.equations[0];
          b.minForce = -a;
          b.maxForce = a;
        };
        h.prototype.getMaxForce = function () {
          return this.equations[0].maxForce;
        };
      }, {
        "../equations/Equation": 22,
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Constraint": 14
      }],
      16: [function (a, b, c) {
        function h(a, b, c) {
          c = c || {};
          d.call(this, a, b, d.GEAR, c);
          this.ratio = undefined !== c.ratio ? c.ratio : 1;
          this.angle = undefined !== c.angle ? c.angle : b.angle - this.ratio * a.angle;
          c.angle = this.angle;
          c.ratio = this.ratio;
          this.equations = [new f(a, b, c)];
          if (undefined !== c.maxTorque) {
            this.setMaxTorque(c.maxTorque);
          }
        }
        var d = a("./Constraint");
        a("../equations/Equation");
        var f = a("../equations/AngleLockEquation");
        a("../math/vec2");
        b.exports = h;
        h.prototype = new d();
        h.prototype.constructor = h;
        h.prototype.update = function () {
          var a = this.equations[0];
          if (a.ratio !== this.ratio) {
            a.setRatio(this.ratio);
          }
          a.angle = this.angle;
        };
        h.prototype.setMaxTorque = function (a) {
          this.equations[0].setMaxTorque(a);
        };
        h.prototype.getMaxTorque = function (a) {
          return this.equations[0].maxForce;
        };
      }, {
        "../equations/AngleLockEquation": 20,
        "../equations/Equation": 22,
        "../math/vec2": 30,
        "./Constraint": 14
      }],
      17: [function (a, b, c) {
        function g(a, b, c) {
          c = c || {};
          d.call(this, a, b, d.LOCK, c);
          var g = undefined === c.maxForce ? Number.MAX_VALUE : c.maxForce;
          c.localAngleB;
          var i = new f(a, b, -g, g);
          var j = new f(a, b, -g, g);
          var k = new f(a, b, -g, g);
          var l = e.create();
          var m = e.create();
          var n = this;
          i.computeGq = function () {
            e.rotate(l, n.localOffsetB, a.angle);
            e.sub(m, b.position, a.position);
            e.sub(m, m, l);
            return m[0];
          };
          j.computeGq = function () {
            e.rotate(l, n.localOffsetB, a.angle);
            e.sub(m, b.position, a.position);
            e.sub(m, m, l);
            return m[1];
          };
          var o = e.create();
          var p = e.create();
          k.computeGq = function () {
            e.rotate(o, n.localOffsetB, b.angle - n.localAngleB);
            e.scale(o, o, -1);
            e.sub(m, a.position, b.position);
            e.add(m, m, o);
            e.rotate(p, o, -Math.PI / 2);
            e.normalize(p, p);
            return e.dot(m, p);
          };
          this.localOffsetB = e.create();
          if (c.localOffsetB) {
            e.copy(this.localOffsetB, c.localOffsetB);
          } else {
            e.sub(this.localOffsetB, b.position, a.position);
            e.rotate(this.localOffsetB, this.localOffsetB, -a.angle);
          }
          this.localAngleB = 0;
          if ("number" == typeof c.localAngleB) {
            this.localAngleB = c.localAngleB;
          } else {
            this.localAngleB = b.angle - a.angle;
          }
          this.equations.push(i, j, k);
          this.setMaxForce(g);
        }
        var d = a("./Constraint");
        var e = a("../math/vec2");
        var f = a("../equations/Equation");
        b.exports = g;
        g.prototype = new d();
        g.prototype.constructor = g;
        g.prototype.setMaxForce = function (a) {
          var b = this.equations;
          for (var c = 0; c < this.equations.length; c++) {
            b[c].maxForce = a;
            b[c].minForce = -a;
          }
        };
        g.prototype.getMaxForce = function () {
          return this.equations[0].maxForce;
        };
        var h = e.create();
        var i = e.create();
        var j = e.create();
        var k = e.fromValues(1, 0);
        var l = e.fromValues(0, 1);
        g.prototype.update = function () {
          var a = this.equations[0];
          var b = this.equations[1];
          var c = this.equations[2];
          var d = this.bodyA;
          var f = this.bodyB;
          e.rotate(h, this.localOffsetB, d.angle);
          e.rotate(i, this.localOffsetB, f.angle - this.localAngleB);
          e.scale(i, i, -1);
          e.rotate(j, i, Math.PI / 2);
          e.normalize(j, j);
          a.G[0] = -1;
          a.G[1] = 0;
          a.G[2] = -e.crossLength(h, k);
          a.G[3] = 1;
          b.G[0] = 0;
          b.G[1] = -1;
          b.G[2] = -e.crossLength(h, l);
          b.G[4] = 1;
          c.G[0] = -j[0];
          c.G[1] = -j[1];
          c.G[3] = j[0];
          c.G[4] = j[1];
          c.G[5] = e.crossLength(i, j);
        };
      }, {
        "../equations/Equation": 22,
        "../math/vec2": 30,
        "./Constraint": 14
      }],
      18: [function (a, b, c) {
        function i(a, b, c) {
          c = c || {};
          d.call(this, a, b, d.PRISMATIC, c);
          var i = g.fromValues(0, 0);
          var j = g.fromValues(1, 0);
          var k = g.fromValues(0, 0);
          if (c.localAnchorA) {
            g.copy(i, c.localAnchorA);
          }
          if (c.localAxisA) {
            g.copy(j, c.localAxisA);
          }
          if (c.localAnchorB) {
            g.copy(k, c.localAnchorB);
          }
          this.localAnchorA = i;
          this.localAnchorB = k;
          this.localAxisA = j;
          var l = this.maxForce = undefined !== c.maxForce ? c.maxForce : Number.MAX_VALUE;
          var m = new f(a, b, -l, l);
          var n = new g.create();
          var o = new g.create();
          var p = new g.create();
          var q = new g.create();
          m.computeGq = function () {
            return g.dot(p, q);
          };
          m.updateJacobian = function () {
            var c = this.G;
            var d = a.position;
            var e = b.position;
            g.rotate(n, i, a.angle);
            g.rotate(o, k, b.angle);
            g.add(p, e, o);
            g.sub(p, p, d);
            g.sub(p, p, n);
            g.rotate(q, j, a.angle + Math.PI / 2);
            c[0] = -q[0];
            c[1] = -q[1];
            c[2] = -g.crossLength(n, q) + g.crossLength(q, p);
            c[3] = q[0];
            c[4] = q[1];
            c[5] = g.crossLength(o, q);
          };
          this.equations.push(m);
          if (!c.disableRotationalLock) {
            var r = new h(a, b, -l, l);
            this.equations.push(r);
          }
          this.position = 0;
          this.velocity = 0;
          this.lowerLimitEnabled = undefined !== c.lowerLimit;
          this.upperLimitEnabled = undefined !== c.upperLimit;
          this.lowerLimit = undefined !== c.lowerLimit ? c.lowerLimit : 0;
          this.upperLimit = undefined !== c.upperLimit ? c.upperLimit : 1;
          this.upperLimitEquation = new e(a, b);
          this.lowerLimitEquation = new e(a, b);
          this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;
          this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = l;
          this.motorEquation = new f(a, b);
          this.motorEnabled = false;
          this.motorSpeed = 0;
          var s = this;
          var t = this.motorEquation;
          t.computeGW;
          t.computeGq = function () {
            return 0;
          };
          t.computeGW = function () {
            var a = this.G;
            var b = this.bodyA;
            var c = this.bodyB;
            var d = b.velocity;
            var e = c.velocity;
            var f = b.angularVelocity;
            var g = c.angularVelocity;
            return this.gmult(a, d, f, e, g) + s.motorSpeed;
          };
        }
        var d = a("./Constraint");
        var e = a("../equations/ContactEquation");
        var f = a("../equations/Equation");
        var g = a("../math/vec2");
        var h = a("../equations/RotationalLockEquation");
        b.exports = i;
        i.prototype = new d();
        i.prototype.constructor = i;
        var j = g.create();
        var k = g.create();
        var l = g.create();
        var m = g.create();
        var n = g.create();
        var o = g.create();
        i.prototype.update = function () {
          var a = this.equations;
          var b = a[0];
          var c = this.upperLimit;
          var d = this.lowerLimit;
          var e = this.upperLimitEquation;
          var f = this.lowerLimitEquation;
          var h = this.bodyA;
          var i = this.bodyB;
          var p = this.localAxisA;
          var q = this.localAnchorA;
          var r = this.localAnchorB;
          b.updateJacobian();
          g.rotate(j, p, h.angle);
          g.rotate(m, q, h.angle);
          g.add(k, m, h.position);
          g.rotate(n, r, i.angle);
          g.add(l, n, i.position);
          var s = this.position = g.dot(l, j) - g.dot(k, j);
          if (this.motorEnabled) {
            var t = this.motorEquation.G;
            t[0] = j[0];
            t[1] = j[1];
            t[2] = g.crossLength(j, n);
            t[3] = -j[0];
            t[4] = -j[1];
            t[5] = -g.crossLength(j, m);
          }
          if (this.upperLimitEnabled && s > c) {
            g.scale(e.normalA, j, -1);
            g.sub(e.contactPointA, k, h.position);
            g.sub(e.contactPointB, l, i.position);
            g.scale(o, j, c);
            g.add(e.contactPointA, e.contactPointA, o);
            if (-1 === a.indexOf(e)) {
              a.push(e);
            }
          } else {
            var u = a.indexOf(e);
            if (-1 !== u) {
              a.splice(u, 1);
            }
          }
          if (this.lowerLimitEnabled && s < d) {
            g.scale(f.normalA, j, 1);
            g.sub(f.contactPointA, k, h.position);
            g.sub(f.contactPointB, l, i.position);
            g.scale(o, j, d);
            g.sub(f.contactPointB, f.contactPointB, o);
            if (-1 === a.indexOf(f)) {
              a.push(f);
            }
          } else {
            var u = a.indexOf(f);
            if (-1 !== u) {
              a.splice(u, 1);
            }
          }
        };
        i.prototype.enableMotor = function () {
          if (!this.motorEnabled) {
            this.equations.push(this.motorEquation);
            this.motorEnabled = true;
          }
        };
        i.prototype.disableMotor = function () {
          if (this.motorEnabled) {
            var a = this.equations.indexOf(this.motorEquation);
            this.equations.splice(a, 1);
            this.motorEnabled = false;
          }
        };
        i.prototype.setLimits = function (a, b) {
          if ("number" == typeof a) {
            this.lowerLimit = a;
            this.lowerLimitEnabled = true;
          } else {
            this.lowerLimit = a;
            this.lowerLimitEnabled = false;
          }
          if ("number" == typeof b) {
            this.upperLimit = b;
            this.upperLimitEnabled = true;
          } else {
            this.upperLimit = b;
            this.upperLimitEnabled = false;
          }
        };
      }, {
        "../equations/ContactEquation": 21,
        "../equations/Equation": 22,
        "../equations/RotationalLockEquation": 24,
        "../math/vec2": 30,
        "./Constraint": 14
      }],
      19: [function (a, b, c) {
        function n(a, b, c) {
          c = c || {};
          d.call(this, a, b, d.REVOLUTE, c);
          var n = this.maxForce = undefined !== c.maxForce ? c.maxForce : Number.MAX_VALUE;
          this.pivotA = h.create();
          this.pivotB = h.create();
          if (c.worldPivot) {
            h.sub(this.pivotA, c.worldPivot, a.position);
            h.sub(this.pivotB, c.worldPivot, b.position);
            h.rotate(this.pivotA, this.pivotA, -a.angle);
            h.rotate(this.pivotB, this.pivotB, -b.angle);
          } else {
            h.copy(this.pivotA, c.localPivotA);
            h.copy(this.pivotB, c.localPivotB);
          }
          var o = this.equations = [new e(a, b, -n, n), new e(a, b, -n, n)];
          var p = o[0];
          var q = o[1];
          var r = this;
          p.computeGq = function () {
            h.rotate(i, r.pivotA, a.angle);
            h.rotate(j, r.pivotB, b.angle);
            h.add(m, b.position, j);
            h.sub(m, m, a.position);
            h.sub(m, m, i);
            return h.dot(m, k);
          };
          q.computeGq = function () {
            h.rotate(i, r.pivotA, a.angle);
            h.rotate(j, r.pivotB, b.angle);
            h.add(m, b.position, j);
            h.sub(m, m, a.position);
            h.sub(m, m, i);
            return h.dot(m, l);
          };
          q.minForce = p.minForce = -n;
          q.maxForce = p.maxForce = n;
          this.motorEquation = new f(a, b);
          this.motorEnabled = false;
          this.angle = 0;
          this.lowerLimitEnabled = false;
          this.upperLimitEnabled = false;
          this.lowerLimit = 0;
          this.upperLimit = 0;
          this.upperLimitEquation = new g(a, b);
          this.lowerLimitEquation = new g(a, b);
          this.upperLimitEquation.minForce = 0;
          this.lowerLimitEquation.maxForce = 0;
        }
        var d = a("./Constraint");
        var e = a("../equations/Equation");
        var f = a("../equations/RotationalVelocityEquation");
        var g = a("../equations/RotationalLockEquation");
        var h = a("../math/vec2");
        b.exports = n;
        var i = h.create();
        var j = h.create();
        var k = h.fromValues(1, 0);
        var l = h.fromValues(0, 1);
        var m = h.create();
        n.prototype = new d();
        n.prototype.constructor = n;
        n.prototype.setLimits = function (a, b) {
          if ("number" == typeof a) {
            this.lowerLimit = a;
            this.lowerLimitEnabled = true;
          } else {
            this.lowerLimit = a;
            this.lowerLimitEnabled = false;
          }
          if ("number" == typeof b) {
            this.upperLimit = b;
            this.upperLimitEnabled = true;
          } else {
            this.upperLimit = b;
            this.upperLimitEnabled = false;
          }
        };
        n.prototype.update = function () {
          var a = this.bodyA;
          var b = this.bodyB;
          var c = this.pivotA;
          var d = this.pivotB;
          var e = this.equations;
          e[0];
          e[1];
          var m = e[0];
          var n = e[1];
          var o = this.upperLimit;
          var p = this.lowerLimit;
          var q = this.upperLimitEquation;
          var r = this.lowerLimitEquation;
          var s = this.angle = b.angle - a.angle;
          if (this.upperLimitEnabled && s > o) {
            q.angle = o;
            if (-1 === e.indexOf(q)) {
              e.push(q);
            }
          } else {
            var t = e.indexOf(q);
            if (-1 !== t) {
              e.splice(t, 1);
            }
          }
          if (this.lowerLimitEnabled && s < p) {
            r.angle = p;
            if (-1 === e.indexOf(r)) {
              e.push(r);
            }
          } else {
            var t = e.indexOf(r);
            if (-1 !== t) {
              e.splice(t, 1);
            }
          }
          h.rotate(i, c, a.angle);
          h.rotate(j, d, b.angle);
          m.G[0] = -1;
          m.G[1] = 0;
          m.G[2] = -h.crossLength(i, k);
          m.G[3] = 1;
          m.G[4] = 0;
          m.G[5] = h.crossLength(j, k);
          n.G[0] = 0;
          n.G[1] = -1;
          n.G[2] = -h.crossLength(i, l);
          n.G[3] = 0;
          n.G[4] = 1;
          n.G[5] = h.crossLength(j, l);
        };
        n.prototype.enableMotor = function () {
          if (!this.motorEnabled) {
            this.equations.push(this.motorEquation);
            this.motorEnabled = true;
          }
        };
        n.prototype.disableMotor = function () {
          if (this.motorEnabled) {
            var a = this.equations.indexOf(this.motorEquation);
            this.equations.splice(a, 1);
            this.motorEnabled = false;
          }
        };
        n.prototype.motorIsEnabled = function () {
          return !!this.motorEnabled;
        };
        n.prototype.setMotorSpeed = function (a) {
          if (this.motorEnabled) {
            var b = this.equations.indexOf(this.motorEquation);
            this.equations[b].relativeVelocity = a;
          }
        };
        n.prototype.getMotorSpeed = function () {
          return !!this.motorEnabled && this.motorEquation.relativeVelocity;
        };
      }, {
        "../equations/Equation": 22,
        "../equations/RotationalLockEquation": 24,
        "../equations/RotationalVelocityEquation": 25,
        "../math/vec2": 30,
        "./Constraint": 14
      }],
      20: [function (a, b, c) {
        function f(a, b, c) {
          c = c || {};
          d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
          this.angle = c.angle || 0;
          this.ratio = "number" == typeof c.ratio ? c.ratio : 1;
          this.setRatio(this.ratio);
        }
        var d = a("./Equation");
        a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeGq = function () {
          return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;
        };
        f.prototype.setRatio = function (a) {
          var b = this.G;
          b[2] = a;
          b[5] = -1;
          this.ratio = a;
        };
        f.prototype.setMaxTorque = function (a) {
          this.maxForce = a;
          this.minForce = -a;
        };
      }, {
        "../math/vec2": 30,
        "./Equation": 22
      }],
      21: [function (a, b, c) {
        function f(a, b) {
          d.call(this, a, b, 0, Number.MAX_VALUE);
          this.contactPointA = e.create();
          this.penetrationVec = e.create();
          this.contactPointB = e.create();
          this.normalA = e.create();
          this.restitution = 0;
          this.firstImpact = false;
          this.shapeA = null;
          this.shapeB = null;
        }
        var d = a("./Equation");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeB = function (a, b, c) {
          var d = this.bodyA;
          var f = this.bodyB;
          var g = this.contactPointA;
          var h = this.contactPointB;
          var i = d.position;
          var j = f.position;
          var k = this.penetrationVec;
          var l = this.normalA;
          var m = this.G;
          var n = e.crossLength(g, l);
          var o = e.crossLength(h, l);
          m[0] = -l[0];
          m[1] = -l[1];
          m[2] = -n;
          m[3] = l[0];
          m[4] = l[1];
          m[5] = o;
          e.add(k, j, h);
          e.sub(k, k, i);
          e.sub(k, k, g);
          var p;
          var q;
          if (this.firstImpact && 0 !== this.restitution) {
            q = 0;
            p = 1 / b * (1 + this.restitution) * this.computeGW();
          } else {
            q = e.dot(l, k) + this.offset;
            p = this.computeGW();
          }
          return -q * a - p * b - c * this.computeGiMf();
        };
      }, {
        "../math/vec2": 30,
        "./Equation": 22
      }],
      22: [function (a, b, c) {
        function g(a, b, c, d) {
          this.minForce = undefined === c ? -Number.MAX_VALUE : c;
          this.maxForce = undefined === d ? Number.MAX_VALUE : d;
          this.bodyA = a;
          this.bodyB = b;
          this.stiffness = g.DEFAULT_STIFFNESS;
          this.relaxation = g.DEFAULT_RELAXATION;
          this.G = new e.ARRAY_TYPE(6);
          for (var f = 0; f < 6; f++) {
            this.G[f] = 0;
          }
          this.offset = 0;
          this.a = 0;
          this.b = 0;
          this.epsilon = 0;
          this.timeStep = 0.016666666666666666;
          this.needsUpdate = true;
          this.multiplier = 0;
          this.relativeVelocity = 0;
          this.enabled = true;
        }
        b.exports = g;
        var d = a("../math/vec2");
        var e = a("../utils/Utils");
        a("../objects/Body");
        g.prototype.constructor = g;
        g.DEFAULT_STIFFNESS = 1e6;
        g.DEFAULT_RELAXATION = 4;
        g.prototype.update = function () {
          var a = this.stiffness;
          var b = this.relaxation;
          var c = this.timeStep;
          this.a = 4 / (c * (1 + 4 * b));
          this.b = 4 * b / (1 + 4 * b);
          this.epsilon = 4 / (c * c * a * (1 + 4 * b));
          this.needsUpdate = false;
        };
        g.prototype.gmult = function (a, b, c, d, e) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * c + a[3] * d[0] + a[4] * d[1] + a[5] * e;
        };
        g.prototype.computeB = function (a, b, c) {
          var d = this.computeGW();
          return -this.computeGq() * a - d * b - this.computeGiMf() * c;
        };
        var h = d.create();
        var i = d.create();
        g.prototype.computeGq = function () {
          var a = this.G;
          var b = this.bodyA;
          var c = this.bodyB;
          b.position;
          c.position;
          var f = b.angle;
          var g = c.angle;
          return this.gmult(a, h, f, i, g) + this.offset;
        };
        g.prototype.computeGW = function () {
          var a = this.G;
          var b = this.bodyA;
          var c = this.bodyB;
          var d = b.velocity;
          var e = c.velocity;
          var f = b.angularVelocity;
          var g = c.angularVelocity;
          return this.gmult(a, d, f, e, g) + this.relativeVelocity;
        };
        g.prototype.computeGWlambda = function () {
          var a = this.G;
          var b = this.bodyA;
          var c = this.bodyB;
          var d = b.vlambda;
          var e = c.vlambda;
          var f = b.wlambda;
          var g = c.wlambda;
          return this.gmult(a, d, f, e, g);
        };
        var j = d.create();
        var k = d.create();
        g.prototype.computeGiMf = function () {
          var a = this.bodyA;
          var b = this.bodyB;
          var c = a.force;
          var e = a.angularForce;
          var f = b.force;
          var g = b.angularForce;
          var h = a.invMassSolve;
          var i = b.invMassSolve;
          var l = a.invInertiaSolve;
          var m = b.invInertiaSolve;
          var n = this.G;
          d.scale(j, c, h);
          d.multiply(j, a.massMultiplier, j);
          d.scale(k, f, i);
          d.multiply(k, b.massMultiplier, k);
          return this.gmult(n, j, e * l, k, g * m);
        };
        g.prototype.computeGiMGt = function () {
          var a = this.bodyA;
          var b = this.bodyB;
          var c = a.invMassSolve;
          var d = b.invMassSolve;
          var e = a.invInertiaSolve;
          var f = b.invInertiaSolve;
          var g = this.G;
          return g[0] * g[0] * c * a.massMultiplier[0] + g[1] * g[1] * c * a.massMultiplier[1] + g[2] * g[2] * e + g[3] * g[3] * d * b.massMultiplier[0] + g[4] * g[4] * d * b.massMultiplier[1] + g[5] * g[5] * f;
        };
        var l = d.create();
        var m = d.create();
        var n = d.create();
        d.create();
        d.create();
        d.create();
        g.prototype.addToWlambda = function (a) {
          var b = this.bodyA;
          var c = this.bodyB;
          var j = b.invMassSolve;
          var k = c.invMassSolve;
          var r = b.invInertiaSolve;
          var s = c.invInertiaSolve;
          var u = this.G;
          m[0] = u[0];
          m[1] = u[1];
          n[0] = u[3];
          n[1] = u[4];
          d.scale(l, m, j * a);
          d.multiply(l, l, b.massMultiplier);
          d.add(b.vlambda, b.vlambda, l);
          b.wlambda += r * u[2] * a;
          d.scale(l, n, k * a);
          d.multiply(l, l, c.massMultiplier);
          d.add(c.vlambda, c.vlambda, l);
          c.wlambda += s * u[5] * a;
        };
        g.prototype.computeInvC = function (a) {
          return 1 / (this.computeGiMGt() + a);
        };
      }, {
        "../math/vec2": 30,
        "../objects/Body": 31,
        "../utils/Utils": 57
      }],
      23: [function (a, b, c) {
        function g(a, b, c) {
          e.call(this, a, b, -c, c);
          this.contactPointA = d.create();
          this.contactPointB = d.create();
          this.t = d.create();
          this.contactEquations = [];
          this.shapeA = null;
          this.shapeB = null;
          this.frictionCoefficient = .3;
        }
        var d = a("../math/vec2");
        var e = a("./Equation");
        a("../utils/Utils");
        b.exports = g;
        g.prototype = new e();
        g.prototype.constructor = g;
        g.prototype.setSlipForce = function (a) {
          this.maxForce = a;
          this.minForce = -a;
        };
        g.prototype.getSlipForce = function () {
          return this.maxForce;
        };
        g.prototype.computeB = function (a, b, c) {
          this.bodyA;
          this.bodyB;
          var g = this.contactPointA;
          var h = this.contactPointB;
          var i = this.t;
          var j = this.G;
          j[0] = -i[0];
          j[1] = -i[1];
          j[2] = -d.crossLength(g, i);
          j[3] = i[0];
          j[4] = i[1];
          j[5] = d.crossLength(h, i);
          return -this.computeGW() * b - c * this.computeGiMf();
        };
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Equation": 22
      }],
      24: [function (a, b, c) {
        function f(a, b, c) {
          c = c || {};
          d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
          this.angle = c.angle || 0;
          var e = this.G;
          e[2] = 1;
          e[5] = -1;
        }
        var d = a("./Equation");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        var g = e.create();
        var h = e.create();
        var i = e.fromValues(1, 0);
        var j = e.fromValues(0, 1);
        f.prototype.computeGq = function () {
          e.rotate(g, i, this.bodyA.angle + this.angle);
          e.rotate(h, j, this.bodyB.angle);
          return e.dot(g, h);
        };
      }, {
        "../math/vec2": 30,
        "./Equation": 22
      }],
      25: [function (a, b, c) {
        function f(a, b) {
          d.call(this, a, b, -Number.MAX_VALUE, Number.MAX_VALUE);
          this.relativeVelocity = 1;
          this.ratio = 1;
        }
        var d = a("./Equation");
        a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeB = function (a, b, c) {
          var d = this.G;
          d[2] = -1;
          d[5] = this.ratio;
          var e = this.computeGiMf();
          return -this.computeGW() * b - c * e;
        };
      }, {
        "../math/vec2": 30,
        "./Equation": 22
      }],
      26: [function (a, b, c) {
        var d = function () {};
        b.exports = d;
        d.prototype = {
          constructor: d,
          on: function (a, b, c) {
            b.context = c || this;
            if (undefined === this._listeners) {
              this._listeners = {};
            }
            var d = this._listeners;
            if (undefined === d[a]) {
              d[a] = [];
            }
            if (-1 === d[a].indexOf(b)) {
              d[a].push(b);
            }
            return this;
          },
          has: function (a, b) {
            if (undefined === this._listeners) {
              return false;
            }
            var c = this._listeners;
            if (b) {
              if (undefined !== c[a] && -1 !== c[a].indexOf(b)) {
                return true;
              }
            } else if (undefined !== c[a]) {
              return true;
            }
            return false;
          },
          off: function (a, b) {
            if (undefined === this._listeners) {
              return this;
            }
            var c = this._listeners;
            var d = c[a].indexOf(b);
            if (-1 !== d) {
              c[a].splice(d, 1);
            }
            return this;
          },
          emit: function (a) {
            if (undefined === this._listeners) {
              return this;
            }
            var b = this._listeners;
            var c = b[a.type];
            if (undefined !== c) {
              a.target = this;
              var d = 0;
              for (var e = c.length; d < e; d++) {
                var f = c[d];
                f.call(f.context, a);
              }
            }
            return this;
          }
        };
      }, {}],
      27: [function (a, b, c) {
        function f(a, b, c) {
          c = c || {};
          if (!(a instanceof d && b instanceof d)) {
            throw new Error("First two arguments must be Material instances.");
          }
          this.id = f.idCounter++;
          this.materialA = a;
          this.materialB = b;
          this.friction = undefined !== c.friction ? Number(c.friction) : .3;
          this.restitution = undefined !== c.restitution ? Number(c.restitution) : 0;
          this.stiffness = undefined !== c.stiffness ? Number(c.stiffness) : e.DEFAULT_STIFFNESS;
          this.relaxation = undefined !== c.relaxation ? Number(c.relaxation) : e.DEFAULT_RELAXATION;
          this.frictionStiffness = undefined !== c.frictionStiffness ? Number(c.frictionStiffness) : e.DEFAULT_STIFFNESS;
          this.frictionRelaxation = undefined !== c.frictionRelaxation ? Number(c.frictionRelaxation) : e.DEFAULT_RELAXATION;
          this.surfaceVelocity = undefined !== c.surfaceVelocity ? Number(c.surfaceVelocity) : 0;
          this.contactSkinSize = .005;
        }
        var d = a("./Material");
        var e = a("../equations/Equation");
        b.exports = f;
        f.idCounter = 0;
      }, {
        "../equations/Equation": 22,
        "./Material": 28
      }],
      28: [function (a, b, c) {
        function d(a) {
          this.id = a || d.idCounter++;
        }
        b.exports = d;
        d.idCounter = 0;
      }, {}],
      29: [function (a, b, c) {
        var d = {
          GetArea: function (a) {
            if (a.length < 6) {
              return 0;
            }
            var b = a.length - 2;
            var c = 0;
            for (var d = 0; d < b; d += 2) {
              c += (a[d + 2] - a[d]) * (a[d + 1] + a[d + 3]);
            }
            return .5 * -(c += (a[0] - a[b]) * (a[b + 1] + a[1]));
          },
          Triangulate: function (a) {
            var b = a.length >> 1;
            if (b < 3) {
              return [];
            }
            var c = [];
            var e = [];
            for (var f = 0; f < b; f++) {
              e.push(f);
            }
            var f = 0;
            for (var g = b; g > 3;) {
              var h = e[(f + 0) % g];
              var i = e[(f + 1) % g];
              var j = e[(f + 2) % g];
              var k = a[2 * h];
              var l = a[2 * h + 1];
              var m = a[2 * i];
              var n = a[2 * i + 1];
              var o = a[2 * j];
              var p = a[2 * j + 1];
              var q = false;
              if ((l - n) * (o - m) + (m - k) * (p - n) >= 0) {
                q = true;
                for (var r = 0; r < g; r++) {
                  var s = e[r];
                  if (s != h && s != i && s != j && d._PointInTriangle(a[2 * s], a[2 * s + 1], k, l, m, n, o, p)) {
                    q = false;
                    break;
                  }
                }
              }
              if (q) {
                c.push(h, i, j);
                e.splice((f + 1) % g, 1);
                g--;
                f = 0;
              } else if (f++ > 3 * g) {
                break;
              }
            }
            c.push(e[0], e[1], e[2]);
            return c;
          },
          _PointInTriangle: function (a, b, c, d, e, f, g, h) {
            var i = g - c;
            var j = h - d;
            var k = e - c;
            var l = f - d;
            var m = a - c;
            var n = b - d;
            var o = i * i + j * j;
            var p = i * k + j * l;
            var q = i * m + j * n;
            var r = k * k + l * l;
            var s = k * m + l * n;
            var t = 1 / (o * r - p * p);
            var u = (r * q - p * s) * t;
            var v = (o * s - p * q) * t;
            return u >= 0 && v >= 0 && u + v < 1;
          },
          _convex: function (a, b, c, d, e, f) {
            return (b - d) * (e - c) + (c - a) * (f - d) >= 0;
          }
        };
        b.exports = d;
      }, {}],
      30: [function (a, b, c) {
        var d = b.exports = {};
        var e = a("../utils/Utils");
        d.crossLength = function (a, b) {
          return a[0] * b[1] - a[1] * b[0];
        };
        d.crossVZ = function (a, b, c) {
          d.rotate(a, b, -Math.PI / 2);
          d.scale(a, a, c);
          return a;
        };
        d.crossZV = function (a, b, c) {
          d.rotate(a, c, Math.PI / 2);
          d.scale(a, a, b);
          return a;
        };
        d.rotate = function (a, b, c) {
          if (0 !== c) {
            var d = Math.cos(c);
            var e = Math.sin(c);
            var f = b[0];
            var g = b[1];
            a[0] = d * f - e * g;
            a[1] = e * f + d * g;
          } else {
            a[0] = b[0];
            a[1] = b[1];
          }
        };
        d.rotate90cw = function (a, b) {
          var c = b[0];
          var d = b[1];
          a[0] = d;
          a[1] = -c;
        };
        d.toLocalFrame = function (a, b, c, e) {
          d.copy(a, b);
          d.sub(a, a, c);
          d.rotate(a, a, -e);
        };
        d.toGlobalFrame = function (a, b, c, e) {
          d.copy(a, b);
          d.rotate(a, a, e);
          d.add(a, a, c);
        };
        d.vectorToLocalFrame = function (a, b, c) {
          d.rotate(a, b, -c);
        };
        d.vectorToGlobalFrame = function (a, b, c) {
          d.rotate(a, b, c);
        };
        d.centroid = function (a, b, c, e) {
          d.add(a, b, c);
          d.add(a, a, e);
          d.scale(a, a, 0.3333333333333333);
          return a;
        };
        d.create = function () {
          var a = new e.ARRAY_TYPE(2);
          a[0] = 0;
          a[1] = 0;
          return a;
        };
        d.clone = function (a) {
          var b = new e.ARRAY_TYPE(2);
          b[0] = a[0];
          b[1] = a[1];
          return b;
        };
        d.fromValues = function (a, b) {
          var c = new e.ARRAY_TYPE(2);
          c[0] = a;
          c[1] = b;
          return c;
        };
        d.copy = function (a, b) {
          a[0] = b[0];
          a[1] = b[1];
          return a;
        };
        d.set = function (a, b, c) {
          a[0] = b;
          a[1] = c;
          return a;
        };
        d.add = function (a, b, c) {
          a[0] = b[0] + c[0];
          a[1] = b[1] + c[1];
          return a;
        };
        d.subtract = function (a, b, c) {
          a[0] = b[0] - c[0];
          a[1] = b[1] - c[1];
          return a;
        };
        d.sub = d.subtract;
        d.multiply = function (a, b, c) {
          a[0] = b[0] * c[0];
          a[1] = b[1] * c[1];
          return a;
        };
        d.mul = d.multiply;
        d.divide = function (a, b, c) {
          a[0] = b[0] / c[0];
          a[1] = b[1] / c[1];
          return a;
        };
        d.div = d.divide;
        d.scale = function (a, b, c) {
          a[0] = b[0] * c;
          a[1] = b[1] * c;
          return a;
        };
        d.distance = function (a, b) {
          var c = b[0] - a[0];
          var d = b[1] - a[1];
          return Math.sqrt(c * c + d * d);
        };
        d.dist = d.distance;
        d.squaredDistance = function (a, b) {
          var c = b[0] - a[0];
          var d = b[1] - a[1];
          return c * c + d * d;
        };
        d.sqrDist = d.squaredDistance;
        d.length = function (a) {
          var b = a[0];
          var c = a[1];
          return Math.sqrt(b * b + c * c);
        };
        d.len = d.length;
        d.squaredLength = function (a) {
          var b = a[0];
          var c = a[1];
          return b * b + c * c;
        };
        d.sqrLen = d.squaredLength;
        d.negate = function (a, b) {
          a[0] = -b[0];
          a[1] = -b[1];
          return a;
        };
        d.normalize = function (a, b) {
          var c = b[0];
          var d = b[1];
          var e = c * c + d * d;
          if (e > 0) {
            e = 1 / Math.sqrt(e);
            a[0] = b[0] * e;
            a[1] = b[1] * e;
          }
          return a;
        };
        d.dot = function (a, b) {
          return a[0] * b[0] + a[1] * b[1];
        };
        d.str = function (a) {
          return "vec2(" + a[0] + ", " + a[1] + ")";
        };
        d.lerp = function (a, b, c, d) {
          var e = b[0];
          var f = b[1];
          a[0] = e + d * (c[0] - e);
          a[1] = f + d * (c[1] - f);
          return a;
        };
        d.reflect = function (a, b, c) {
          var d = b[0] * c[0] + b[1] * c[1];
          a[0] = b[0] - 2 * c[0] * d;
          a[1] = b[1] - 2 * c[1] * d;
        };
        d.getLineSegmentsIntersection = function (a, b, c, e, f) {
          var g = d.getLineSegmentsIntersectionFraction(b, c, e, f);
          return !(g < 0) && (a[0] = b[0] + g * (c[0] - b[0]), a[1] = b[1] + g * (c[1] - b[1]), true);
        };
        d.getLineSegmentsIntersectionFraction = function (a, b, c, d) {
          var i;
          var j;
          var e = b[0] - a[0];
          var f = b[1] - a[1];
          var g = d[0] - c[0];
          var h = d[1] - c[1];
          i = (-f * (a[0] - c[0]) + e * (a[1] - c[1])) / (-g * f + e * h);
          j = (g * (a[1] - c[1]) - h * (a[0] - c[0])) / (-g * f + e * h);
          return i >= 0 && i <= 1 && j >= 0 && j <= 1 ? j : -1;
        };
      }, {
        "../utils/Utils": 57
      }],
      31: [function (a, b, c) {
        function k(a) {
          a = a || {};
          j.call(this);
          this.id = a.id || ++k._idCounter;
          this.world = null;
          this.shapes = [];
          this.mass = a.mass || 0;
          this.invMass = 0;
          this.inertia = 0;
          this.invInertia = 0;
          this.invMassSolve = 0;
          this.invInertiaSolve = 0;
          this.fixedRotation = !!a.fixedRotation;
          this.fixedX = !!a.fixedX;
          this.fixedY = !!a.fixedY;
          this.massMultiplier = d.create();
          this.position = d.fromValues(0, 0);
          if (a.position) {
            d.copy(this.position, a.position);
          }
          this.interpolatedPosition = d.fromValues(0, 0);
          this.interpolatedAngle = 0;
          this.previousPosition = d.fromValues(0, 0);
          this.previousAngle = 0;
          this.velocity = d.fromValues(0, 0);
          if (a.velocity) {
            d.copy(this.velocity, a.velocity);
          }
          this.vlambda = d.fromValues(0, 0);
          this.wlambda = 0;
          this.angle = a.angle || 0;
          this.angularVelocity = a.angularVelocity || 0;
          this.force = d.create();
          if (a.force) {
            d.copy(this.force, a.force);
          }
          this.angularForce = a.angularForce || 0;
          this.damping = "number" == typeof a.damping ? a.damping : .1;
          this.angularDamping = "number" == typeof a.angularDamping ? a.angularDamping : .1;
          this.type = k.STATIC;
          if (undefined !== a.type) {
            this.type = a.type;
          } else if (a.mass) {
            this.type = k.DYNAMIC;
          } else {
            this.type = k.STATIC;
          }
          this.boundingRadius = 0;
          this.aabb = new i();
          this.aabbNeedsUpdate = true;
          this.allowSleep = undefined === a.allowSleep || a.allowSleep;
          this.wantsToSleep = false;
          this.sleepState = k.AWAKE;
          this.sleepSpeedLimit = undefined !== a.sleepSpeedLimit ? a.sleepSpeedLimit : .2;
          this.sleepTimeLimit = undefined !== a.sleepTimeLimit ? a.sleepTimeLimit : 1;
          this.gravityScale = undefined !== a.gravityScale ? a.gravityScale : 1;
          this.collisionResponse = undefined === a.collisionResponse || a.collisionResponse;
          this.idleTime = 0;
          this.timeLastSleepy = 0;
          this.ccdSpeedThreshold = undefined !== a.ccdSpeedThreshold ? a.ccdSpeedThreshold : -1;
          this.ccdIterations = undefined !== a.ccdIterations ? a.ccdIterations : 10;
          this.concavePath = null;
          this._wakeUpAfterNarrowphase = false;
          this.updateMassProperties();
        }
        var d = a("../math/vec2");
        var e = a("poly-decomp");
        var f = a("../shapes/Convex");
        var g = a("../collision/RaycastResult");
        var h = a("../collision/Ray");
        var i = a("../collision/AABB");
        var j = a("../events/EventEmitter");
        b.exports = k;
        k.prototype = new j();
        k.prototype.constructor = k;
        k._idCounter = 0;
        k.prototype.updateSolveMassProperties = function () {
          if (this.sleepState === k.SLEEPING || this.type === k.KINEMATIC) {
            this.invMassSolve = 0;
            this.invInertiaSolve = 0;
          } else {
            this.invMassSolve = this.invMass;
            this.invInertiaSolve = this.invInertia;
          }
        };
        k.prototype.setDensity = function (a) {
          var b = this.getArea();
          this.mass = b * a;
          this.updateMassProperties();
        };
        k.prototype.getArea = function () {
          var a = 0;
          for (var b = 0; b < this.shapes.length; b++) {
            a += this.shapes[b].area;
          }
          return a;
        };
        k.prototype.getAABB = function () {
          if (this.aabbNeedsUpdate) {
            this.updateAABB();
          }
          return this.aabb;
        };
        var l = new i();
        var m = d.create();
        k.prototype.updateAABB = function () {
          var a = this.shapes;
          var b = a.length;
          var e = this.angle;
          for (var f = 0; f !== b; f++) {
            var g = a[f];
            var h = g.angle + e;
            d.rotate(m, g.position, e);
            d.add(m, m, this.position);
            g.computeAABB(l, m, h);
            if (0 === f) {
              this.aabb.copy(l);
            } else {
              this.aabb.extend(l);
            }
          }
          this.aabbNeedsUpdate = false;
        };
        k.prototype.updateBoundingRadius = function () {
          var a = this.shapes;
          var b = a.length;
          var c = 0;
          for (var e = 0; e !== b; e++) {
            var f = a[e];
            var g = d.length(f.position);
            var h = f.boundingRadius;
            if (g + h > c) {
              c = g + h;
            }
          }
          this.boundingRadius = c;
        };
        k.prototype.addShape = function (a, b, c) {
          if (a.body) {
            throw new Error("A shape can only be added to one body.");
          }
          a.body = this;
          if (b) {
            d.copy(a.position, b);
          } else {
            d.set(a.position, 0, 0);
          }
          a.angle = c || 0;
          this.shapes.push(a);
          this.updateMassProperties();
          this.updateBoundingRadius();
          this.aabbNeedsUpdate = true;
        };
        k.prototype.removeShape = function (a) {
          var b = this.shapes.indexOf(a);
          return -1 !== b && (this.shapes.splice(b, 1), this.aabbNeedsUpdate = true, a.body = null, true);
        };
        k.prototype.updateMassProperties = function () {
          if (this.type === k.STATIC || this.type === k.KINEMATIC) {
            this.mass = Number.MAX_VALUE;
            this.invMass = 0;
            this.inertia = Number.MAX_VALUE;
            this.invInertia = 0;
          } else {
            var a = this.shapes;
            var b = a.length;
            var c = this.mass / b;
            var e = 0;
            if (this.fixedRotation) {
              this.inertia = Number.MAX_VALUE;
              this.invInertia = 0;
            } else {
              for (var f = 0; f < b; f++) {
                var g = a[f];
                var h = d.squaredLength(g.position);
                e += g.computeMomentOfInertia(c) + c * h;
              }
              this.inertia = e;
              this.invInertia = e > 0 ? 1 / e : 0;
            }
            this.invMass = 1 / this.mass;
            d.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1);
          }
        };
        d.create();
        k.prototype.applyForce = function (a, b) {
          d.add(this.force, this.force, a);
          if (b) {
            var c = d.crossLength(b, a);
            this.angularForce += c;
          }
        };
        var o = d.create();
        var p = d.create();
        var q = d.create();
        k.prototype.applyForceLocal = function (a, b) {
          b = b || q;
          this.vectorToWorldFrame(o, a);
          this.vectorToWorldFrame(p, b);
          this.applyForce(o, p);
        };
        var r = d.create();
        k.prototype.applyImpulse = function (a, b) {
          if (this.type === k.DYNAMIC) {
            d.scale(r, a, this.invMass);
            d.multiply(r, this.massMultiplier, r);
            d.add(this.velocity, r, this.velocity);
            if (b) {
              var e = d.crossLength(b, a);
              e *= this.invInertia;
              this.angularVelocity += e;
            }
          }
        };
        var s = d.create();
        var t = d.create();
        var u = d.create();
        k.prototype.applyImpulseLocal = function (a, b) {
          b = b || u;
          this.vectorToWorldFrame(s, a);
          this.vectorToWorldFrame(t, b);
          this.applyImpulse(s, t);
        };
        k.prototype.toLocalFrame = function (a, b) {
          d.toLocalFrame(a, b, this.position, this.angle);
        };
        k.prototype.toWorldFrame = function (a, b) {
          d.toGlobalFrame(a, b, this.position, this.angle);
        };
        k.prototype.vectorToLocalFrame = function (a, b) {
          d.vectorToLocalFrame(a, b, this.angle);
        };
        k.prototype.vectorToWorldFrame = function (a, b) {
          d.vectorToGlobalFrame(a, b, this.angle);
        };
        k.prototype.fromPolygon = function (a, b) {
          b = b || {};
          for (var c = this.shapes.length; c >= 0; --c) {
            this.removeShape(this.shapes[c]);
          }
          var g = new e.Polygon();
          g.vertices = a;
          g.makeCCW();
          if ("number" == typeof b.removeCollinearPoints) {
            g.removeCollinearPoints(b.removeCollinearPoints);
          }
          if (undefined === b.skipSimpleCheck && !g.isSimple()) {
            return false;
          }
          this.concavePath = g.vertices.slice(0);
          for (var c = 0; c < this.concavePath.length; c++) {
            var h = [0, 0];
            d.copy(h, this.concavePath[c]);
            this.concavePath[c] = h;
          }
          var i;
          i = b.optimalDecomp ? g.decomp() : g.quickDecomp();
          var j = d.create();
          for (var c = 0; c !== i.length; c++) {
            var k = new f({
              vertices: i[c].vertices
            });
            for (var l = 0; l !== k.vertices.length; l++) {
              var h = k.vertices[l];
              d.sub(h, h, k.centerOfMass);
            }
            d.scale(j, k.centerOfMass, 1);
            k.updateTriangles();
            k.updateCenterOfMass();
            k.updateBoundingRadius();
            this.addShape(k, j);
          }
          this.adjustCenterOfMass();
          this.aabbNeedsUpdate = true;
          return true;
        };
        d.fromValues(0, 0);
        var w = d.fromValues(0, 0);
        var x = d.fromValues(0, 0);
        var y = d.fromValues(0, 0);
        k.prototype.adjustCenterOfMass = function () {
          var e = 0;
          d.set(x, 0, 0);
          for (var f = 0; f !== this.shapes.length; f++) {
            var g = this.shapes[f];
            d.scale(w, g.position, g.area);
            d.add(x, x, w);
            e += g.area;
          }
          d.scale(y, x, 1 / e);
          for (var f = 0; f !== this.shapes.length; f++) {
            var g = this.shapes[f];
            d.sub(g.position, g.position, y);
          }
          d.add(this.position, this.position, y);
          for (var f = 0; this.concavePath && f < this.concavePath.length; f++) {
            d.sub(this.concavePath[f], this.concavePath[f], y);
          }
          this.updateMassProperties();
          this.updateBoundingRadius();
        };
        k.prototype.setZeroForce = function () {
          d.set(this.force, 0, 0);
          this.angularForce = 0;
        };
        k.prototype.resetConstraintVelocity = function () {
          var a = this;
          var b = a.vlambda;
          d.set(b, 0, 0);
          a.wlambda = 0;
        };
        k.prototype.addConstraintVelocity = function () {
          var a = this;
          var b = a.velocity;
          d.add(b, b, a.vlambda);
          a.angularVelocity += a.wlambda;
        };
        k.prototype.applyDamping = function (a) {
          if (this.type === k.DYNAMIC) {
            var b = this.velocity;
            d.scale(b, b, Math.pow(1 - this.damping, a));
            this.angularVelocity *= Math.pow(1 - this.angularDamping, a);
          }
        };
        k.prototype.wakeUp = function () {
          var a = this.sleepState;
          this.sleepState = k.AWAKE;
          this.idleTime = 0;
          if (a !== k.AWAKE) {
            this.emit(k.wakeUpEvent);
          }
        };
        k.prototype.sleep = function () {
          this.sleepState = k.SLEEPING;
          this.angularVelocity = 0;
          this.angularForce = 0;
          d.set(this.velocity, 0, 0);
          d.set(this.force, 0, 0);
          this.emit(k.sleepEvent);
        };
        k.prototype.sleepTick = function (a, b, c) {
          if (this.allowSleep && this.type !== k.SLEEPING) {
            this.wantsToSleep = false;
            this.sleepState;
            if (d.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2)) {
              this.idleTime = 0;
              this.sleepState = k.AWAKE;
            } else {
              this.idleTime += c;
              this.sleepState = k.SLEEPY;
            }
            if (this.idleTime > this.sleepTimeLimit) {
              if (b) {
                this.wantsToSleep = true;
              } else {
                this.sleep();
              }
            }
          }
        };
        k.prototype.overlaps = function (a) {
          return this.world.overlapKeeper.bodiesAreOverlapping(this, a);
        };
        var z = d.create();
        var A = d.create();
        k.prototype.integrate = function (a) {
          var b = this.invMass;
          var c = this.force;
          var e = this.position;
          var f = this.velocity;
          d.copy(this.previousPosition, this.position);
          this.previousAngle = this.angle;
          if (!this.fixedRotation) {
            this.angularVelocity += this.angularForce * this.invInertia * a;
          }
          d.scale(z, c, a * b);
          d.multiply(z, this.massMultiplier, z);
          d.add(f, z, f);
          if (!this.integrateToTimeOfImpact(a)) {
            d.scale(A, f, a);
            d.add(e, e, A);
            if (!this.fixedRotation) {
              this.angle += this.angularVelocity * a;
            }
          }
          this.aabbNeedsUpdate = true;
        };
        var B = new g();
        var C = new h({
          mode: h.ALL
        });
        var D = d.create();
        var E = d.create();
        var F = d.create();
        var G = d.create();
        k.prototype.integrateToTimeOfImpact = function (a) {
          if (this.ccdSpeedThreshold < 0 || d.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) {
            return false;
          }
          d.normalize(D, this.velocity);
          d.scale(E, this.velocity, a);
          d.add(E, E, this.position);
          d.sub(F, E, this.position);
          var f;
          var b = this.angularVelocity * a;
          var c = d.length(F);
          var e = 1;
          var g = this;
          B.reset();
          C.callback = function (a) {
            if (a.body !== g) {
              f = a.body;
              a.getHitPoint(E, C);
              d.sub(F, E, g.position);
              e = d.length(F) / c;
              a.stop();
            }
          };
          d.copy(C.from, this.position);
          d.copy(C.to, E);
          C.update();
          this.world.raycast(B, C);
          if (!f) {
            return false;
          }
          var h = this.angle;
          d.copy(G, this.position);
          var i = 0;
          var j = 0;
          var k = 0;
          for (var l = e; l >= j && i < this.ccdIterations;) {
            i++;
            k = (l - j) / 2;
            d.scale(A, F, e);
            d.add(this.position, G, A);
            this.angle = h + b * e;
            this.updateAABB();
            if (this.aabb.overlaps(f.aabb) && this.world.narrowphase.bodiesOverlap(this, f)) {
              j = k;
            } else {
              l = k;
            }
          }
          e = k;
          d.copy(this.position, G);
          this.angle = h;
          d.scale(A, F, e);
          d.add(this.position, this.position, A);
          if (!this.fixedRotation) {
            this.angle += b * e;
          }
          return true;
        };
        k.prototype.getVelocityAtPoint = function (a, b) {
          d.crossVZ(a, b, this.angularVelocity);
          d.subtract(a, this.velocity, a);
          return a;
        };
        k.sleepyEvent = {
          type: "sleepy"
        };
        k.sleepEvent = {
          type: "sleep"
        };
        k.wakeUpEvent = {
          type: "wakeup"
        };
        k.DYNAMIC = 1;
        k.STATIC = 2;
        k.KINEMATIC = 4;
        k.AWAKE = 0;
        k.SLEEPY = 1;
        k.SLEEPING = 2;
      }, {
        "../collision/AABB": 7,
        "../collision/Ray": 11,
        "../collision/RaycastResult": 12,
        "../events/EventEmitter": 26,
        "../math/vec2": 30,
        "../shapes/Convex": 40,
        "poly-decomp": 5
      }],
      32: [function (a, b, c) {
        function g(a, b, c) {
          c = c || {};
          e.call(this, a, b, c);
          this.localAnchorA = d.fromValues(0, 0);
          this.localAnchorB = d.fromValues(0, 0);
          if (c.localAnchorA) {
            d.copy(this.localAnchorA, c.localAnchorA);
          }
          if (c.localAnchorB) {
            d.copy(this.localAnchorB, c.localAnchorB);
          }
          if (c.worldAnchorA) {
            this.setWorldAnchorA(c.worldAnchorA);
          }
          if (c.worldAnchorB) {
            this.setWorldAnchorB(c.worldAnchorB);
          }
          var f = d.create();
          var g = d.create();
          this.getWorldAnchorA(f);
          this.getWorldAnchorB(g);
          var h = d.distance(f, g);
          this.restLength = "number" == typeof c.restLength ? c.restLength : h;
        }
        var d = a("../math/vec2");
        var e = a("./Spring");
        a("../utils/Utils");
        b.exports = g;
        g.prototype = new e();
        g.prototype.constructor = g;
        g.prototype.setWorldAnchorA = function (a) {
          this.bodyA.toLocalFrame(this.localAnchorA, a);
        };
        g.prototype.setWorldAnchorB = function (a) {
          this.bodyB.toLocalFrame(this.localAnchorB, a);
        };
        g.prototype.getWorldAnchorA = function (a) {
          this.bodyA.toWorldFrame(a, this.localAnchorA);
        };
        g.prototype.getWorldAnchorB = function (a) {
          this.bodyB.toWorldFrame(a, this.localAnchorB);
        };
        var h = d.create();
        var i = d.create();
        var j = d.create();
        var k = d.create();
        var l = d.create();
        var m = d.create();
        var n = d.create();
        var o = d.create();
        var p = d.create();
        g.prototype.applyForce = function () {
          var a = this.stiffness;
          var b = this.damping;
          var c = this.restLength;
          var e = this.bodyA;
          var f = this.bodyB;
          this.getWorldAnchorA(l);
          this.getWorldAnchorB(m);
          d.sub(n, l, e.position);
          d.sub(o, m, f.position);
          d.sub(h, m, l);
          var y = d.len(h);
          d.normalize(i, h);
          d.sub(j, f.velocity, e.velocity);
          d.crossZV(p, f.angularVelocity, o);
          d.add(j, j, p);
          d.crossZV(p, e.angularVelocity, n);
          d.sub(j, j, p);
          d.scale(k, i, -a * (y - c) - b * d.dot(j, i));
          d.sub(e.force, e.force, k);
          d.add(f.force, f.force, k);
          var z = d.crossLength(n, k);
          var A = d.crossLength(o, k);
          e.angularForce -= z;
          f.angularForce += A;
        };
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Spring": 34
      }],
      33: [function (a, b, c) {
        function f(a, b, c) {
          c = c || {};
          e.call(this, a, b, c);
          this.restAngle = "number" == typeof c.restAngle ? c.restAngle : b.angle - a.angle;
        }
        a("../math/vec2");
        var e = a("./Spring");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.applyForce = function () {
          var a = this.stiffness;
          var b = this.damping;
          var c = this.restAngle;
          var d = this.bodyA;
          var e = this.bodyB;
          var f = e.angle - d.angle;
          var g = e.angularVelocity - d.angularVelocity;
          var h = -a * (f - c) - b * g * 0;
          d.angularForce -= h;
          e.angularForce += h;
        };
      }, {
        "../math/vec2": 30,
        "./Spring": 34
      }],
      34: [function (a, b, c) {
        function f(a, b, c) {
          c = e.defaults(c, {
            stiffness: 100,
            damping: 1
          });
          this.stiffness = c.stiffness;
          this.damping = c.damping;
          this.bodyA = a;
          this.bodyB = b;
        }
        a("../math/vec2");
        var e = a("../utils/Utils");
        b.exports = f;
        f.prototype.applyForce = function () {};
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57
      }],
      35: [function (a, b, c) {
        function i(a, b) {
          b = b || {};
          this.chassisBody = a;
          this.wheels = [];
          this.groundBody = new h({
            mass: 0
          });
          this.world = null;
          var c = this;
          this.preStepCallback = function () {
            c.update();
          };
        }
        function j(a, b) {
          b = b || {};
          this.vehicle = a;
          this.forwardEquation = new g(a.chassisBody, a.groundBody);
          this.sideEquation = new g(a.chassisBody, a.groundBody);
          this.steerValue = 0;
          this.engineForce = 0;
          this.setSideFriction(undefined !== b.sideFriction ? b.sideFriction : 5);
          this.localForwardVector = d.fromValues(0, 1);
          if (b.localForwardVector) {
            d.copy(this.localForwardVector, b.localForwardVector);
          }
          this.localPosition = d.fromValues(0, 0);
          if (b.localPosition) {
            d.copy(this.localPosition, b.localPosition);
          }
          f.apply(this, a.chassisBody, a.groundBody);
          this.equations.push(this.forwardEquation, this.sideEquation);
          this.setBrakeForce(0);
        }
        var d = a("../math/vec2");
        a("../utils/Utils");
        var f = a("../constraints/Constraint");
        var g = a("../equations/FrictionEquation");
        var h = a("../objects/Body");
        b.exports = i;
        i.prototype.addToWorld = function (a) {
          this.world = a;
          a.addBody(this.groundBody);
          a.on("preStep", this.preStepCallback);
          for (var b = 0; b < this.wheels.length; b++) {
            var c = this.wheels[b];
            a.addConstraint(c);
          }
        };
        i.prototype.removeFromWorld = function () {
          var a = this.world;
          a.removeBody(this.groundBody);
          a.off("preStep", this.preStepCallback);
          for (var b = 0; b < this.wheels.length; b++) {
            var c = this.wheels[b];
            a.removeConstraint(c);
          }
          this.world = null;
        };
        i.prototype.addWheel = function (a) {
          var b = new j(this, a);
          this.wheels.push(b);
          return b;
        };
        i.prototype.update = function () {
          for (var a = 0; a < this.wheels.length; a++) {
            this.wheels[a].update();
          }
        };
        j.prototype = new f();
        j.prototype.setBrakeForce = function (a) {
          this.forwardEquation.setSlipForce(a);
        };
        j.prototype.setSideFriction = function (a) {
          this.sideEquation.setSlipForce(a);
        };
        var k = d.create();
        var l = d.create();
        j.prototype.getSpeed = function () {
          this.vehicle.chassisBody.vectorToWorldFrame(l, this.localForwardVector);
          this.vehicle.chassisBody.getVelocityAtPoint(k, l);
          return d.dot(k, l);
        };
        var m = d.create();
        j.prototype.update = function () {
          this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);
          d.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);
          this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);
          d.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);
          d.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);
          this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);
          d.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);
          this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);
          d.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);
          d.normalize(m, this.forwardEquation.t);
          d.scale(m, m, this.engineForce);
          this.vehicle.chassisBody.applyForce(m, this.forwardEquation.contactPointA);
        };
      }, {
        "../constraints/Constraint": 14,
        "../equations/FrictionEquation": 23,
        "../math/vec2": 30,
        "../objects/Body": 31,
        "../utils/Utils": 57
      }],
      36: [function (a, b, c) {
        var d = b.exports = {
          AABB: a("./collision/AABB"),
          AngleLockEquation: a("./equations/AngleLockEquation"),
          Body: a("./objects/Body"),
          Broadphase: a("./collision/Broadphase"),
          Capsule: a("./shapes/Capsule"),
          Circle: a("./shapes/Circle"),
          Constraint: a("./constraints/Constraint"),
          ContactEquation: a("./equations/ContactEquation"),
          ContactEquationPool: a("./utils/ContactEquationPool"),
          ContactMaterial: a("./material/ContactMaterial"),
          Convex: a("./shapes/Convex"),
          DistanceConstraint: a("./constraints/DistanceConstraint"),
          Equation: a("./equations/Equation"),
          EventEmitter: a("./events/EventEmitter"),
          FrictionEquation: a("./equations/FrictionEquation"),
          FrictionEquationPool: a("./utils/FrictionEquationPool"),
          GearConstraint: a("./constraints/GearConstraint"),
          GSSolver: a("./solver/GSSolver"),
          Heightfield: a("./shapes/Heightfield"),
          Line: a("./shapes/Line"),
          LockConstraint: a("./constraints/LockConstraint"),
          Material: a("./material/Material"),
          Narrowphase: a("./collision/Narrowphase"),
          NaiveBroadphase: a("./collision/NaiveBroadphase"),
          Particle: a("./shapes/Particle"),
          Plane: a("./shapes/Plane"),
          Pool: a("./utils/Pool"),
          RevoluteConstraint: a("./constraints/RevoluteConstraint"),
          PrismaticConstraint: a("./constraints/PrismaticConstraint"),
          Ray: a("./collision/Ray"),
          RaycastResult: a("./collision/RaycastResult"),
          Box: a("./shapes/Box"),
          RotationalVelocityEquation: a("./equations/RotationalVelocityEquation"),
          SAPBroadphase: a("./collision/SAPBroadphase"),
          Shape: a("./shapes/Shape"),
          Solver: a("./solver/Solver"),
          Spring: a("./objects/Spring"),
          TopDownVehicle: a("./objects/TopDownVehicle"),
          LinearSpring: a("./objects/LinearSpring"),
          RotationalSpring: a("./objects/RotationalSpring"),
          Utils: a("./utils/Utils"),
          World: a("./world/World"),
          vec2: a("./math/vec2"),
          version: a("../package.json").version
        };
        Object.defineProperty(d, "Rectangle", {
          get: function () {
            console.warn("The Rectangle class has been renamed to Box.");
            return this.Box;
          }
        });
      }, {
        "../package.json": 6,
        "./collision/AABB": 7,
        "./collision/Broadphase": 8,
        "./collision/NaiveBroadphase": 9,
        "./collision/Narrowphase": 10,
        "./collision/Ray": 11,
        "./collision/RaycastResult": 12,
        "./collision/SAPBroadphase": 13,
        "./constraints/Constraint": 14,
        "./constraints/DistanceConstraint": 15,
        "./constraints/GearConstraint": 16,
        "./constraints/LockConstraint": 17,
        "./constraints/PrismaticConstraint": 18,
        "./constraints/RevoluteConstraint": 19,
        "./equations/AngleLockEquation": 20,
        "./equations/ContactEquation": 21,
        "./equations/Equation": 22,
        "./equations/FrictionEquation": 23,
        "./equations/RotationalVelocityEquation": 25,
        "./events/EventEmitter": 26,
        "./material/ContactMaterial": 27,
        "./material/Material": 28,
        "./math/vec2": 30,
        "./objects/Body": 31,
        "./objects/LinearSpring": 32,
        "./objects/RotationalSpring": 33,
        "./objects/Spring": 34,
        "./objects/TopDownVehicle": 35,
        "./shapes/Box": 37,
        "./shapes/Capsule": 38,
        "./shapes/Circle": 39,
        "./shapes/Convex": 40,
        "./shapes/Heightfield": 41,
        "./shapes/Line": 42,
        "./shapes/Particle": 43,
        "./shapes/Plane": 44,
        "./shapes/Shape": 45,
        "./solver/GSSolver": 46,
        "./solver/Solver": 47,
        "./utils/ContactEquationPool": 48,
        "./utils/FrictionEquationPool": 49,
        "./utils/Pool": 55,
        "./utils/Utils": 57,
        "./world/World": 61
      }],
      37: [function (a, b, c) {
        function g(a) {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            a = {
              width: arguments[0],
              height: arguments[1]
            };
            console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })");
          }
          a = a || {};
          var b = this.width = a.width || 1;
          var c = this.height = a.height || 1;
          var g = [d.fromValues(-b / 2, -c / 2), d.fromValues(b / 2, -c / 2), d.fromValues(b / 2, c / 2), d.fromValues(-b / 2, c / 2)];
          var h = [d.fromValues(1, 0), d.fromValues(0, 1)];
          a.vertices = g;
          a.axes = h;
          a.type = e.BOX;
          f.call(this, a);
        }
        var d = a("../math/vec2");
        var e = a("./Shape");
        var f = a("./Convex");
        b.exports = g;
        g.prototype = new f();
        g.prototype.constructor = g;
        g.prototype.computeMomentOfInertia = function (a) {
          var b = this.width;
          var c = this.height;
          return a * (c * c + b * b) / 12;
        };
        g.prototype.updateBoundingRadius = function () {
          var a = this.width;
          var b = this.height;
          this.boundingRadius = Math.sqrt(a * a + b * b) / 2;
        };
        d.create();
        d.create();
        d.create();
        d.create();
        g.prototype.computeAABB = function (a, b, c) {
          a.setFromPoints(this.vertices, b, c, 0);
        };
        g.prototype.updateArea = function () {
          this.area = this.width * this.height;
        };
      }, {
        "../math/vec2": 30,
        "./Convex": 40,
        "./Shape": 45
      }],
      38: [function (a, b, c) {
        function f(a) {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            a = {
              length: arguments[0],
              radius: arguments[1]
            };
            console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })");
          }
          a = a || {};
          this.length = a.length || 1;
          this.radius = a.radius || 1;
          a.type = d.CAPSULE;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeMomentOfInertia = function (a) {
          var b = this.radius;
          var c = this.length + b;
          var d = 2 * b;
          return a * (d * d + c * c) / 12;
        };
        f.prototype.updateBoundingRadius = function () {
          this.boundingRadius = this.radius + this.length / 2;
        };
        f.prototype.updateArea = function () {
          this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length;
        };
        var g = e.create();
        f.prototype.computeAABB = function (a, b, c) {
          var d = this.radius;
          e.set(g, this.length / 2, 0);
          if (0 !== c) {
            e.rotate(g, g, c);
          }
          e.set(a.upperBound, Math.max(g[0] + d, -g[0] + d), Math.max(g[1] + d, -g[1] + d));
          e.set(a.lowerBound, Math.min(g[0] - d, -g[0] - d), Math.min(g[1] - d, -g[1] - d));
          e.add(a.lowerBound, a.lowerBound, b);
          e.add(a.upperBound, a.upperBound, b);
        };
        var h = e.create();
        var i = e.create();
        var j = e.create();
        var k = e.create();
        var l = e.fromValues(0, 1);
        f.prototype.raycast = function (a, b, c, d) {
          var f = b.from;
          var g = b.to;
          var n = h;
          var o = i;
          var p = j;
          var q = k;
          var r = this.length / 2;
          for (var s = 0; s < 2; s++) {
            var f;
            var g;
            var n;
            var o;
            var p;
            var q;
            var r;
            var s;
            var t = this.radius * (2 * s - 1);
            e.set(j, -r, t);
            e.set(k, r, t);
            e.toGlobalFrame(j, j, c, d);
            e.toGlobalFrame(k, k, c, d);
            var u = e.getLineSegmentsIntersectionFraction(f, g, j, k);
            if (u >= 0 && (e.rotate(i, l, d), e.scale(i, i, 2 * s - 1), b.reportIntersection(a, u, i, -1), a.shouldStop(b))) {
              return;
            }
          }
          var v = Math.pow(this.radius, 2) + Math.pow(r, 2);
          for (var s = 0; s < 2; s++) {
            e.set(j, r * (2 * s - 1), 0);
            e.toGlobalFrame(j, j, c, d);
            var w = Math.pow(g[0] - f[0], 2) + Math.pow(g[1] - f[1], 2);
            var x = 2 * ((g[0] - f[0]) * (f[0] - j[0]) + (g[1] - f[1]) * (f[1] - j[1]));
            var y = Math.pow(f[0] - j[0], 2) + Math.pow(f[1] - j[1], 2) - Math.pow(this.radius, 2);
            var u = Math.pow(x, 2) - 4 * w * y;
            if (!(u < 0)) {
              if (0 === u) {
                e.lerp(n, f, g, u);
                if (e.squaredDistance(n, c) > v && (e.sub(i, n, j), e.normalize(i, i), b.reportIntersection(a, u, i, -1), a.shouldStop(b))) {
                  return;
                }
              } else {
                var z = Math.sqrt(u);
                var A = 1 / (2 * w);
                var B = (-x - z) * A;
                var C = (-x + z) * A;
                if (B >= 0 && B <= 1 && (e.lerp(n, f, g, B), e.squaredDistance(n, c) > v && (e.sub(i, n, j), e.normalize(i, i), b.reportIntersection(a, B, i, -1), a.shouldStop(b)))) {
                  return;
                }
                if (C >= 0 && C <= 1 && (e.lerp(n, f, g, C), e.squaredDistance(n, c) > v && (e.sub(i, n, j), e.normalize(i, i), b.reportIntersection(a, C, i, -1), a.shouldStop(b)))) {
                  return;
                }
              }
            }
          }
        };
      }, {
        "../math/vec2": 30,
        "./Shape": 45
      }],
      39: [function (a, b, c) {
        function f(a) {
          if ("number" == typeof arguments[0]) {
            a = {
              radius: arguments[0]
            };
            console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })");
          }
          a = a || {};
          this.radius = a.radius || 1;
          a.type = d.CIRCLE;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeMomentOfInertia = function (a) {
          var b = this.radius;
          return a * b * b / 2;
        };
        f.prototype.updateBoundingRadius = function () {
          this.boundingRadius = this.radius;
        };
        f.prototype.updateArea = function () {
          this.area = Math.PI * this.radius * this.radius;
        };
        f.prototype.computeAABB = function (a, b, c) {
          var d = this.radius;
          e.set(a.upperBound, d, d);
          e.set(a.lowerBound, -d, -d);
          if (b) {
            e.add(a.lowerBound, a.lowerBound, b);
            e.add(a.upperBound, a.upperBound, b);
          }
        };
        var g = e.create();
        var h = e.create();
        f.prototype.raycast = function (a, b, c, d) {
          var f = b.from;
          var i = b.to;
          var j = this.radius;
          var k = Math.pow(i[0] - f[0], 2) + Math.pow(i[1] - f[1], 2);
          var l = 2 * ((i[0] - f[0]) * (f[0] - c[0]) + (i[1] - f[1]) * (f[1] - c[1]));
          var m = Math.pow(f[0] - c[0], 2) + Math.pow(f[1] - c[1], 2) - Math.pow(j, 2);
          var n = Math.pow(l, 2) - 4 * k * m;
          if (!(n < 0)) {
            if (0 === n) {
              e.lerp(g, f, i, n);
              e.sub(h, g, c);
              e.normalize(h, h);
              b.reportIntersection(a, n, h, -1);
            } else {
              var q = Math.sqrt(n);
              var r = 1 / (2 * k);
              var s = (-l - q) * r;
              var t = (-l + q) * r;
              if (s >= 0 && s <= 1 && (e.lerp(g, f, i, s), e.sub(h, g, c), e.normalize(h, h), b.reportIntersection(a, s, h, -1), a.shouldStop(b))) {
                return;
              }
              if (t >= 0 && t <= 1) {
                e.lerp(g, f, i, t);
                e.sub(h, g, c);
                e.normalize(h, h);
                b.reportIntersection(a, t, h, -1);
              }
            }
          }
        };
      }, {
        "../math/vec2": 30,
        "./Shape": 45
      }],
      40: [function (a, b, c) {
        function h(a) {
          if (Array.isArray(arguments[0])) {
            a = {
              vertices: arguments[0],
              axes: arguments[1]
            };
            console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })");
          }
          a = a || {};
          this.vertices = [];
          var b = undefined !== a.vertices ? a.vertices : [];
          for (var c = 0; c < b.length; c++) {
            var f = e.create();
            e.copy(f, b[c]);
            this.vertices.push(f);
          }
          this.axes = [];
          if (a.axes) {
            for (var c = 0; c < a.axes.length; c++) {
              var g = e.create();
              e.copy(g, a.axes[c]);
              this.axes.push(g);
            }
          } else {
            for (var c = 0; c < this.vertices.length; c++) {
              var h = this.vertices[c];
              var i = this.vertices[(c + 1) % this.vertices.length];
              var j = e.create();
              e.sub(j, i, h);
              e.rotate90cw(j, j);
              e.normalize(j, j);
              this.axes.push(j);
            }
          }
          this.centerOfMass = e.fromValues(0, 0);
          this.triangles = [];
          if (this.vertices.length) {
            this.updateTriangles();
            this.updateCenterOfMass();
          }
          this.boundingRadius = 0;
          a.type = d.CONVEX;
          d.call(this, a);
          this.updateBoundingRadius();
          this.updateArea();
          if (this.area < 0) {
            throw new Error("Convex vertices must be given in conter-clockwise winding.");
          }
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        var f = a("../math/polyk");
        a("poly-decomp");
        b.exports = h;
        h.prototype = new d();
        h.prototype.constructor = h;
        var i = e.create();
        var j = e.create();
        h.prototype.projectOntoLocalAxis = function (a, b) {
          var f;
          var g;
          var c = null;
          var d = null;
          var a = i;
          for (var h = 0; h < this.vertices.length; h++) {
            f = this.vertices[h];
            g = e.dot(f, a);
            if (null === c || g > c) {
              c = g;
            }
            if (null === d || g < d) {
              d = g;
            }
          }
          if (d > c) {
            d = c;
            c = d;
          }
          e.set(b, d, c);
        };
        h.prototype.projectOntoWorldAxis = function (a, b, c, d) {
          var f = j;
          this.projectOntoLocalAxis(a, d);
          if (0 !== c) {
            e.rotate(f, a, c);
          } else {
            f = a;
          }
          var g = e.dot(b, f);
          e.set(d, d[0] + g, d[1] + g);
        };
        h.prototype.updateTriangles = function () {
          this.triangles.length = 0;
          var a = [];
          for (var b = 0; b < this.vertices.length; b++) {
            var c = this.vertices[b];
            a.push(c[0], c[1]);
          }
          var d = f.Triangulate(a);
          for (var b = 0; b < d.length; b += 3) {
            var e = d[b];
            var g = d[b + 1];
            var h = d[b + 2];
            this.triangles.push([e, g, h]);
          }
        };
        var k = e.create();
        var l = e.create();
        var m = e.create();
        var n = e.create();
        var o = e.create();
        e.create();
        e.create();
        e.create();
        e.create();
        h.prototype.updateCenterOfMass = function () {
          var a = this.triangles;
          var b = this.vertices;
          var c = this.centerOfMass;
          var g = m;
          var i = n;
          var j = o;
          e.set(c, 0, 0);
          var x = 0;
          for (var y = 0; y !== a.length; y++) {
            var z = a[y];
            var g = b[z[0]];
            var i = b[z[1]];
            var j = b[z[2]];
            e.centroid(k, g, i, j);
            var A = h.triangleArea(g, i, j);
            x += A;
            e.scale(l, k, A);
            e.add(c, c, l);
          }
          e.scale(c, c, 1 / x);
        };
        h.prototype.computeMomentOfInertia = function (a) {
          var b = 0;
          var c = 0;
          var d = this.vertices.length;
          var f = d - 1;
          for (var g = 0; g < d; f = g, g++) {
            var h = this.vertices[f];
            var i = this.vertices[g];
            var j = Math.abs(e.crossLength(h, i));
            b += j * (e.dot(i, i) + e.dot(i, h) + e.dot(h, h));
            c += j;
          }
          return a / 6 * (b / c);
        };
        h.prototype.updateBoundingRadius = function () {
          var a = this.vertices;
          var b = 0;
          for (var c = 0; c !== a.length; c++) {
            var d = e.squaredLength(a[c]);
            if (d > b) {
              b = d;
            }
          }
          this.boundingRadius = Math.sqrt(b);
        };
        h.triangleArea = function (a, b, c) {
          return .5 * ((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]));
        };
        h.prototype.updateArea = function () {
          this.updateTriangles();
          this.area = 0;
          var a = this.triangles;
          var b = this.vertices;
          for (var c = 0; c !== a.length; c++) {
            var d = a[c];
            var e = b[d[0]];
            var f = b[d[1]];
            var g = b[d[2]];
            var i = h.triangleArea(e, f, g);
            this.area += i;
          }
        };
        h.prototype.computeAABB = function (a, b, c) {
          a.setFromPoints(this.vertices, b, c, 0);
        };
        var t = e.create();
        var u = e.create();
        var v = e.create();
        h.prototype.raycast = function (a, b, c, d) {
          var i = this.vertices;
          e.toLocalFrame(t, b.from, c, d);
          e.toLocalFrame(u, b.to, c, d);
          var j = i.length;
          for (var k = 0; k < j && !a.shouldStop(b); k++) {
            var l = i[k];
            var m = i[(k + 1) % j];
            var n = e.getLineSegmentsIntersectionFraction(t, u, l, m);
            if (n >= 0) {
              e.sub(v, m, l);
              e.rotate(v, v, -Math.PI / 2 + d);
              e.normalize(v, v);
              b.reportIntersection(a, n, v, k);
            }
          }
        };
      }, {
        "../math/polyk": 29,
        "../math/vec2": 30,
        "./Shape": 45,
        "poly-decomp": 5
      }],
      41: [function (a, b, c) {
        function g(a) {
          if (Array.isArray(arguments[0])) {
            a = {
              heights: arguments[0]
            };
            if ("object" == typeof arguments[1]) {
              for (var b in arguments[1]) a[b] = arguments[1][b];
            }
            console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })");
          }
          a = a || {};
          this.heights = a.heights ? a.heights.slice(0) : [];
          this.maxValue = a.maxValue || null;
          this.minValue = a.minValue || null;
          this.elementWidth = a.elementWidth || .1;
          if (!(undefined !== a.maxValue && undefined !== a.minValue)) {
            this.updateMaxMinValues();
          }
          a.type = d.HEIGHTFIELD;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        a("../utils/Utils");
        b.exports = g;
        g.prototype = new d();
        g.prototype.constructor = g;
        g.prototype.updateMaxMinValues = function () {
          var a = this.heights;
          var b = a[0];
          var c = a[0];
          for (var d = 0; d !== a.length; d++) {
            var e = a[d];
            if (e > b) {
              b = e;
            }
            if (e < c) {
              c = e;
            }
          }
          this.maxValue = b;
          this.minValue = c;
        };
        g.prototype.computeMomentOfInertia = function (a) {
          return Number.MAX_VALUE;
        };
        g.prototype.updateBoundingRadius = function () {
          this.boundingRadius = Number.MAX_VALUE;
        };
        g.prototype.updateArea = function () {
          var a = this.heights;
          var b = 0;
          for (var c = 0; c < a.length - 1; c++) {
            b += (a[c] + a[c + 1]) / 2 * this.elementWidth;
          }
          this.area = b;
        };
        var h = [e.create(), e.create(), e.create(), e.create()];
        g.prototype.computeAABB = function (a, b, c) {
          e.set(h[0], 0, this.maxValue);
          e.set(h[1], this.elementWidth * this.heights.length, this.maxValue);
          e.set(h[2], this.elementWidth * this.heights.length, this.minValue);
          e.set(h[3], 0, this.minValue);
          a.setFromPoints(h, b, c);
        };
        g.prototype.getLineSegment = function (a, b, c) {
          var d = this.heights;
          var f = this.elementWidth;
          e.set(a, c * f, d[c]);
          e.set(b, (c + 1) * f, d[c + 1]);
        };
        g.prototype.getSegmentIndex = function (a) {
          return Math.floor(a[0] / this.elementWidth);
        };
        g.prototype.getClampedSegmentIndex = function (a) {
          var b = this.getSegmentIndex(a);
          return b = Math.min(this.heights.length, Math.max(b, 0));
        };
        e.create();
        var j = e.create();
        var k = e.create();
        var l = e.create();
        var m = e.create();
        var n = e.create();
        e.fromValues(0, 1);
        g.prototype.raycast = function (a, b, c, d) {
          var f = b.from;
          var g = b.to;
          b.direction;
          e.toLocalFrame(m, f, c, d);
          e.toLocalFrame(n, g, c, d);
          var u = this.getClampedSegmentIndex(m);
          var v = this.getClampedSegmentIndex(n);
          if (u > v) {
            u = v;
            v = u;
          }
          for (var x = 0; x < this.heights.length - 1; x++) {
            this.getLineSegment(k, l, x);
            var y = e.getLineSegmentsIntersectionFraction(m, n, k, l);
            if (y >= 0 && (e.sub(j, l, k), e.rotate(j, j, d + Math.PI / 2), e.normalize(j, j), b.reportIntersection(a, y, j, -1), a.shouldStop(b))) {
              return;
            }
          }
        };
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Shape": 45
      }],
      42: [function (a, b, c) {
        function f(a) {
          if ("number" == typeof arguments[0]) {
            a = {
              length: arguments[0]
            };
            console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })");
          }
          a = a || {};
          this.length = a.length || 1;
          a.type = d.LINE;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeMomentOfInertia = function (a) {
          return a * Math.pow(this.length, 2) / 12;
        };
        f.prototype.updateBoundingRadius = function () {
          this.boundingRadius = this.length / 2;
        };
        var g = [e.create(), e.create()];
        f.prototype.computeAABB = function (a, b, c) {
          var d = this.length / 2;
          e.set(g[0], -d, 0);
          e.set(g[1], d, 0);
          a.setFromPoints(g, b, c, 0);
        };
        e.create();
        var i = e.create();
        var j = e.create();
        var k = e.create();
        var l = e.fromValues(0, 1);
        f.prototype.raycast = function (a, b, c, d) {
          var f = b.from;
          var g = b.to;
          var n = this.length / 2;
          e.set(j, -n, 0);
          e.set(k, n, 0);
          e.toGlobalFrame(j, j, c, d);
          e.toGlobalFrame(k, k, c, d);
          var o = e.getLineSegmentsIntersectionFraction(j, k, f, g);
          if (o >= 0) {
            e.rotate(i, l, d);
            b.reportIntersection(a, o, i, -1);
          }
        };
      }, {
        "../math/vec2": 30,
        "./Shape": 45
      }],
      43: [function (a, b, c) {
        function f(a) {
          a = a || {};
          a.type = d.PARTICLE;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        b.exports = f;
        f.prototype = new d();
        f.prototype.constructor = f;
        f.prototype.computeMomentOfInertia = function (a) {
          return 0;
        };
        f.prototype.updateBoundingRadius = function () {
          this.boundingRadius = 0;
        };
        f.prototype.computeAABB = function (a, b, c) {
          e.copy(a.lowerBound, b);
          e.copy(a.upperBound, b);
        };
      }, {
        "../math/vec2": 30,
        "./Shape": 45
      }],
      44: [function (a, b, c) {
        function g(a) {
          a = a || {};
          a.type = d.PLANE;
          d.call(this, a);
        }
        var d = a("./Shape");
        var e = a("../math/vec2");
        a("../utils/Utils");
        b.exports = g;
        g.prototype = new d();
        g.prototype.constructor = g;
        g.prototype.computeMomentOfInertia = function (a) {
          return 0;
        };
        g.prototype.updateBoundingRadius = function () {
          this.boundingRadius = Number.MAX_VALUE;
        };
        g.prototype.computeAABB = function (a, b, c) {
          var d = c % (2 * Math.PI);
          var f = e.set;
          var g = Number.MAX_VALUE;
          var h = a.lowerBound;
          var i = a.upperBound;
          if (0 === d) {
            f(h, -g, -g);
            f(i, g, 0);
          } else if (d === Math.PI / 2) {
            f(h, 0, -g);
            f(i, g, g);
          } else if (d === Math.PI) {
            f(h, -g, 0);
            f(i, g, g);
          } else if (d === 3 * Math.PI / 2) {
            f(h, -g, -g);
            f(i, 0, g);
          } else {
            f(h, -g, -g);
            f(i, g, g);
          }
          e.add(h, h, b);
          e.add(i, i, b);
        };
        g.prototype.updateArea = function () {
          this.area = Number.MAX_VALUE;
        };
        var h = e.create();
        e.create();
        e.create();
        var k = e.create();
        var l = e.create();
        g.prototype.raycast = function (a, b, c, d) {
          var f = b.from;
          var g = b.to;
          var m = b.direction;
          e.set(k, 0, 1);
          e.rotate(k, k, d);
          e.sub(l, f, c);
          var s = e.dot(l, k);
          e.sub(l, g, c);
          if (!(s * e.dot(l, k) > 0 || e.squaredDistance(f, g) < s * s)) {
            var u = e.dot(k, m);
            e.sub(h, f, c);
            var v = -e.dot(k, h) / u / b.length;
            b.reportIntersection(a, v, k, -1);
          }
        };
      }, {
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Shape": 45
      }],
      45: [function (a, b, c) {
        function e(a) {
          a = a || {};
          this.body = null;
          this.position = d.fromValues(0, 0);
          if (a.position) {
            d.copy(this.position, a.position);
          }
          this.angle = a.angle || 0;
          this.type = a.type || 0;
          this.id = e.idCounter++;
          this.boundingRadius = 0;
          this.collisionGroup = undefined !== a.collisionGroup ? a.collisionGroup : 1;
          this.collisionResponse = undefined === a.collisionResponse || a.collisionResponse;
          this.collisionMask = undefined !== a.collisionMask ? a.collisionMask : 1;
          this.material = a.material || null;
          this.area = 0;
          this.sensor = undefined !== a.sensor && a.sensor;
          if (this.type) {
            this.updateBoundingRadius();
          }
          this.updateArea();
        }
        b.exports = e;
        var d = a("../math/vec2");
        e.idCounter = 0;
        e.CIRCLE = 1;
        e.PARTICLE = 2;
        e.PLANE = 4;
        e.CONVEX = 8;
        e.LINE = 16;
        e.BOX = 32;
        Object.defineProperty(e, "RECTANGLE", {
          get: function () {
            console.warn("Shape.RECTANGLE is deprecated, use Shape.BOX instead.");
            return e.BOX;
          }
        });
        e.CAPSULE = 64;
        e.HEIGHTFIELD = 128;
        e.prototype.computeMomentOfInertia = function (a) {};
        e.prototype.updateBoundingRadius = function () {};
        e.prototype.updateArea = function () {};
        e.prototype.computeAABB = function (a, b, c) {};
        e.prototype.raycast = function (a, b, c, d) {};
      }, {
        "../math/vec2": 30
      }],
      46: [function (a, b, c) {
        function h(a) {
          e.call(this, a, e.GS);
          a = a || {};
          this.iterations = a.iterations || 10;
          this.tolerance = a.tolerance || 1e-7;
          this.arrayStep = 30;
          this.lambda = new f.ARRAY_TYPE(this.arrayStep);
          this.Bs = new f.ARRAY_TYPE(this.arrayStep);
          this.invCs = new f.ARRAY_TYPE(this.arrayStep);
          this.useZeroRHS = false;
          this.frictionIterations = 0;
          this.usedIterations = 0;
        }
        function i(a) {
          for (var b = a.length; b--;) {
            a[b] = 0;
          }
        }
        var d = a("../math/vec2");
        var e = a("./Solver");
        var f = a("../utils/Utils");
        var g = a("../equations/FrictionEquation");
        b.exports = h;
        h.prototype = new e();
        h.prototype.constructor = h;
        h.prototype.solve = function (a, b) {
          this.sortEquations();
          var c = 0;
          var e = this.iterations;
          var j = this.frictionIterations;
          var k = this.equations;
          var l = k.length;
          var m = Math.pow(this.tolerance * l, 2);
          var n = b.bodies;
          var o = b.bodies.length;
          d.add;
          d.set;
          var r = this.useZeroRHS;
          var s = this.lambda;
          this.usedIterations = 0;
          if (l) {
            for (var t = 0; t !== o; t++) {
              var u = n[t];
              u.updateSolveMassProperties();
            }
          }
          if (s.length < l) {
            s = this.lambda = new f.ARRAY_TYPE(l + this.arrayStep);
            this.Bs = new f.ARRAY_TYPE(l + this.arrayStep);
            this.invCs = new f.ARRAY_TYPE(l + this.arrayStep);
          }
          i(s);
          var v = this.invCs;
          var w = this.Bs;
          var s = this.lambda;
          for (var t = 0; t !== k.length; t++) {
            var x = k[t];
            if (x.timeStep !== a || x.needsUpdate) {
              x.timeStep = a;
              x.update();
            }
            w[t] = x.computeB(x.a, x.b, a);
            v[t] = x.computeInvC(x.epsilon);
          }
          var x;
          var A;
          var t;
          var B;
          if (0 !== l) {
            for (t = 0; t !== o; t++) {
              var u = n[t];
              u.resetConstraintVelocity();
            }
            if (j) {
              for (c = 0; c !== j; c++) {
                A = 0;
                for (B = 0; B !== l; B++) {
                  x = k[B];
                  var C = h.iterateEquation(B, x, x.epsilon, w, v, s, r, a, c);
                  A += Math.abs(C);
                }
                this.usedIterations++;
                if (A * A <= m) {
                  break;
                }
              }
              h.updateMultipliers(k, s, 1 / a);
              for (B = 0; B !== l; B++) {
                var D = k[B];
                if (D instanceof g) {
                  var E = 0;
                  for (var F = 0; F !== D.contactEquations.length; F++) {
                    E += D.contactEquations[F].multiplier;
                  }
                  E *= D.frictionCoefficient / D.contactEquations.length;
                  D.maxForce = E;
                  D.minForce = -E;
                }
              }
            }
            for (c = 0; c !== e; c++) {
              A = 0;
              for (B = 0; B !== l; B++) {
                x = k[B];
                var C = h.iterateEquation(B, x, x.epsilon, w, v, s, r, a, c);
                A += Math.abs(C);
              }
              this.usedIterations++;
              if (A * A <= m) {
                break;
              }
            }
            for (t = 0; t !== o; t++) {
              n[t].addConstraintVelocity();
            }
            h.updateMultipliers(k, s, 1 / a);
          }
        };
        h.updateMultipliers = function (a, b, c) {
          for (var d = a.length; d--;) {
            a[d].multiplier = b[d] * c;
          }
        };
        h.iterateEquation = function (a, b, c, d, e, f, g, h, i) {
          var j = d[a];
          var k = e[a];
          var l = f[a];
          var m = b.computeGWlambda();
          var n = b.maxForce;
          var o = b.minForce;
          if (g) {
            j = 0;
          }
          var p = k * (j - m - c * l);
          var q = l + p;
          if (q < o * h) {
            p = o * h - l;
          } else if (q > n * h) {
            p = n * h - l;
          }
          f[a] += p;
          b.addToWlambda(p);
          return p;
        };
      }, {
        "../equations/FrictionEquation": 23,
        "../math/vec2": 30,
        "../utils/Utils": 57,
        "./Solver": 47
      }],
      47: [function (a, b, c) {
        function f(a, b) {
          a = a || {};
          e.call(this);
          this.type = b;
          this.equations = [];
          this.equationSortFunction = a.equationSortFunction || false;
        }
        a("../utils/Utils");
        var e = a("../events/EventEmitter");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.solve = function (a, b) {
          throw new Error("Solver.solve should be implemented by subclasses!");
        };
        var g = {
          bodies: []
        };
        f.prototype.solveIsland = function (a, b) {
          this.removeAllEquations();
          if (b.equations.length) {
            this.addEquations(b.equations);
            g.bodies.length = 0;
            b.getBodies(g.bodies);
            if (g.bodies.length) {
              this.solve(a, g);
            }
          }
        };
        f.prototype.sortEquations = function () {
          if (this.equationSortFunction) {
            this.equations.sort(this.equationSortFunction);
          }
        };
        f.prototype.addEquation = function (a) {
          if (a.enabled) {
            this.equations.push(a);
          }
        };
        f.prototype.addEquations = function (a) {
          var b = 0;
          for (var c = a.length; b !== c; b++) {
            var d = a[b];
            if (d.enabled) {
              this.equations.push(d);
            }
          }
        };
        f.prototype.removeEquation = function (a) {
          var b = this.equations.indexOf(a);
          if (-1 !== b) {
            this.equations.splice(b, 1);
          }
        };
        f.prototype.removeAllEquations = function () {
          this.equations.length = 0;
        };
        f.GS = 1;
        f.ISLAND = 2;
      }, {
        "../events/EventEmitter": 26,
        "../utils/Utils": 57
      }],
      48: [function (a, b, c) {
        function f() {
          e.apply(this, arguments);
        }
        var d = a("../equations/ContactEquation");
        var e = a("./Pool");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.create = function () {
          return new d();
        };
        f.prototype.destroy = function (a) {
          a.bodyA = a.bodyB = null;
          return this;
        };
      }, {
        "../equations/ContactEquation": 21,
        "./Pool": 55
      }],
      49: [function (a, b, c) {
        function f() {
          e.apply(this, arguments);
        }
        var d = a("../equations/FrictionEquation");
        var e = a("./Pool");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.create = function () {
          return new d();
        };
        f.prototype.destroy = function (a) {
          a.bodyA = a.bodyB = null;
          return this;
        };
      }, {
        "../equations/FrictionEquation": 23,
        "./Pool": 55
      }],
      50: [function (a, b, c) {
        function f() {
          e.apply(this, arguments);
        }
        var d = a("../world/IslandNode");
        var e = a("./Pool");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.create = function () {
          return new d();
        };
        f.prototype.destroy = function (a) {
          a.reset();
          return this;
        };
      }, {
        "../world/IslandNode": 60,
        "./Pool": 55
      }],
      51: [function (a, b, c) {
        function f() {
          e.apply(this, arguments);
        }
        var d = a("../world/Island");
        var e = a("./Pool");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.create = function () {
          return new d();
        };
        f.prototype.destroy = function (a) {
          a.reset();
          return this;
        };
      }, {
        "../world/Island": 58,
        "./Pool": 55
      }],
      52: [function (a, b, c) {
        function h() {
          this.overlappingShapesLastState = new d();
          this.overlappingShapesCurrentState = new d();
          this.recordPool = new f({
            size: 16
          });
          this.tmpDict = new d();
          this.tmpArray1 = [];
        }
        var d = a("./TupleDictionary");
        a("./OverlapKeeperRecord");
        var f = a("./OverlapKeeperRecordPool");
        a("./Utils");
        b.exports = h;
        h.prototype.tick = function () {
          var a = this.overlappingShapesLastState;
          var b = this.overlappingShapesCurrentState;
          for (var c = a.keys.length; c--;) {
            var d = a.keys[c];
            var e = a.getByKey(d);
            b.getByKey(d);
            if (e) {
              this.recordPool.release(e);
            }
          }
          a.reset();
          a.copy(b);
          b.reset();
        };
        h.prototype.setOverlapping = function (a, b, c, d) {
          this.overlappingShapesLastState;
          var f = this.overlappingShapesCurrentState;
          if (!f.get(b.id, d.id)) {
            var g = this.recordPool.get();
            g.set(a, b, c, d);
            f.set(b.id, d.id, g);
          }
        };
        h.prototype.getNewOverlaps = function (a) {
          return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, a);
        };
        h.prototype.getEndOverlaps = function (a) {
          return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, a);
        };
        h.prototype.bodiesAreOverlapping = function (a, b) {
          var c = this.overlappingShapesCurrentState;
          for (var d = c.keys.length; d--;) {
            var e = c.keys[d];
            var f = c.data[e];
            if (f.bodyA === a && f.bodyB === b || f.bodyA === b && f.bodyB === a) {
              return true;
            }
          }
          return false;
        };
        h.prototype.getDiff = function (a, b, c) {
          var c = c || [];
          c.length = 0;
          for (var f = b.keys.length; f--;) {
            var g = b.keys[f];
            var h = b.data[g];
            if (!h) {
              throw new Error("Key " + g + " had no data!");
            }
            if (!a.data[g]) {
              c.push(h);
            }
          }
          return c;
        };
        h.prototype.isNewOverlap = function (a, b) {
          var c = 0 | a.id;
          var d = 0 | b.id;
          var e = this.overlappingShapesLastState;
          var f = this.overlappingShapesCurrentState;
          return !e.get(c, d) && !!f.get(c, d);
        };
        h.prototype.getNewBodyOverlaps = function (a) {
          this.tmpArray1.length = 0;
          var b = this.getNewOverlaps(this.tmpArray1);
          return this.getBodyDiff(b, a);
        };
        h.prototype.getEndBodyOverlaps = function (a) {
          this.tmpArray1.length = 0;
          var b = this.getEndOverlaps(this.tmpArray1);
          return this.getBodyDiff(b, a);
        };
        h.prototype.getBodyDiff = function (a, b) {
          b = b || [];
          var c = this.tmpDict;
          for (var d = a.length; d--;) {
            var e = a[d];
            c.set(0 | e.bodyA.id, 0 | e.bodyB.id, e);
          }
          for (d = c.keys.length; d--;) {
            var e = c.getByKey(c.keys[d]);
            if (e) {
              b.push(e.bodyA, e.bodyB);
            }
          }
          c.reset();
          return b;
        };
      }, {
        "./OverlapKeeperRecord": 53,
        "./OverlapKeeperRecordPool": 54,
        "./TupleDictionary": 56,
        "./Utils": 57
      }],
      53: [function (a, b, c) {
        function d(a, b, c, d) {
          this.shapeA = b;
          this.shapeB = d;
          this.bodyA = a;
          this.bodyB = c;
        }
        b.exports = d;
        d.prototype.set = function (a, b, c, e) {
          d.call(this, a, b, c, e);
        };
      }, {}],
      54: [function (a, b, c) {
        function f() {
          e.apply(this, arguments);
        }
        var d = a("./OverlapKeeperRecord");
        var e = a("./Pool");
        b.exports = f;
        f.prototype = new e();
        f.prototype.constructor = f;
        f.prototype.create = function () {
          return new d();
        };
        f.prototype.destroy = function (a) {
          a.bodyA = a.bodyB = a.shapeA = a.shapeB = null;
          return this;
        };
      }, {
        "./OverlapKeeperRecord": 53,
        "./Pool": 55
      }],
      55: [function (a, b, c) {
        function d(a) {
          a = a || {};
          this.objects = [];
          if (undefined !== a.size) {
            this.resize(a.size);
          }
        }
        b.exports = d;
        d.prototype.resize = function (a) {
          for (var b = this.objects; b.length > a;) {
            b.pop();
          }
          for (; b.length < a;) {
            b.push(this.create());
          }
          return this;
        };
        d.prototype.get = function () {
          var a = this.objects;
          return a.length ? a.pop() : this.create();
        };
        d.prototype.release = function (a) {
          this.destroy(a);
          this.objects.push(a);
          return this;
        };
      }, {}],
      56: [function (a, b, c) {
        function e() {
          this.data = {};
          this.keys = [];
        }
        var d = a("./Utils");
        b.exports = e;
        e.prototype.getKey = function (a, b) {
          a |= 0;
          b |= 0;
          return (0 | a) == (0 | b) ? -1 : 0 | ((0 | a) > (0 | b) ? a << 16 | 65535 & b : b << 16 | 65535 & a);
        };
        e.prototype.getByKey = function (a) {
          a |= 0;
          return this.data[a];
        };
        e.prototype.get = function (a, b) {
          return this.data[this.getKey(a, b)];
        };
        e.prototype.set = function (a, b, c) {
          if (!c) {
            throw new Error("No data!");
          }
          var d = this.getKey(a, b);
          if (!this.data[d]) {
            this.keys.push(d);
          }
          this.data[d] = c;
          return d;
        };
        e.prototype.reset = function () {
          var a = this.data;
          var b = this.keys;
          for (var c = b.length; c--;) {
            delete a[b[c]];
          }
          b.length = 0;
        };
        e.prototype.copy = function (a) {
          this.reset();
          d.appendArray(this.keys, a.keys);
          for (var b = a.keys.length; b--;) {
            var c = a.keys[b];
            this.data[c] = a.data[c];
          }
        };
      }, {
        "./Utils": 57
      }],
      57: [function (a, b, c) {
        function d() {}
        b.exports = d;
        d.appendArray = function (a, b) {
          if (b.length < 15e4) {
            a.push.apply(a, b);
          } else {
            var c = 0;
            for (var d = b.length; c !== d; ++c) {
              a.push(b[c]);
            }
          }
        };
        d.splice = function (a, b, c) {
          c = c || 1;
          var d = b;
          for (var e = a.length - c; d < e; d++) {
            a[d] = a[d + c];
          }
          a.length = e;
        };
        if ("undefined" != typeof P2_ARRAY_TYPE) {
          d.ARRAY_TYPE = P2_ARRAY_TYPE;
        } else if ("undefined" != typeof Float32Array) {
          d.ARRAY_TYPE = Float32Array;
        } else {
          d.ARRAY_TYPE = Array;
        }
        d.extend = function (a, b) {
          for (var c in b) a[c] = b[c];
        };
        d.defaults = function (a, b) {
          a = a || {};
          for (var c in b) if (!(c in a)) {
            a[c] = b[c];
          }
          return a;
        };
      }, {}],
      58: [function (a, b, c) {
        function e() {
          this.equations = [];
          this.bodies = [];
        }
        var d = a("../objects/Body");
        b.exports = e;
        e.prototype.reset = function () {
          this.equations.length = this.bodies.length = 0;
        };
        var f = [];
        e.prototype.getBodies = function (a) {
          var b = a || [];
          var c = this.equations;
          f.length = 0;
          for (var d = 0; d !== c.length; d++) {
            var e = c[d];
            if (-1 === f.indexOf(e.bodyA.id)) {
              b.push(e.bodyA);
              f.push(e.bodyA.id);
            }
            if (-1 === f.indexOf(e.bodyB.id)) {
              b.push(e.bodyB);
              f.push(e.bodyB.id);
            }
          }
          return b;
        };
        e.prototype.wantsToSleep = function () {
          for (var a = 0; a < this.bodies.length; a++) {
            var b = this.bodies[a];
            if (b.type === d.DYNAMIC && !b.wantsToSleep) {
              return false;
            }
          }
          return true;
        };
        e.prototype.sleep = function () {
          for (var a = 0; a < this.bodies.length; a++) {
            this.bodies[a].sleep();
          }
          return true;
        };
      }, {
        "../objects/Body": 31
      }],
      59: [function (a, b, c) {
        function j(a) {
          this.nodePool = new g({
            size: 16
          });
          this.islandPool = new h({
            size: 8
          });
          this.equations = [];
          this.islands = [];
          this.nodes = [];
          this.queue = [];
        }
        a("../math/vec2");
        a("./Island");
        a("./IslandNode");
        var g = a("./../utils/IslandNodePool");
        var h = a("./../utils/IslandPool");
        var i = a("../objects/Body");
        b.exports = j;
        j.getUnvisitedNode = function (a) {
          var b = a.length;
          for (var c = 0; c !== b; c++) {
            var d = a[c];
            if (!d.visited && d.body.type === i.DYNAMIC) {
              return d;
            }
          }
          return false;
        };
        j.prototype.visit = function (a, b, c) {
          b.push(a.body);
          var d = a.equations.length;
          for (var e = 0; e !== d; e++) {
            var f = a.equations[e];
            if (-1 === c.indexOf(f)) {
              c.push(f);
            }
          }
        };
        j.prototype.bfs = function (a, b, c) {
          var d = this.queue;
          d.length = 0;
          d.push(a);
          a.visited = true;
          for (this.visit(a, b, c); d.length;) {
            var f;
            for (var e = d.pop(); f = j.getUnvisitedNode(e.neighbors);) {
              f.visited = true;
              this.visit(f, b, c);
              if (f.body.type === i.DYNAMIC) {
                d.push(f);
              }
            }
          }
        };
        j.prototype.split = function (a) {
          var b = a.bodies;
          var c = this.nodes;
          for (var d = this.equations; c.length;) {
            this.nodePool.release(c.pop());
          }
          for (var e = 0; e !== b.length; e++) {
            var f = this.nodePool.get();
            f.body = b[e];
            c.push(f);
          }
          for (var g = 0; g !== d.length; g++) {
            var h = d[g];
            var e = b.indexOf(h.bodyA);
            var i = b.indexOf(h.bodyB);
            var k = c[e];
            var l = c[i];
            k.neighbors.push(l);
            l.neighbors.push(k);
            k.equations.push(h);
            l.equations.push(h);
          }
          var m = this.islands;
          for (var e = 0; e < m.length; e++) {
            this.islandPool.release(m[e]);
          }
          m.length = 0;
          for (var n; n = j.getUnvisitedNode(c);) {
            var o = this.islandPool.get();
            this.bfs(n, o.bodies, o.equations);
            m.push(o);
          }
          return m;
        };
      }, {
        "../math/vec2": 30,
        "../objects/Body": 31,
        "./../utils/IslandNodePool": 50,
        "./../utils/IslandPool": 51,
        "./Island": 58,
        "./IslandNode": 60
      }],
      60: [function (a, b, c) {
        function d(a) {
          this.body = a;
          this.neighbors = [];
          this.equations = [];
          this.visited = false;
        }
        b.exports = d;
        d.prototype.reset = function () {
          this.equations.length = 0;
          this.neighbors.length = 0;
          this.visited = false;
          this.body = null;
        };
      }, {}],
      61: [function (a, b, c) {
        function I(a) {
          n.apply(this);
          a = a || {};
          this.springs = [];
          this.bodies = [];
          this.disabledBodyCollisionPairs = [];
          this.solver = a.solver || new d();
          this.narrowphase = new D(this);
          this.islandManager = new G();
          this.gravity = g.fromValues(0, -9.78);
          if (a.gravity) {
            g.copy(this.gravity, a.gravity);
          }
          this.frictionGravity = g.length(this.gravity) || 10;
          this.useWorldGravityAsFrictionGravity = true;
          this.useFrictionGravityOnZeroGravity = true;
          this.broadphase = a.broadphase || new C();
          this.broadphase.setWorld(this);
          this.constraints = [];
          this.defaultMaterial = new r();
          this.defaultContactMaterial = new s(this.defaultMaterial, this.defaultMaterial);
          this.lastTimeStep = 0.016666666666666666;
          this.applySpringForces = true;
          this.applyDamping = true;
          this.applyGravity = true;
          this.solveConstraints = true;
          this.contactMaterials = [];
          this.time = 0;
          this.accumulator = 0;
          this.stepping = false;
          this.bodiesToBeRemoved = [];
          this.islandSplit = undefined === a.islandSplit || !!a.islandSplit;
          this.emitImpactEvent = true;
          this._constraintIdCounter = 0;
          this._bodyIdCounter = 0;
          this.postStepEvent = {
            type: "postStep"
          };
          this.addBodyEvent = {
            type: "addBody",
            body: null
          };
          this.removeBodyEvent = {
            type: "removeBody",
            body: null
          };
          this.addSpringEvent = {
            type: "addSpring",
            spring: null
          };
          this.impactEvent = {
            type: "impact",
            bodyA: null,
            bodyB: null,
            shapeA: null,
            shapeB: null,
            contactEquation: null
          };
          this.postBroadphaseEvent = {
            type: "postBroadphase",
            pairs: null
          };
          this.sleepMode = I.NO_SLEEPING;
          this.beginContactEvent = {
            type: "beginContact",
            shapeA: null,
            shapeB: null,
            bodyA: null,
            bodyB: null,
            contactEquations: []
          };
          this.endContactEvent = {
            type: "endContact",
            shapeA: null,
            shapeB: null,
            bodyA: null,
            bodyB: null
          };
          this.preSolveEvent = {
            type: "preSolve",
            contactEquations: null,
            frictionEquations: null
          };
          this.overlappingShapesLastState = {
            keys: []
          };
          this.overlappingShapesCurrentState = {
            keys: []
          };
          this.overlapKeeper = new F();
        }
        var d = a("../solver/GSSolver");
        a("../solver/Solver");
        a("../collision/Ray");
        var g = a("../math/vec2");
        var h = a("../shapes/Circle");
        var i = a("../shapes/Convex");
        a("../shapes/Line");
        var k = a("../shapes/Plane");
        var l = a("../shapes/Capsule");
        var m = a("../shapes/Particle");
        var n = a("../events/EventEmitter");
        var o = a("../objects/Body");
        a("../shapes/Shape");
        a("../objects/LinearSpring");
        var r = a("../material/Material");
        var s = a("../material/ContactMaterial");
        a("../constraints/DistanceConstraint");
        a("../constraints/Constraint");
        a("../constraints/LockConstraint");
        a("../constraints/RevoluteConstraint");
        a("../constraints/PrismaticConstraint");
        a("../constraints/GearConstraint");
        a("../../package.json");
        a("../collision/Broadphase");
        var B = a("../collision/AABB");
        var C = a("../collision/SAPBroadphase");
        var D = a("../collision/Narrowphase");
        var E = a("../utils/Utils");
        var F = a("../utils/OverlapKeeper");
        var G = a("./IslandManager");
        a("../objects/RotationalSpring");
        b.exports = I;
        I.prototype = new Object(n.prototype);
        I.prototype.constructor = I;
        I.NO_SLEEPING = 1;
        I.BODY_SLEEPING = 2;
        I.ISLAND_SLEEPING = 4;
        I.prototype.addConstraint = function (a) {
          this.constraints.push(a);
        };
        I.prototype.addContactMaterial = function (a) {
          this.contactMaterials.push(a);
        };
        I.prototype.removeContactMaterial = function (a) {
          var b = this.contactMaterials.indexOf(a);
          if (-1 !== b) {
            E.splice(this.contactMaterials, b, 1);
          }
        };
        I.prototype.getContactMaterial = function (a, b) {
          var c = this.contactMaterials;
          var d = 0;
          for (var e = c.length; d !== e; d++) {
            var f = c[d];
            if (f.materialA.id === a.id && f.materialB.id === b.id || f.materialA.id === b.id && f.materialB.id === a.id) {
              return f;
            }
          }
          return false;
        };
        I.prototype.removeConstraint = function (a) {
          var b = this.constraints.indexOf(a);
          if (-1 !== b) {
            E.splice(this.constraints, b, 1);
          }
        };
        g.create();
        g.create();
        g.create();
        g.create();
        g.create();
        g.create();
        var P = g.create();
        var Q = g.fromValues(0, 0);
        var R = g.fromValues(0, 0);
        g.fromValues(0, 0);
        g.fromValues(0, 0);
        I.prototype.step = function (a, b, c) {
          c = c || 10;
          if (0 === (b = b || 0)) {
            this.internalStep(a);
            this.time += a;
          } else {
            this.accumulator += b;
            for (var d = 0; this.accumulator >= a && d < c;) {
              this.internalStep(a);
              this.time += a;
              this.accumulator -= a;
              d++;
            }
            var e = this.accumulator % a / a;
            for (var f = 0; f !== this.bodies.length; f++) {
              var h = this.bodies[f];
              g.lerp(h.interpolatedPosition, h.previousPosition, h.position, e);
              h.interpolatedAngle = h.previousAngle + e * (h.angle - h.previousAngle);
            }
          }
        };
        var U = [];
        I.prototype.internalStep = function (a) {
          this.stepping = true;
          var c = this.springs.length;
          var d = this.springs;
          var e = this.bodies;
          var f = this.gravity;
          var h = this.solver;
          var i = this.bodies.length;
          var j = this.broadphase;
          var k = this.narrowphase;
          var l = this.constraints;
          g.scale;
          var t = g.add;
          g.rotate;
          var v = this.islandManager;
          this.overlapKeeper.tick();
          this.lastTimeStep = a;
          if (this.useWorldGravityAsFrictionGravity) {
            var w = g.length(this.gravity);
            if (!(0 === w && this.useFrictionGravityOnZeroGravity)) {
              this.frictionGravity = w;
            }
          }
          if (this.applyGravity) {
            for (var x = 0; x !== i; x++) {
              var y = e[x];
              var z = y.force;
              if (y.type === o.DYNAMIC && y.sleepState !== o.SLEEPING) {
                g.scale(P, f, y.mass * y.gravityScale);
                t(z, z, P);
              }
            }
          }
          if (this.applySpringForces) {
            for (var x = 0; x !== c; x++) {
              var A = d[x];
              A.applyForce();
            }
          }
          if (this.applyDamping) {
            for (var x = 0; x !== i; x++) {
              var y = e[x];
              if (y.type === o.DYNAMIC) {
                y.applyDamping(a);
              }
            }
          }
          var B = j.getCollisionPairs(this);
          var C = this.disabledBodyCollisionPairs;
          for (var x = C.length - 2; x >= 0; x -= 2) {
            for (var D = B.length - 2; D >= 0; D -= 2) {
              if (C[x] === B[D] && C[x + 1] === B[D + 1] || C[x + 1] === B[D] && C[x] === B[D + 1]) {
                B.splice(D, 2);
              }
            }
          }
          var F = l.length;
          for (x = 0; x !== F; x++) {
            var G = l[x];
            if (!G.collideConnected) {
              for (var D = B.length - 2; D >= 0; D -= 2) {
                if (G.bodyA === B[D] && G.bodyB === B[D + 1] || G.bodyB === B[D] && G.bodyA === B[D + 1]) {
                  B.splice(D, 2);
                }
              }
            }
          }
          this.postBroadphaseEvent.pairs = B;
          this.emit(this.postBroadphaseEvent);
          this.postBroadphaseEvent.pairs = null;
          k.reset(this);
          var x = 0;
          for (var H = B.length; x !== H; x += 2) {
            var J = B[x];
            var K = B[x + 1];
            var L = 0;
            for (var M = J.shapes.length; L !== M; L++) {
              var Q = J.shapes[L];
              var R = Q.position;
              var S = Q.angle;
              var T = 0;
              for (var V = K.shapes.length; T !== V; T++) {
                var W = K.shapes[T];
                var X = W.position;
                var Y = W.angle;
                var Z = this.defaultContactMaterial;
                if (Q.material && W.material) {
                  var $ = this.getContactMaterial(Q.material, W.material);
                  if ($) {
                    Z = $;
                  }
                }
                this.runNarrowphase(k, J, Q, R, S, K, W, X, Y, Z, this.frictionGravity);
              }
            }
          }
          for (var x = 0; x !== i; x++) {
            var _ = e[x];
            if (_._wakeUpAfterNarrowphase) {
              _.wakeUp();
              _._wakeUpAfterNarrowphase = false;
            }
          }
          if (this.has("endContact")) {
            this.overlapKeeper.getEndOverlaps(U);
            var aa = this.endContactEvent;
            for (var T = U.length; T--;) {
              var ba = U[T];
              aa.shapeA = ba.shapeA;
              aa.shapeB = ba.shapeB;
              aa.bodyA = ba.bodyA;
              aa.bodyB = ba.bodyB;
              this.emit(aa);
            }
            U.length = 0;
          }
          var ca = this.preSolveEvent;
          ca.contactEquations = k.contactEquations;
          ca.frictionEquations = k.frictionEquations;
          this.emit(ca);
          ca.contactEquations = ca.frictionEquations = null;
          var F = l.length;
          for (x = 0; x !== F; x++) {
            l[x].update();
          }
          if (k.contactEquations.length || k.frictionEquations.length || F) {
            if (this.islandSplit) {
              v.equations.length = 0;
              E.appendArray(v.equations, k.contactEquations);
              E.appendArray(v.equations, k.frictionEquations);
              for (x = 0; x !== F; x++) {
                E.appendArray(v.equations, l[x].equations);
              }
              v.split(this);
              for (var x = 0; x !== v.islands.length; x++) {
                var da = v.islands[x];
                if (da.equations.length) {
                  h.solveIsland(a, da);
                }
              }
            } else {
              h.addEquations(k.contactEquations);
              h.addEquations(k.frictionEquations);
              for (x = 0; x !== F; x++) {
                h.addEquations(l[x].equations);
              }
              if (this.solveConstraints) {
                h.solve(a, this);
              }
              h.removeAllEquations();
            }
          }
          for (var x = 0; x !== i; x++) {
            var _ = e[x];
            _.integrate(a);
          }
          for (var x = 0; x !== i; x++) {
            e[x].setZeroForce();
          }
          if (this.emitImpactEvent && this.has("impact")) {
            var ea = this.impactEvent;
            for (var x = 0; x !== k.contactEquations.length; x++) {
              var fa = k.contactEquations[x];
              if (fa.firstImpact) {
                ea.bodyA = fa.bodyA;
                ea.bodyB = fa.bodyB;
                ea.shapeA = fa.shapeA;
                ea.shapeB = fa.shapeB;
                ea.contactEquation = fa;
                this.emit(ea);
              }
            }
          }
          if (this.sleepMode === I.BODY_SLEEPING) {
            for (x = 0; x !== i; x++) {
              e[x].sleepTick(this.time, false, a);
            }
          } else if (this.sleepMode === I.ISLAND_SLEEPING && this.islandSplit) {
            for (x = 0; x !== i; x++) {
              e[x].sleepTick(this.time, true, a);
            }
            for (var x = 0; x < this.islandManager.islands.length; x++) {
              var da = this.islandManager.islands[x];
              if (da.wantsToSleep()) {
                da.sleep();
              }
            }
          }
          this.stepping = false;
          var ga = this.bodiesToBeRemoved;
          for (var x = 0; x !== ga.length; x++) {
            this.removeBody(ga[x]);
          }
          ga.length = 0;
          this.emit(this.postStepEvent);
        };
        I.prototype.runNarrowphase = function (a, b, c, d, e, f, h, i, j, k, l) {
          if (0 != (c.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & c.collisionMask)) {
            g.rotate(Q, d, b.angle);
            g.rotate(R, i, f.angle);
            g.add(Q, Q, b.position);
            g.add(R, R, f.position);
            var m = e + b.angle;
            var n = j + f.angle;
            a.enableFriction = k.friction > 0;
            a.frictionCoefficient = k.friction;
            var p;
            p = b.type === o.STATIC || b.type === o.KINEMATIC ? f.mass : f.type === o.STATIC || f.type === o.KINEMATIC ? b.mass : b.mass * f.mass / (b.mass + f.mass);
            a.slipForce = k.friction * l * p;
            a.restitution = k.restitution;
            a.surfaceVelocity = k.surfaceVelocity;
            a.frictionStiffness = k.frictionStiffness;
            a.frictionRelaxation = k.frictionRelaxation;
            a.stiffness = k.stiffness;
            a.relaxation = k.relaxation;
            a.contactSkinSize = k.contactSkinSize;
            a.enabledEquations = b.collisionResponse && f.collisionResponse && c.collisionResponse && h.collisionResponse;
            var q = a[c.type | h.type];
            var r = 0;
            if (q) {
              var s = c.sensor || h.sensor;
              var t = a.frictionEquations.length;
              r = c.type < h.type ? q.call(a, b, c, Q, m, f, h, R, n, s) : q.call(a, f, h, R, n, b, c, Q, m, s);
              var u = a.frictionEquations.length - t;
              if (r) {
                if (b.allowSleep && b.type === o.DYNAMIC && b.sleepState === o.SLEEPING && f.sleepState === o.AWAKE && f.type !== o.STATIC) {
                  if (g.squaredLength(f.velocity) + Math.pow(f.angularVelocity, 2) >= 2 * Math.pow(f.sleepSpeedLimit, 2)) {
                    b._wakeUpAfterNarrowphase = true;
                  }
                }
                if (f.allowSleep && f.type === o.DYNAMIC && f.sleepState === o.SLEEPING && b.sleepState === o.AWAKE && b.type !== o.STATIC) {
                  if (g.squaredLength(b.velocity) + Math.pow(b.angularVelocity, 2) >= 2 * Math.pow(b.sleepSpeedLimit, 2)) {
                    f._wakeUpAfterNarrowphase = true;
                  }
                }
                this.overlapKeeper.setOverlapping(b, c, f, h);
                if (this.has("beginContact") && this.overlapKeeper.isNewOverlap(c, h)) {
                  var z = this.beginContactEvent;
                  z.shapeA = c;
                  z.shapeB = h;
                  z.bodyA = b;
                  z.bodyB = f;
                  z.contactEquations.length = 0;
                  if ("number" == typeof r) {
                    for (var A = a.contactEquations.length - r; A < a.contactEquations.length; A++) {
                      z.contactEquations.push(a.contactEquations[A]);
                    }
                  }
                  this.emit(z);
                }
                if ("number" == typeof r && u > 1) {
                  for (var A = a.frictionEquations.length - u; A < a.frictionEquations.length; A++) {
                    var B = a.frictionEquations[A];
                    B.setSlipForce(B.getSlipForce() / u);
                  }
                }
              }
            }
          }
        };
        I.prototype.addSpring = function (a) {
          this.springs.push(a);
          var b = this.addSpringEvent;
          b.spring = a;
          this.emit(b);
          b.spring = null;
        };
        I.prototype.removeSpring = function (a) {
          var b = this.springs.indexOf(a);
          if (-1 !== b) {
            E.splice(this.springs, b, 1);
          }
        };
        I.prototype.addBody = function (a) {
          if (-1 === this.bodies.indexOf(a)) {
            this.bodies.push(a);
            a.world = this;
            var b = this.addBodyEvent;
            b.body = a;
            this.emit(b);
            b.body = null;
          }
        };
        I.prototype.removeBody = function (a) {
          if (this.stepping) {
            this.bodiesToBeRemoved.push(a);
          } else {
            a.world = null;
            var b = this.bodies.indexOf(a);
            if (-1 !== b) {
              E.splice(this.bodies, b, 1);
              this.removeBodyEvent.body = a;
              a.resetConstraintVelocity();
              this.emit(this.removeBodyEvent);
              this.removeBodyEvent.body = null;
            }
          }
        };
        I.prototype.getBodyById = function (a) {
          var b = this.bodies;
          for (var c = 0; c < b.length; c++) {
            var d = b[c];
            if (d.id === a) {
              return d;
            }
          }
          return false;
        };
        I.prototype.disableBodyCollision = function (a, b) {
          this.disabledBodyCollisionPairs.push(a, b);
        };
        I.prototype.enableBodyCollision = function (a, b) {
          var c = this.disabledBodyCollisionPairs;
          for (var d = 0; d < c.length; d += 2) {
            if (c[d] === a && c[d + 1] === b || c[d + 1] === a && c[d] === b) {
              return void c.splice(d, 2);
            }
          }
        };
        I.prototype.clear = function () {
          this.time = 0;
          if (this.solver && this.solver.equations.length) {
            this.solver.removeAllEquations();
          }
          var a = this.constraints;
          for (var b = a.length - 1; b >= 0; b--) {
            this.removeConstraint(a[b]);
          }
          var c = this.bodies;
          for (var b = c.length - 1; b >= 0; b--) {
            this.removeBody(c[b]);
          }
          var d = this.springs;
          for (var b = d.length - 1; b >= 0; b--) {
            this.removeSpring(d[b]);
          }
          var e = this.contactMaterials;
          for (var b = e.length - 1; b >= 0; b--) {
            this.removeContactMaterial(e[b]);
          }
          I.apply(this);
        };
        var V = g.create();
        g.fromValues(0, 0);
        var X = g.fromValues(0, 0);
        I.prototype.hitTest = function (a, b, c) {
          c = c || 0;
          var d = new o({
            position: a
          });
          var e = new m();
          d.addShape(e);
          var r = this.narrowphase;
          var s = [];
          var t = 0;
          for (var u = b.length; t !== u; t++) {
            var v = b[t];
            var w = 0;
            for (var x = v.shapes.length; w !== x; w++) {
              var y = v.shapes[w];
              g.rotate(V, y.position, v.angle);
              g.add(V, V, v.position);
              var z = y.angle + v.angle;
              if (y instanceof h && r.circleParticle(v, y, V, z, d, e, a, 0, true) || y instanceof i && r.particleConvex(d, e, a, 0, v, y, V, z, true) || y instanceof k && r.particlePlane(d, e, a, 0, v, y, V, z, true) || y instanceof l && r.particleCapsule(d, e, a, 0, v, y, V, z, true) || y instanceof m && g.squaredLength(g.sub(X, V, a)) < c * c) {
                s.push(v);
              }
            }
          }
          return s;
        };
        I.prototype.setGlobalStiffness = function (a) {
          var b = this.constraints;
          for (var c = 0; c !== b.length; c++) {
            var d = b[c];
            for (var e = 0; e !== d.equations.length; e++) {
              var f = d.equations[e];
              f.stiffness = a;
              f.needsUpdate = true;
            }
          }
          var g = this.contactMaterials;
          for (var c = 0; c !== g.length; c++) {
            var d = g[c];
            d.stiffness = d.frictionStiffness = a;
          }
          var d = this.defaultContactMaterial;
          d.stiffness = d.frictionStiffness = a;
        };
        I.prototype.setGlobalRelaxation = function (a) {
          for (var b = 0; b !== this.constraints.length; b++) {
            var c = this.constraints[b];
            for (var d = 0; d !== c.equations.length; d++) {
              var e = c.equations[d];
              e.relaxation = a;
              e.needsUpdate = true;
            }
          }
          for (var b = 0; b !== this.contactMaterials.length; b++) {
            var c = this.contactMaterials[b];
            c.relaxation = c.frictionRelaxation = a;
          }
          var c = this.defaultContactMaterial;
          c.relaxation = c.frictionRelaxation = a;
        };
        var Y = new B();
        var Z = [];
        I.prototype.raycast = function (a, b) {
          b.getAABB(Y);
          this.broadphase.aabbQuery(this, Y, Z);
          b.intersectBodies(a, Z);
          Z.length = 0;
          return a.hasHit();
        };
      }, {
        "../../package.json": 6,
        "../collision/AABB": 7,
        "../collision/Broadphase": 8,
        "../collision/Narrowphase": 10,
        "../collision/Ray": 11,
        "../collision/SAPBroadphase": 13,
        "../constraints/Constraint": 14,
        "../constraints/DistanceConstraint": 15,
        "../constraints/GearConstraint": 16,
        "../constraints/LockConstraint": 17,
        "../constraints/PrismaticConstraint": 18,
        "../constraints/RevoluteConstraint": 19,
        "../events/EventEmitter": 26,
        "../material/ContactMaterial": 27,
        "../material/Material": 28,
        "../math/vec2": 30,
        "../objects/Body": 31,
        "../objects/LinearSpring": 32,
        "../objects/RotationalSpring": 33,
        "../shapes/Capsule": 38,
        "../shapes/Circle": 39,
        "../shapes/Convex": 40,
        "../shapes/Line": 42,
        "../shapes/Particle": 43,
        "../shapes/Plane": 44,
        "../shapes/Shape": 45,
        "../solver/GSSolver": 46,
        "../solver/Solver": 47,
        "../utils/OverlapKeeper": 52,
        "../utils/Utils": 57,
        "./IslandManager": 59
      }]
    }, {}, [36])(36);
  });
  (function () {
    var a = this;
    var b = b || {};
    b.game = null;
    b.WEBGL_RENDERER = 0;
    b.CANVAS_RENDERER = 1;
    b.VERSION = "v2.2.9";
    b._UID = 0;
    if ("undefined" != typeof Float32Array) {
      b.Float32Array = Float32Array;
      b.Uint16Array = Uint16Array;
      b.Uint32Array = Uint32Array;
      b.ArrayBuffer = ArrayBuffer;
    } else {
      b.Float32Array = Array;
      b.Uint16Array = Array;
    }
    b.PI_2 = 2 * Math.PI;
    b.RAD_TO_DEG = 180 / Math.PI;
    b.DEG_TO_RAD = Math.PI / 180;
    b.RETINA_PREFIX = "@2x";
    b.DisplayObject = function () {
      this.position = new b.Point(0, 0);
      this.scale = new b.Point(1, 1);
      this.pivot = new b.Point(0, 0);
      this.rotation = 0;
      this.alpha = 1;
      this.visible = true;
      this.hitArea = null;
      this.renderable = false;
      this.parent = null;
      this.worldAlpha = 1;
      this.worldTransform = new b.Matrix();
      this.worldPosition = new b.Point(0, 0);
      this.worldScale = new b.Point(1, 1);
      this.worldRotation = 0;
      this.filterArea = null;
      this._sr = 0;
      this._cr = 1;
      this._bounds = new b.Rectangle(0, 0, 0, 0);
      this._currentBounds = null;
      this._mask = null;
      this._cacheAsBitmap = false;
      this._cacheIsDirty = false;
    };
    b.DisplayObject.prototype.constructor = b.DisplayObject;
    b.DisplayObject.prototype = {
      destroy: function () {
        if (this.children) {
          for (var a = this.children.length; a--;) {
            this.children[a].destroy();
          }
          this.children = [];
        }
        this.hitArea = null;
        this.parent = null;
        this.worldTransform = null;
        this.filterArea = null;
        this.renderable = false;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this._destroyCachedSprite();
      },
      updateTransform: function (a) {
        if (!a && !this.parent && !this.game) {
          return this;
        }
        var c = this.parent;
        if (a) {
          c = a;
        } else if (!this.parent) {
          c = this.game.world;
        }
        var f;
        var g;
        var h;
        var i;
        var j;
        var k;
        var d = c.worldTransform;
        var e = this.worldTransform;
        if (this.rotation % b.PI_2) {
          if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation);
          }
          f = this._cr * this.scale.x;
          g = this._sr * this.scale.x;
          h = -this._sr * this.scale.y;
          i = this._cr * this.scale.y;
          j = this.position.x;
          k = this.position.y;
          if (this.pivot.x || this.pivot.y) {
            j -= this.pivot.x * f + this.pivot.y * h;
            k -= this.pivot.x * g + this.pivot.y * i;
          }
          e.a = f * d.a + g * d.c;
          e.b = f * d.b + g * d.d;
          e.c = h * d.a + i * d.c;
          e.d = h * d.b + i * d.d;
          e.tx = j * d.a + k * d.c + d.tx;
          e.ty = j * d.b + k * d.d + d.ty;
        } else {
          f = this.scale.x;
          i = this.scale.y;
          j = this.position.x - this.pivot.x * f;
          k = this.position.y - this.pivot.y * i;
          e.a = f * d.a;
          e.b = f * d.b;
          e.c = i * d.c;
          e.d = i * d.d;
          e.tx = j * d.a + k * d.c + d.tx;
          e.ty = j * d.b + k * d.d + d.ty;
        }
        this.worldAlpha = this.alpha * c.worldAlpha;
        this.worldPosition.set(e.tx, e.ty);
        this.worldScale.set(this.scale.x * Math.sqrt(e.a * e.a + e.c * e.c), this.scale.y * Math.sqrt(e.b * e.b + e.d * e.d));
        this.worldRotation = Math.atan2(-e.c, e.d);
        this._currentBounds = null;
        if (this.transformCallback) {
          this.transformCallback.call(this.transformCallbackContext, e, d);
        }
        return this;
      },
      preUpdate: function () {},
      generateTexture: function (a, c, d) {
        var e = this.getLocalBounds();
        var f = new b.RenderTexture(0 | e.width, 0 | e.height, d, c, a);
        b.DisplayObject._tempMatrix.tx = -e.x;
        b.DisplayObject._tempMatrix.ty = -e.y;
        f.render(this, b.DisplayObject._tempMatrix);
        return f;
      },
      updateCache: function () {
        this._generateCachedSprite();
        return this;
      },
      toGlobal: function (a) {
        this.updateTransform();
        return this.worldTransform.apply(a);
      },
      toLocal: function (a, b) {
        if (b) {
          a = b.toGlobal(a);
        }
        this.updateTransform();
        return this.worldTransform.applyInverse(a);
      },
      _renderCachedSprite: function (a) {
        this._cachedSprite.worldAlpha = this.worldAlpha;
        if (a.gl) {
          b.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
        } else {
          b.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
        }
      },
      _generateCachedSprite: function () {
        this._cacheAsBitmap = false;
        var a = this.getLocalBounds();
        a.width = Math.max(1, Math.ceil(a.width));
        a.height = Math.max(1, Math.ceil(a.height));
        this.updateTransform();
        if (this._cachedSprite) {
          this._cachedSprite.texture.resize(a.width, a.height);
        } else {
          var c = new b.RenderTexture(a.width, a.height);
          this._cachedSprite = new b.Sprite(c);
          this._cachedSprite.worldTransform = this.worldTransform;
        }
        var d = this._filters;
        this._filters = null;
        this._cachedSprite.filters = d;
        b.DisplayObject._tempMatrix.tx = -a.x;
        b.DisplayObject._tempMatrix.ty = -a.y;
        this._cachedSprite.texture.render(this, b.DisplayObject._tempMatrix, true);
        this._cachedSprite.anchor.x = -a.x / a.width;
        this._cachedSprite.anchor.y = -a.y / a.height;
        this._filters = d;
        this._cacheAsBitmap = true;
      },
      _destroyCachedSprite: function () {
        if (this._cachedSprite) {
          this._cachedSprite.texture.destroy(true);
          this._cachedSprite = null;
        }
      }
    };
    b.DisplayObject.prototype.displayObjectUpdateTransform = b.DisplayObject.prototype.updateTransform;
    Object.defineProperties(b.DisplayObject.prototype, {
      x: {
        get: function () {
          return this.position.x;
        },
        set: function (a) {
          this.position.x = a;
        }
      },
      y: {
        get: function () {
          return this.position.y;
        },
        set: function (a) {
          this.position.y = a;
        }
      },
      worldVisible: {
        get: function () {
          if (this.visible) {
            var a = this.parent;
            if (!a) {
              return this.visible;
            }
            do {
              if (!a.visible) {
                return false;
              }
              a = a.parent;
            } while (a);
            return true;
          }
          return false;
        }
      },
      mask: {
        get: function () {
          return this._mask;
        },
        set: function (a) {
          if (this._mask) {
            this._mask.isMask = false;
          }
          this._mask = a;
          if (a) {
            this._mask.isMask = true;
          }
        }
      },
      filters: {
        get: function () {
          return this._filters;
        },
        set: function (a) {
          if (Array.isArray(a)) {
            var c = [];
            for (var d = 0; d < a.length; d++) {
              var e = a[d].passes;
              for (var f = 0; f < e.length; f++) {
                c.push(e[f]);
              }
            }
            this._filterBlock = {
              target: this,
              filterPasses: c
            };
          }
          this._filters = a;
          if (this.blendMode && this.blendMode === b.blendModes.MULTIPLY) {
            this.blendMode = b.blendModes.NORMAL;
          }
        }
      },
      cacheAsBitmap: {
        get: function () {
          return this._cacheAsBitmap;
        },
        set: function (a) {
          if (this._cacheAsBitmap !== a) {
            if (a) {
              this._generateCachedSprite();
            } else {
              this._destroyCachedSprite();
            }
            this._cacheAsBitmap = a;
          }
        }
      }
    });
    b.DisplayObjectContainer = function () {
      b.DisplayObject.call(this);
      this.children = [];
      this.ignoreChildInput = false;
    };
    b.DisplayObjectContainer.prototype = Object.create(b.DisplayObject.prototype);
    b.DisplayObjectContainer.prototype.constructor = b.DisplayObjectContainer;
    b.DisplayObjectContainer.prototype.addChild = function (a) {
      return this.addChildAt(a, this.children.length);
    };
    b.DisplayObjectContainer.prototype.addChildAt = function (a, b) {
      if (b >= 0 && b <= this.children.length) {
        if (a.parent) {
          a.parent.removeChild(a);
        }
        a.parent = this;
        this.children.splice(b, 0, a);
        return a;
      }
      throw new Error(a + "addChildAt: The index " + b + " supplied is out of bounds " + this.children.length);
    };
    b.DisplayObjectContainer.prototype.swapChildren = function (a, b) {
      if (a !== b) {
        var c = this.getChildIndex(a);
        var d = this.getChildIndex(b);
        if (c < 0 || d < 0) {
          throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
        }
        this.children[c] = b;
        this.children[d] = a;
      }
    };
    b.DisplayObjectContainer.prototype.getChildIndex = function (a) {
      var b = this.children.indexOf(a);
      if (-1 === b) {
        throw new Error("The supplied DisplayObject must be a child of the caller");
      }
      return b;
    };
    b.DisplayObjectContainer.prototype.setChildIndex = function (a, b) {
      if (b < 0 || b >= this.children.length) {
        throw new Error("The supplied index is out of bounds");
      }
      var c = this.getChildIndex(a);
      this.children.splice(c, 1);
      this.children.splice(b, 0, a);
    };
    b.DisplayObjectContainer.prototype.getChildAt = function (a) {
      if (a < 0 || a >= this.children.length) {
        throw new Error("getChildAt: Supplied index " + a + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
      }
      return this.children[a];
    };
    b.DisplayObjectContainer.prototype.removeChild = function (a) {
      var b = this.children.indexOf(a);
      if (-1 !== b) {
        return this.removeChildAt(b);
      }
    };
    b.DisplayObjectContainer.prototype.removeChildAt = function (a) {
      var b = this.getChildAt(a);
      if (b) {
        b.parent = undefined;
        this.children.splice(a, 1);
      }
      return b;
    };
    b.DisplayObjectContainer.prototype.removeChildren = function (a, b) {
      if (undefined === a) {
        a = 0;
      }
      if (undefined === b) {
        b = this.children.length;
      }
      var c = b - a;
      if (c > 0 && c <= b) {
        var d = this.children.splice(begin, c);
        for (var e = 0; e < d.length; e++) {
          d[e].parent = undefined;
        }
        return d;
      }
      if (0 === c && 0 === this.children.length) {
        return [];
      }
      throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
    };
    b.DisplayObjectContainer.prototype.updateTransform = function () {
      if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) {
        for (var a = 0; a < this.children.length; a++) {
          this.children[a].updateTransform();
        }
      }
    };
    b.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = b.DisplayObjectContainer.prototype.updateTransform;
    b.DisplayObjectContainer.prototype.getBounds = function (a) {
      var c = a && a instanceof b.DisplayObject;
      var d = true;
      if (c) {
        d = a instanceof b.DisplayObjectContainer && a.contains(this);
      } else {
        a = this;
      }
      var e;
      if (c) {
        var f = a.worldTransform;
        a.worldTransform = b.identityMatrix;
        for (e = 0; e < a.children.length; e++) {
          a.children[e].updateTransform();
        }
      }
      var k;
      var l;
      var m;
      var g = Infinity;
      var h = Infinity;
      var i = -Infinity;
      var j = -Infinity;
      var n = false;
      for (e = 0; e < this.children.length; e++) {
        if (this.children[e].visible) {
          n = true;
          k = this.children[e].getBounds();
          g = g < k.x ? g : k.x;
          h = h < k.y ? h : k.y;
          l = k.width + k.x;
          m = k.height + k.y;
          i = i > l ? i : l;
          j = j > m ? j : m;
        }
      }
      var p = this._bounds;
      if (!n) {
        p = new b.Rectangle();
        var q = p.x;
        var r = p.width + p.x;
        var s = p.y;
        var t = p.height + p.y;
        var u = this.worldTransform;
        var v = u.a;
        var w = u.b;
        var x = u.c;
        var y = u.d;
        var z = u.tx;
        var A = u.ty;
        var B = v * r + x * t + z;
        var C = y * t + w * r + A;
        var D = v * q + x * t + z;
        var E = y * t + w * q + A;
        var F = v * q + x * s + z;
        var G = y * s + w * q + A;
        var H = v * r + x * s + z;
        var I = y * s + w * r + A;
        i = B;
        j = C;
        g = B;
        h = C;
        g = D < g ? D : g;
        g = F < g ? F : g;
        g = H < g ? H : g;
        h = E < h ? E : h;
        h = G < h ? G : h;
        h = I < h ? I : h;
        i = D > i ? D : i;
        i = F > i ? F : i;
        i = H > i ? H : i;
        j = E > j ? E : j;
        j = G > j ? G : j;
        j = I > j ? I : j;
      }
      p.x = g;
      p.y = h;
      p.width = i - g;
      p.height = j - h;
      if (c) {
        a.worldTransform = f;
        for (e = 0; e < a.children.length; e++) {
          a.children[e].updateTransform();
        }
      }
      if (!d) {
        var J = a.getBounds();
        p.x -= J.x;
        p.y -= J.y;
      }
      return p;
    };
    b.DisplayObjectContainer.prototype.getLocalBounds = function () {
      return this.getBounds(this);
    };
    b.DisplayObjectContainer.prototype.contains = function (a) {
      return !!a && (a === this || this.contains(a.parent));
    };
    b.DisplayObjectContainer.prototype._renderWebGL = function (a) {
      if (this.visible && !(this.alpha <= 0)) {
        if (this._cacheAsBitmap) {
          return void this._renderCachedSprite(a);
        }
        var b;
        if (this._mask || this._filters) {
          if (this._filters) {
            a.spriteBatch.flush();
            a.filterManager.pushFilter(this._filterBlock);
          }
          if (this._mask) {
            a.spriteBatch.stop();
            a.maskManager.pushMask(this.mask, a);
            a.spriteBatch.start();
          }
          for (b = 0; b < this.children.length; b++) {
            this.children[b]._renderWebGL(a);
          }
          a.spriteBatch.stop();
          if (this._mask) {
            a.maskManager.popMask(this._mask, a);
          }
          if (this._filters) {
            a.filterManager.popFilter();
          }
          a.spriteBatch.start();
        } else {
          for (b = 0; b < this.children.length; b++) {
            this.children[b]._renderWebGL(a);
          }
        }
      }
    };
    b.DisplayObjectContainer.prototype._renderCanvas = function (a) {
      if (false !== this.visible && 0 !== this.alpha) {
        if (this._cacheAsBitmap) {
          return void this._renderCachedSprite(a);
        }
        if (this._mask) {
          a.maskManager.pushMask(this._mask, a);
        }
        for (var b = 0; b < this.children.length; b++) {
          this.children[b]._renderCanvas(a);
        }
        if (this._mask) {
          a.maskManager.popMask(a);
        }
      }
    };
    Object.defineProperty(b.DisplayObjectContainer.prototype, "width", {
      get: function () {
        return this.getLocalBounds().width * this.scale.x;
      },
      set: function (a) {
        var b = this.getLocalBounds().width;
        this.scale.x = 0 !== b ? a / b : 1;
        this._width = a;
      }
    });
    Object.defineProperty(b.DisplayObjectContainer.prototype, "height", {
      get: function () {
        return this.getLocalBounds().height * this.scale.y;
      },
      set: function (a) {
        var b = this.getLocalBounds().height;
        this.scale.y = 0 !== b ? a / b : 1;
        this._height = a;
      }
    });
    b.Sprite = function (a) {
      b.DisplayObjectContainer.call(this);
      this.anchor = new b.Point();
      this.texture = a || b.Texture.emptyTexture;
      this._width = 0;
      this._height = 0;
      this.tint = 16777215;
      this.cachedTint = -1;
      this.tintedTexture = null;
      this.blendMode = b.blendModes.NORMAL;
      this.shader = null;
      this.exists = true;
      if (this.texture.baseTexture.hasLoaded) {
        this.onTextureUpdate();
      }
      this.renderable = true;
    };
    b.Sprite.prototype = Object.create(b.DisplayObjectContainer.prototype);
    b.Sprite.prototype.constructor = b.Sprite;
    Object.defineProperty(b.Sprite.prototype, "width", {
      get: function () {
        return this.scale.x * this.texture.frame.width;
      },
      set: function (a) {
        this.scale.x = a / this.texture.frame.width;
        this._width = a;
      }
    });
    Object.defineProperty(b.Sprite.prototype, "height", {
      get: function () {
        return this.scale.y * this.texture.frame.height;
      },
      set: function (a) {
        this.scale.y = a / this.texture.frame.height;
        this._height = a;
      }
    });
    b.Sprite.prototype.setTexture = function (a, b) {
      if (undefined !== b) {
        this.texture.baseTexture.destroy();
      }
      this.texture.baseTexture.skipRender = false;
      this.texture = a;
      this.texture.valid = true;
      this.cachedTint = -1;
    };
    b.Sprite.prototype.onTextureUpdate = function () {
      if (this._width) {
        this.scale.x = this._width / this.texture.frame.width;
      }
      if (this._height) {
        this.scale.y = this._height / this.texture.frame.height;
      }
    };
    b.Sprite.prototype.getBounds = function (a) {
      var b = this.texture.frame.width;
      var c = this.texture.frame.height;
      var d = b * (1 - this.anchor.x);
      var e = b * -this.anchor.x;
      var f = c * (1 - this.anchor.y);
      var g = c * -this.anchor.y;
      var h = a || this.worldTransform;
      var i = h.a;
      var j = h.b;
      var k = h.c;
      var l = h.d;
      var m = h.tx;
      var n = h.ty;
      var o = -Infinity;
      var p = -Infinity;
      var q = Infinity;
      var r = Infinity;
      if (0 === j && 0 === k) {
        if (i < 0) {
          i *= -1;
          var s = d;
          d = -e;
          e = -s;
        }
        if (l < 0) {
          l *= -1;
          var s = f;
          f = -g;
          g = -s;
        }
        q = i * e + m;
        o = i * d + m;
        r = l * g + n;
        p = l * f + n;
      } else {
        var t = i * e + k * g + m;
        var u = l * g + j * e + n;
        var v = i * d + k * g + m;
        var w = l * g + j * d + n;
        var x = i * d + k * f + m;
        var y = l * f + j * d + n;
        var z = i * e + k * f + m;
        var A = l * f + j * e + n;
        q = t < q ? t : q;
        q = v < q ? v : q;
        q = x < q ? x : q;
        q = z < q ? z : q;
        r = u < r ? u : r;
        r = w < r ? w : r;
        r = y < r ? y : r;
        r = A < r ? A : r;
        o = t > o ? t : o;
        o = v > o ? v : o;
        o = x > o ? x : o;
        o = z > o ? z : o;
        p = u > p ? u : p;
        p = w > p ? w : p;
        p = y > p ? y : p;
        p = A > p ? A : p;
      }
      var B = this._bounds;
      B.x = q;
      B.width = o - q;
      B.y = r;
      B.height = p - r;
      this._currentBounds = B;
      return B;
    };
    b.Sprite.prototype.getLocalBounds = function () {
      var a = this.worldTransform;
      this.worldTransform = b.identityMatrix;
      for (var c = 0; c < this.children.length; c++) {
        this.children[c].updateTransform();
      }
      var d = this.getBounds();
      this.worldTransform = a;
      for (c = 0; c < this.children.length; c++) {
        this.children[c].updateTransform();
      }
      return d;
    };
    b.Sprite.prototype._renderWebGL = function (a, b) {
      if (this.visible && !(this.alpha <= 0) && this.renderable) {
        var c = this.worldTransform;
        if (b) {
          c = b;
        }
        if (this._mask || this._filters) {
          var d = a.spriteBatch;
          if (this._filters) {
            d.flush();
            a.filterManager.pushFilter(this._filterBlock);
          }
          if (this._mask) {
            d.stop();
            a.maskManager.pushMask(this.mask, a);
            d.start();
          }
          d.render(this);
          for (var e = 0; e < this.children.length; e++) {
            this.children[e]._renderWebGL(a);
          }
          d.stop();
          if (this._mask) {
            a.maskManager.popMask(this._mask, a);
          }
          if (this._filters) {
            a.filterManager.popFilter();
          }
          d.start();
        } else {
          a.spriteBatch.render(this);
          for (var e = 0; e < this.children.length; e++) {
            this.children[e]._renderWebGL(a, c);
          }
        }
      }
    };
    b.Sprite.prototype._renderCanvas = function (a, c) {
      if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
        var d = this.worldTransform;
        if (c) {
          d = c;
        }
        if (this.blendMode !== a.currentBlendMode) {
          a.currentBlendMode = this.blendMode;
          a.context.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode];
        }
        if (this._mask) {
          a.maskManager.pushMask(this._mask, a);
        }
        if (this.texture.valid) {
          var e = this.texture.baseTexture.resolution / a.resolution;
          a.context.globalAlpha = this.worldAlpha;
          if (a.smoothProperty && a.scaleMode !== this.texture.baseTexture.scaleMode) {
            a.scaleMode = this.texture.baseTexture.scaleMode;
            a.context[a.smoothProperty] = a.scaleMode === b.scaleModes.LINEAR;
          }
          var f = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;
          var g = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
          var h = d.tx * a.resolution + a.shakeX;
          var i = d.ty * a.resolution + a.shakeY;
          if (a.roundPixels) {
            a.context.setTransform(d.a, d.b, d.c, d.d, 0 | h, 0 | i);
            f |= 0;
            g |= 0;
          } else {
            a.context.setTransform(d.a, d.b, d.c, d.d, h, i);
          }
          var j = this.texture.crop.width;
          var k = this.texture.crop.height;
          f /= e;
          g /= e;
          if (16777215 !== this.tint) {
            if (this.texture.requiresReTint || this.cachedTint !== this.tint) {
              this.tintedTexture = b.CanvasTinter.getTintedTexture(this, this.tint);
              this.cachedTint = this.tint;
              this.texture.requiresReTint = false;
            }
            a.context.drawImage(this.tintedTexture, 0, 0, j, k, f, g, j / e, k / e);
          } else {
            var l = this.texture.crop.x;
            var m = this.texture.crop.y;
            a.context.drawImage(this.texture.baseTexture.source, l, m, j, k, f, g, j / e, k / e);
          }
        }
        for (var n = 0; n < this.children.length; n++) {
          this.children[n]._renderCanvas(a);
        }
        if (this._mask) {
          a.maskManager.popMask(a);
        }
      }
    };
    b.SpriteBatch = function (a) {
      b.DisplayObjectContainer.call(this);
      this.textureThing = a;
      this.ready = false;
    };
    b.SpriteBatch.prototype = Object.create(b.DisplayObjectContainer.prototype);
    b.SpriteBatch.prototype.constructor = b.SpriteBatch;
    b.SpriteBatch.prototype.initWebGL = function (a) {
      this.fastSpriteBatch = new b.WebGLFastSpriteBatch(a);
      this.ready = true;
    };
    b.SpriteBatch.prototype.updateTransform = function () {
      this.displayObjectUpdateTransform();
    };
    b.SpriteBatch.prototype._renderWebGL = function (a) {
      if (!(!this.visible || this.alpha <= 0 || !this.children.length)) {
        if (!this.ready) {
          this.initWebGL(a.gl);
        }
        if (this.fastSpriteBatch.gl !== a.gl) {
          this.fastSpriteBatch.setContext(a.gl);
        }
        a.spriteBatch.stop();
        a.shaderManager.setShader(a.shaderManager.fastShader);
        this.fastSpriteBatch.begin(this, a);
        this.fastSpriteBatch.render(this);
        a.spriteBatch.start();
      }
    };
    b.SpriteBatch.prototype._renderCanvas = function (a) {
      if (this.visible && !(this.alpha <= 0) && this.children.length) {
        var b = a.context;
        b.globalAlpha = this.worldAlpha;
        this.displayObjectUpdateTransform();
        var c = this.worldTransform;
        var d = true;
        for (var e = 0; e < this.children.length; e++) {
          var f = this.children[e];
          if (f.visible) {
            var g = f.texture;
            var h = g.frame;
            b.globalAlpha = this.worldAlpha * f.alpha;
            if (f.rotation % (2 * Math.PI) == 0) {
              if (d) {
                b.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty);
                d = false;
              }
              b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * (-h.width * f.scale.x) + f.position.x + .5 + a.shakeX | 0, f.anchor.y * (-h.height * f.scale.y) + f.position.y + .5 + a.shakeY | 0, h.width * f.scale.x, h.height * f.scale.y);
            } else {
              if (!d) {
                d = true;
              }
              f.displayObjectUpdateTransform();
              var i = f.worldTransform;
              var j = i.tx * a.resolution + a.shakeX;
              var k = i.ty * a.resolution + a.shakeY;
              if (a.roundPixels) {
                b.setTransform(i.a, i.b, i.c, i.d, 0 | j, 0 | k);
              } else {
                b.setTransform(i.a, i.b, i.c, i.d, j, k);
              }
              b.drawImage(g.baseTexture.source, h.x, h.y, h.width, h.height, f.anchor.x * -h.width + .5 | 0, f.anchor.y * -h.height + .5 | 0, h.width, h.height);
            }
          }
        }
      }
    };
    b.hex2rgb = function (a) {
      return [(a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255];
    };
    b.rgb2hex = function (a) {
      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    };
    b.canUseNewCanvasBlendModes = function () {
      if (undefined === document) {
        return false;
      }
      var d = new Image();
      d.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/AP804Oa6AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
      var e = new Image();
      e.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX//wCKxvRFAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==";
      var f = b.CanvasPool.create(this, 6, 1);
      var g = f.getContext("2d");
      g.globalCompositeOperation = "multiply";
      g.drawImage(d, 0, 0);
      g.drawImage(e, 2, 0);
      if (!g.getImageData(2, 0, 1, 1)) {
        return false;
      }
      var h = g.getImageData(2, 0, 1, 1).data;
      b.CanvasPool.remove(this);
      return 255 === h[0] && 0 === h[1] && 0 === h[2];
    };
    b.getNextPowerOfTwo = function (a) {
      if (a > 0 && 0 == (a & a - 1)) {
        return a;
      }
      for (var b = 1; b < a;) {
        b <<= 1;
      }
      return b;
    };
    b.isPowerOfTwo = function (a, b) {
      return a > 0 && 0 == (a & a - 1) && b > 0 && 0 == (b & b - 1);
    };
    b.CanvasPool = {
      create: function (a, c, d) {
        var f;
        var e = b.CanvasPool.getFirst();
        if (-1 === e) {
          var g = {
            parent: a,
            canvas: document.createElement("canvas")
          };
          b.CanvasPool.pool.push(g);
          f = g.canvas;
        } else {
          b.CanvasPool.pool[e].parent = a;
          f = b.CanvasPool.pool[e].canvas;
        }
        if (undefined !== c) {
          f.width = c;
          f.height = d;
        }
        return f;
      },
      getFirst: function () {
        var a = b.CanvasPool.pool;
        for (var c = 0; c < a.length; c++) {
          if (!a[c].parent) {
            return c;
          }
        }
        return -1;
      },
      remove: function (a) {
        var c = b.CanvasPool.pool;
        for (var d = 0; d < c.length; d++) {
          if (c[d].parent === a) {
            c[d].parent = null;
            c[d].canvas.width = 1;
            c[d].canvas.height = 1;
          }
        }
      },
      removeByCanvas: function (a) {
        var c = b.CanvasPool.pool;
        for (var d = 0; d < c.length; d++) {
          if (c[d].canvas === a) {
            c[d].parent = null;
            c[d].canvas.width = 1;
            c[d].canvas.height = 1;
          }
        }
      },
      getTotal: function () {
        var a = b.CanvasPool.pool;
        var c = 0;
        for (var d = 0; d < a.length; d++) {
          if (a[d].parent) {
            c++;
          }
        }
        return c;
      },
      getFree: function () {
        var a = b.CanvasPool.pool;
        var c = 0;
        for (var d = 0; d < a.length; d++) {
          if (!a[d].parent) {
            c++;
          }
        }
        return c;
      }
    };
    b.CanvasPool.pool = [];
    b.initDefaultShaders = function () {};
    b.CompileVertexShader = function (a, c) {
      return b._CompileShader(a, c, a.VERTEX_SHADER);
    };
    b.CompileFragmentShader = function (a, c) {
      return b._CompileShader(a, c, a.FRAGMENT_SHADER);
    };
    b._CompileShader = function (a, b, c) {
      var d = b;
      if (Array.isArray(b)) {
        d = b.join("\n");
      }
      var e = a.createShader(c);
      a.shaderSource(e, d);
      a.compileShader(e);
      return a.getShaderParameter(e, a.COMPILE_STATUS) ? e : (window.console.log(a.getShaderInfoLog(e)), null);
    };
    b.compileProgram = function (a, c, d) {
      var e = b.CompileFragmentShader(a, d);
      var f = b.CompileVertexShader(a, c);
      var g = a.createProgram();
      a.attachShader(g, f);
      a.attachShader(g, e);
      a.linkProgram(g);
      if (!a.getProgramParameter(g, a.LINK_STATUS)) {
        window.console.log(a.getProgramInfoLog(g));
        window.console.log("Could not initialise shaders");
      }
      return g;
    };
    b.PixiShader = function (a) {
      this._UID = b._UID++;
      this.gl = a;
      this.program = null;
      this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
      this.textureCount = 0;
      this.firstRun = true;
      this.dirty = true;
      this.attributes = [];
      this.init();
    };
    b.PixiShader.prototype.constructor = b.PixiShader;
    b.PixiShader.prototype.init = function () {
      var a = this.gl;
      var c = b.compileProgram(a, this.vertexSrc || b.PixiShader.defaultVertexSrc, this.fragmentSrc);
      a.useProgram(c);
      this.uSampler = a.getUniformLocation(c, "uSampler");
      this.projectionVector = a.getUniformLocation(c, "projectionVector");
      this.offsetVector = a.getUniformLocation(c, "offsetVector");
      this.dimensions = a.getUniformLocation(c, "dimensions");
      this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition");
      this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord");
      this.colorAttribute = a.getAttribLocation(c, "aColor");
      if (-1 === this.colorAttribute) {
        this.colorAttribute = 2;
      }
      this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
      for (var d in this.uniforms) this.uniforms[d].uniformLocation = a.getUniformLocation(c, d);
      this.initUniforms();
      this.program = c;
    };
    b.PixiShader.prototype.initUniforms = function () {
      this.textureCount = 1;
      var b;
      var a = this.gl;
      for (var c in this.uniforms) {
        b = this.uniforms[c];
        var d = b.type;
        if ("sampler2D" === d) {
          b._init = false;
          if (null !== b.value) {
            this.initSampler2D(b);
          }
        } else if ("mat2" === d || "mat3" === d || "mat4" === d) {
          b.glMatrix = true;
          b.glValueLength = 1;
          if ("mat2" === d) {
            b.glFunc = a.uniformMatrix2fv;
          } else if ("mat3" === d) {
            b.glFunc = a.uniformMatrix3fv;
          } else if ("mat4" === d) {
            b.glFunc = a.uniformMatrix4fv;
          }
        } else {
          b.glFunc = a["uniform" + d];
          b.glValueLength = "2f" === d || "2i" === d ? 2 : "3f" === d || "3i" === d ? 3 : "4f" === d || "4i" === d ? 4 : 1;
        }
      }
    };
    b.PixiShader.prototype.initSampler2D = function (a) {
      if (a.value && a.value.baseTexture && a.value.baseTexture.hasLoaded) {
        var b = this.gl;
        b.activeTexture(b["TEXTURE" + this.textureCount]);
        b.bindTexture(b.TEXTURE_2D, a.value.baseTexture._glTextures[b.id]);
        if (a.textureData) {
          var c = a.textureData;
          var d = c.magFilter ? c.magFilter : b.LINEAR;
          var e = c.minFilter ? c.minFilter : b.LINEAR;
          var f = c.wrapS ? c.wrapS : b.CLAMP_TO_EDGE;
          var g = c.wrapT ? c.wrapT : b.CLAMP_TO_EDGE;
          var h = c.luminance ? b.LUMINANCE : b.RGBA;
          if (c.repeat) {
            f = b.REPEAT;
            g = b.REPEAT;
          }
          b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !!c.flipY);
          if (c.width) {
            var i = c.width ? c.width : 512;
            var j = c.height ? c.height : 2;
            var k = c.border ? c.border : 0;
            b.texImage2D(b.TEXTURE_2D, 0, h, i, j, k, h, b.UNSIGNED_BYTE, null);
          } else {
            b.texImage2D(b.TEXTURE_2D, 0, h, b.RGBA, b.UNSIGNED_BYTE, a.value.baseTexture.source);
          }
          b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, d);
          b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, e);
          b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, f);
          b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, g);
        }
        b.uniform1i(a.uniformLocation, this.textureCount);
        a._init = true;
        this.textureCount++;
      }
    };
    b.PixiShader.prototype.syncUniforms = function () {
      this.textureCount = 1;
      var a;
      var c = this.gl;
      for (var d in this.uniforms) {
        a = this.uniforms[d];
        if (1 === a.glValueLength) {
          if (true === a.glMatrix) {
            a.glFunc.call(c, a.uniformLocation, a.transpose, a.value);
          } else {
            a.glFunc.call(c, a.uniformLocation, a.value);
          }
        } else if (2 === a.glValueLength) {
          a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y);
        } else if (3 === a.glValueLength) {
          a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z);
        } else if (4 === a.glValueLength) {
          a.glFunc.call(c, a.uniformLocation, a.value.x, a.value.y, a.value.z, a.value.w);
        } else if ("sampler2D" === a.type) {
          if (a._init) {
            c.activeTexture(c["TEXTURE" + this.textureCount]);
            if (a.value.baseTexture._dirty[c.id]) {
              b.instances[c.id].updateTexture(a.value.baseTexture);
            } else {
              c.bindTexture(c.TEXTURE_2D, a.value.baseTexture._glTextures[c.id]);
            }
            c.uniform1i(a.uniformLocation, this.textureCount);
            this.textureCount++;
          } else {
            this.initSampler2D(a);
          }
        }
      }
    };
    b.PixiShader.prototype.destroy = function () {
      this.gl.deleteProgram(this.program);
      this.uniforms = null;
      this.gl = null;
      this.attributes = null;
    };
    b.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"];
    b.PixiFastShader = function (a) {
      this._UID = b._UID++;
      this.gl = a;
      this.program = null;
      this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"];
      this.textureCount = 0;
      this.init();
    };
    b.PixiFastShader.prototype.constructor = b.PixiFastShader;
    b.PixiFastShader.prototype.init = function () {
      var a = this.gl;
      var c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
      a.useProgram(c);
      this.uSampler = a.getUniformLocation(c, "uSampler");
      this.projectionVector = a.getUniformLocation(c, "projectionVector");
      this.offsetVector = a.getUniformLocation(c, "offsetVector");
      this.dimensions = a.getUniformLocation(c, "dimensions");
      this.uMatrix = a.getUniformLocation(c, "uMatrix");
      this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition");
      this.aPositionCoord = a.getAttribLocation(c, "aPositionCoord");
      this.aScale = a.getAttribLocation(c, "aScale");
      this.aRotation = a.getAttribLocation(c, "aRotation");
      this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord");
      this.colorAttribute = a.getAttribLocation(c, "aColor");
      if (-1 === this.colorAttribute) {
        this.colorAttribute = 2;
      }
      this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];
      this.program = c;
    };
    b.PixiFastShader.prototype.destroy = function () {
      this.gl.deleteProgram(this.program);
      this.uniforms = null;
      this.gl = null;
      this.attributes = null;
    };
    b.StripShader = function (a) {
      this._UID = b._UID++;
      this.gl = a;
      this.program = null;
      this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"];
      this.init();
    };
    b.StripShader.prototype.constructor = b.StripShader;
    b.StripShader.prototype.init = function () {
      var a = this.gl;
      var c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
      a.useProgram(c);
      this.uSampler = a.getUniformLocation(c, "uSampler");
      this.projectionVector = a.getUniformLocation(c, "projectionVector");
      this.offsetVector = a.getUniformLocation(c, "offsetVector");
      this.colorAttribute = a.getAttribLocation(c, "aColor");
      this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition");
      this.aTextureCoord = a.getAttribLocation(c, "aTextureCoord");
      this.attributes = [this.aVertexPosition, this.aTextureCoord];
      this.translationMatrix = a.getUniformLocation(c, "translationMatrix");
      this.alpha = a.getUniformLocation(c, "alpha");
      this.program = c;
    };
    b.StripShader.prototype.destroy = function () {
      this.gl.deleteProgram(this.program);
      this.uniforms = null;
      this.gl = null;
      this.attribute = null;
    };
    b.PrimitiveShader = function (a) {
      this._UID = b._UID++;
      this.gl = a;
      this.program = null;
      this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"];
      this.init();
    };
    b.PrimitiveShader.prototype.constructor = b.PrimitiveShader;
    b.PrimitiveShader.prototype.init = function () {
      var a = this.gl;
      var c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
      a.useProgram(c);
      this.projectionVector = a.getUniformLocation(c, "projectionVector");
      this.offsetVector = a.getUniformLocation(c, "offsetVector");
      this.tintColor = a.getUniformLocation(c, "tint");
      this.flipY = a.getUniformLocation(c, "flipY");
      this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition");
      this.colorAttribute = a.getAttribLocation(c, "aColor");
      this.attributes = [this.aVertexPosition, this.colorAttribute];
      this.translationMatrix = a.getUniformLocation(c, "translationMatrix");
      this.alpha = a.getUniformLocation(c, "alpha");
      this.program = c;
    };
    b.PrimitiveShader.prototype.destroy = function () {
      this.gl.deleteProgram(this.program);
      this.uniforms = null;
      this.gl = null;
      this.attributes = null;
    };
    b.ComplexPrimitiveShader = function (a) {
      this._UID = b._UID++;
      this.gl = a;
      this.program = null;
      this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"];
      this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"];
      this.init();
    };
    b.ComplexPrimitiveShader.prototype.constructor = b.ComplexPrimitiveShader;
    b.ComplexPrimitiveShader.prototype.init = function () {
      var a = this.gl;
      var c = b.compileProgram(a, this.vertexSrc, this.fragmentSrc);
      a.useProgram(c);
      this.projectionVector = a.getUniformLocation(c, "projectionVector");
      this.offsetVector = a.getUniformLocation(c, "offsetVector");
      this.tintColor = a.getUniformLocation(c, "tint");
      this.color = a.getUniformLocation(c, "color");
      this.flipY = a.getUniformLocation(c, "flipY");
      this.aVertexPosition = a.getAttribLocation(c, "aVertexPosition");
      this.attributes = [this.aVertexPosition, this.colorAttribute];
      this.translationMatrix = a.getUniformLocation(c, "translationMatrix");
      this.alpha = a.getUniformLocation(c, "alpha");
      this.program = c;
    };
    b.ComplexPrimitiveShader.prototype.destroy = function () {
      this.gl.deleteProgram(this.program);
      this.uniforms = null;
      this.gl = null;
      this.attribute = null;
    };
    b.glContexts = [];
    b.instances = [];
    b.WebGLRenderer = function (a) {
      this.game = a;
      if (!b.defaultRenderer) {
        b.defaultRenderer = this;
      }
      this.type = b.WEBGL_RENDERER;
      this.resolution = a.resolution;
      this.transparent = a.transparent;
      this.autoResize = false;
      this.preserveDrawingBuffer = a.preserveDrawingBuffer;
      this.clearBeforeRender = a.clearBeforeRender;
      this.width = a.width;
      this.height = a.height;
      this.view = a.canvas;
      this._contextOptions = {
        alpha: this.transparent,
        antialias: a.antialias,
        premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
        stencil: true,
        preserveDrawingBuffer: this.preserveDrawingBuffer
      };
      this.projection = new b.Point();
      this.offset = new b.Point();
      this.shaderManager = new b.WebGLShaderManager();
      this.spriteBatch = new b.WebGLSpriteBatch();
      this.maskManager = new b.WebGLMaskManager();
      this.filterManager = new b.WebGLFilterManager();
      this.stencilManager = new b.WebGLStencilManager();
      this.blendModeManager = new b.WebGLBlendModeManager();
      this.renderSession = {};
      this.renderSession.game = this.game;
      this.renderSession.gl = this.gl;
      this.renderSession.drawCount = 0;
      this.renderSession.shaderManager = this.shaderManager;
      this.renderSession.maskManager = this.maskManager;
      this.renderSession.filterManager = this.filterManager;
      this.renderSession.blendModeManager = this.blendModeManager;
      this.renderSession.spriteBatch = this.spriteBatch;
      this.renderSession.stencilManager = this.stencilManager;
      this.renderSession.renderer = this;
      this.renderSession.resolution = this.resolution;
      this.initContext();
      this.mapBlendModes();
    };
    b.WebGLRenderer.prototype.constructor = b.WebGLRenderer;
    b.WebGLRenderer.prototype.initContext = function () {
      var a = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
      this.gl = a;
      if (!a) {
        throw new Error("This browser does not support webGL. Try using the canvas renderer");
      }
      this.glContextId = a.id = b.WebGLRenderer.glContextId++;
      b.glContexts[this.glContextId] = a;
      b.instances[this.glContextId] = this;
      a.disable(a.DEPTH_TEST);
      a.disable(a.CULL_FACE);
      a.enable(a.BLEND);
      this.shaderManager.setContext(a);
      this.spriteBatch.setContext(a);
      this.maskManager.setContext(a);
      this.filterManager.setContext(a);
      this.blendModeManager.setContext(a);
      this.stencilManager.setContext(a);
      this.renderSession.gl = this.gl;
      this.resize(this.width, this.height);
    };
    b.WebGLRenderer.prototype.render = function (a) {
      if (!this.contextLost) {
        var b = this.gl;
        b.viewport(0, 0, this.width, this.height);
        b.bindFramebuffer(b.FRAMEBUFFER, null);
        if (this.game.clearBeforeRender) {
          b.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a);
          b.clear(b.COLOR_BUFFER_BIT);
        }
        this.offset.x = this.game.camera._shake.x;
        this.offset.y = this.game.camera._shake.y;
        this.renderDisplayObject(a, this.projection);
      }
    };
    b.WebGLRenderer.prototype.renderDisplayObject = function (a, c, d, e) {
      this.renderSession.blendModeManager.setBlendMode(b.blendModes.NORMAL);
      this.renderSession.drawCount = 0;
      this.renderSession.flipY = d ? -1 : 1;
      this.renderSession.projection = c;
      this.renderSession.offset = this.offset;
      this.spriteBatch.begin(this.renderSession);
      this.filterManager.begin(this.renderSession, d);
      a._renderWebGL(this.renderSession, e);
      this.spriteBatch.end();
    };
    b.WebGLRenderer.prototype.resize = function (a, b) {
      this.width = a * this.resolution;
      this.height = b * this.resolution;
      this.view.width = this.width;
      this.view.height = this.height;
      if (this.autoResize) {
        this.view.style.width = this.width / this.resolution + "px";
        this.view.style.height = this.height / this.resolution + "px";
      }
      this.gl.viewport(0, 0, this.width, this.height);
      this.projection.x = this.width / 2 / this.resolution;
      this.projection.y = -this.height / 2 / this.resolution;
    };
    b.WebGLRenderer.prototype.updateTexture = function (a) {
      if (!a.hasLoaded) {
        return false;
      }
      var c = this.gl;
      if (!a._glTextures[c.id]) {
        a._glTextures[c.id] = c.createTexture();
      }
      c.bindTexture(c.TEXTURE_2D, a._glTextures[c.id]);
      c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultipliedAlpha);
      c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, a.source);
      c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST);
      if (a.mipmap && b.isPowerOfTwo(a.width, a.height)) {
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR_MIPMAP_LINEAR : c.NEAREST_MIPMAP_NEAREST);
        c.generateMipmap(c.TEXTURE_2D);
      } else {
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.scaleMode === b.scaleModes.LINEAR ? c.LINEAR : c.NEAREST);
      }
      if (a._powerOf2) {
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT);
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT);
      } else {
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
      }
      a._dirty[c.id] = false;
      return true;
    };
    b.WebGLRenderer.prototype.destroy = function () {
      b.glContexts[this.glContextId] = null;
      this.projection = null;
      this.offset = null;
      this.shaderManager.destroy();
      this.spriteBatch.destroy();
      this.maskManager.destroy();
      this.filterManager.destroy();
      this.shaderManager = null;
      this.spriteBatch = null;
      this.maskManager = null;
      this.filterManager = null;
      this.gl = null;
      this.renderSession = null;
      b.CanvasPool.remove(this);
      b.instances[this.glContextId] = null;
      b.WebGLRenderer.glContextId--;
    };
    b.WebGLRenderer.prototype.mapBlendModes = function () {
      var a = this.gl;
      if (!b.blendModesWebGL) {
        var c = [];
        var d = b.blendModes;
        c[d.NORMAL] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.ADD] = [a.SRC_ALPHA, a.DST_ALPHA];
        c[d.MULTIPLY] = [a.DST_COLOR, a.ONE_MINUS_SRC_ALPHA];
        c[d.SCREEN] = [a.SRC_ALPHA, a.ONE];
        c[d.OVERLAY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.DARKEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.LIGHTEN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.COLOR_DODGE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.COLOR_BURN] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.HARD_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.SOFT_LIGHT] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.DIFFERENCE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.EXCLUSION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.HUE] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.SATURATION] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.COLOR] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        c[d.LUMINOSITY] = [a.ONE, a.ONE_MINUS_SRC_ALPHA];
        b.blendModesWebGL = c;
      }
    };
    b.WebGLRenderer.glContextId = 0;
    b.WebGLBlendModeManager = function () {
      this.currentBlendMode = 99999;
    };
    b.WebGLBlendModeManager.prototype.constructor = b.WebGLBlendModeManager;
    b.WebGLBlendModeManager.prototype.setContext = function (a) {
      this.gl = a;
    };
    b.WebGLBlendModeManager.prototype.setBlendMode = function (a) {
      if (this.currentBlendMode === a) {
        return false;
      }
      this.currentBlendMode = a;
      var c = b.blendModesWebGL[this.currentBlendMode];
      if (c) {
        this.gl.blendFunc(c[0], c[1]);
      }
      return true;
    };
    b.WebGLBlendModeManager.prototype.destroy = function () {
      this.gl = null;
    };
    b.WebGLMaskManager = function () {};
    b.WebGLMaskManager.prototype.constructor = b.WebGLMaskManager;
    b.WebGLMaskManager.prototype.setContext = function (a) {
      this.gl = a;
    };
    b.WebGLMaskManager.prototype.pushMask = function (a, c) {
      var d = c.gl;
      if (a.dirty) {
        b.WebGLGraphics.updateGraphics(a, d);
      }
      if (undefined !== a._webGL[d.id] && undefined !== a._webGL[d.id].data && 0 !== a._webGL[d.id].data.length) {
        c.stencilManager.pushStencil(a, a._webGL[d.id].data[0], c);
      }
    };
    b.WebGLMaskManager.prototype.popMask = function (a, b) {
      var c = this.gl;
      if (undefined !== a._webGL[c.id] && undefined !== a._webGL[c.id].data && 0 !== a._webGL[c.id].data.length) {
        b.stencilManager.popStencil(a, a._webGL[c.id].data[0], b);
      }
    };
    b.WebGLMaskManager.prototype.destroy = function () {
      this.gl = null;
    };
    b.WebGLStencilManager = function () {
      this.stencilStack = [];
      this.reverse = true;
      this.count = 0;
    };
    b.WebGLStencilManager.prototype.setContext = function (a) {
      this.gl = a;
    };
    b.WebGLStencilManager.prototype.pushStencil = function (a, b, c) {
      var d = this.gl;
      this.bindGraphics(a, b, c);
      if (0 === this.stencilStack.length) {
        d.enable(d.STENCIL_TEST);
        d.clear(d.STENCIL_BUFFER_BIT);
        this.reverse = true;
        this.count = 0;
      }
      this.stencilStack.push(b);
      var e = this.count;
      d.colorMask(false, false, false, false);
      d.stencilFunc(d.ALWAYS, 0, 255);
      d.stencilOp(d.KEEP, d.KEEP, d.INVERT);
      if (1 === b.mode) {
        d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0);
        if (this.reverse) {
          d.stencilFunc(d.EQUAL, 255 - e, 255);
          d.stencilOp(d.KEEP, d.KEEP, d.DECR);
        } else {
          d.stencilFunc(d.EQUAL, e, 255);
          d.stencilOp(d.KEEP, d.KEEP, d.INCR);
        }
        d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4));
        if (this.reverse) {
          d.stencilFunc(d.EQUAL, 255 - (e + 1), 255);
        } else {
          d.stencilFunc(d.EQUAL, e + 1, 255);
        }
        this.reverse = !this.reverse;
      } else {
        if (this.reverse) {
          d.stencilFunc(d.EQUAL, e, 255);
          d.stencilOp(d.KEEP, d.KEEP, d.INCR);
        } else {
          d.stencilFunc(d.EQUAL, 255 - e, 255);
          d.stencilOp(d.KEEP, d.KEEP, d.DECR);
        }
        d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0);
        if (this.reverse) {
          d.stencilFunc(d.EQUAL, e + 1, 255);
        } else {
          d.stencilFunc(d.EQUAL, 255 - (e + 1), 255);
        }
      }
      d.colorMask(true, true, true, true);
      d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
      this.count++;
    };
    b.WebGLStencilManager.prototype.bindGraphics = function (a, c, d) {
      this._currentGraphics = a;
      var h;
      var e = this.gl;
      var f = d.projection;
      var g = d.offset;
      if (1 === c.mode) {
        h = d.shaderManager.complexPrimitiveShader;
        d.shaderManager.setShader(h);
        e.uniform1f(h.flipY, d.flipY);
        e.uniformMatrix3fv(h.translationMatrix, false, a.worldTransform.toArray(true));
        e.uniform2f(h.projectionVector, f.x, -f.y);
        e.uniform2f(h.offsetVector, -g.x, -g.y);
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint));
        e.uniform3fv(h.color, c.color);
        e.uniform1f(h.alpha, a.worldAlpha * c.alpha);
        e.bindBuffer(e.ARRAY_BUFFER, c.buffer);
        e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, false, 8, 0);
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c.indexBuffer);
      } else {
        h = d.shaderManager.primitiveShader;
        d.shaderManager.setShader(h);
        e.uniformMatrix3fv(h.translationMatrix, false, a.worldTransform.toArray(true));
        e.uniform1f(h.flipY, d.flipY);
        e.uniform2f(h.projectionVector, f.x, -f.y);
        e.uniform2f(h.offsetVector, -g.x, -g.y);
        e.uniform3fv(h.tintColor, b.hex2rgb(a.tint));
        e.uniform1f(h.alpha, a.worldAlpha);
        e.bindBuffer(e.ARRAY_BUFFER, c.buffer);
        e.vertexAttribPointer(h.aVertexPosition, 2, e.FLOAT, false, 24, 0);
        e.vertexAttribPointer(h.colorAttribute, 4, e.FLOAT, false, 24, 8);
        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c.indexBuffer);
      }
    };
    b.WebGLStencilManager.prototype.popStencil = function (a, b, c) {
      var d = this.gl;
      this.stencilStack.pop();
      this.count--;
      if (0 === this.stencilStack.length) {
        d.disable(d.STENCIL_TEST);
      } else {
        var e = this.count;
        this.bindGraphics(a, b, c);
        d.colorMask(false, false, false, false);
        if (1 === b.mode) {
          this.reverse = !this.reverse;
          if (this.reverse) {
            d.stencilFunc(d.EQUAL, 255 - (e + 1), 255);
            d.stencilOp(d.KEEP, d.KEEP, d.INCR);
          } else {
            d.stencilFunc(d.EQUAL, e + 1, 255);
            d.stencilOp(d.KEEP, d.KEEP, d.DECR);
          }
          d.drawElements(d.TRIANGLE_FAN, 4, d.UNSIGNED_SHORT, 2 * (b.indices.length - 4));
          d.stencilFunc(d.ALWAYS, 0, 255);
          d.stencilOp(d.KEEP, d.KEEP, d.INVERT);
          d.drawElements(d.TRIANGLE_FAN, b.indices.length - 4, d.UNSIGNED_SHORT, 0);
          if (this.reverse) {
            d.stencilFunc(d.EQUAL, e, 255);
          } else {
            d.stencilFunc(d.EQUAL, 255 - e, 255);
          }
        } else {
          if (this.reverse) {
            d.stencilFunc(d.EQUAL, e + 1, 255);
            d.stencilOp(d.KEEP, d.KEEP, d.DECR);
          } else {
            d.stencilFunc(d.EQUAL, 255 - (e + 1), 255);
            d.stencilOp(d.KEEP, d.KEEP, d.INCR);
          }
          d.drawElements(d.TRIANGLE_STRIP, b.indices.length, d.UNSIGNED_SHORT, 0);
          if (this.reverse) {
            d.stencilFunc(d.EQUAL, e, 255);
          } else {
            d.stencilFunc(d.EQUAL, 255 - e, 255);
          }
        }
        d.colorMask(true, true, true, true);
        d.stencilOp(d.KEEP, d.KEEP, d.KEEP);
      }
    };
    b.WebGLStencilManager.prototype.destroy = function () {
      this.stencilStack = null;
      this.gl = null;
    };
    b.WebGLShaderManager = function () {
      this.maxAttibs = 10;
      this.attribState = [];
      this.tempAttribState = [];
      for (var a = 0; a < this.maxAttibs; a++) {
        this.attribState[a] = false;
      }
      this.stack = [];
    };
    b.WebGLShaderManager.prototype.constructor = b.WebGLShaderManager;
    b.WebGLShaderManager.prototype.setContext = function (a) {
      this.gl = a;
      this.primitiveShader = new b.PrimitiveShader(a);
      this.complexPrimitiveShader = new b.ComplexPrimitiveShader(a);
      this.defaultShader = new b.PixiShader(a);
      this.fastShader = new b.PixiFastShader(a);
      this.stripShader = new b.StripShader(a);
      this.setShader(this.defaultShader);
    };
    b.WebGLShaderManager.prototype.setAttribs = function (a) {
      var b;
      for (b = 0; b < this.tempAttribState.length; b++) {
        this.tempAttribState[b] = false;
      }
      for (b = 0; b < a.length; b++) {
        var c = a[b];
        this.tempAttribState[c] = true;
      }
      var d = this.gl;
      for (b = 0; b < this.attribState.length; b++) {
        if (this.attribState[b] !== this.tempAttribState[b]) {
          this.attribState[b] = this.tempAttribState[b];
          if (this.tempAttribState[b]) {
            d.enableVertexAttribArray(b);
          } else {
            d.disableVertexAttribArray(b);
          }
        }
      }
    };
    b.WebGLShaderManager.prototype.setShader = function (a) {
      return this._currentId !== a._UID && (this._currentId = a._UID, this.currentShader = a, this.gl.useProgram(a.program), this.setAttribs(a.attributes), true);
    };
    b.WebGLShaderManager.prototype.destroy = function () {
      this.attribState = null;
      this.tempAttribState = null;
      this.primitiveShader.destroy();
      this.complexPrimitiveShader.destroy();
      this.defaultShader.destroy();
      this.fastShader.destroy();
      this.stripShader.destroy();
      this.gl = null;
    };
    b.WebGLSpriteBatch = function () {
      this.vertSize = 5;
      this.size = 2e3;
      var a = 4 * this.size * 4 * this.vertSize;
      var c = 6 * this.size;
      this.vertices = new b.ArrayBuffer(a);
      this.positions = new b.Float32Array(this.vertices);
      this.colors = new b.Uint32Array(this.vertices);
      this.indices = new b.Uint16Array(c);
      this.lastIndexCount = 0;
      var d = 0;
      for (var e = 0; d < c; d += 6, e += 4) {
        this.indices[d + 0] = e + 0;
        this.indices[d + 1] = e + 1;
        this.indices[d + 2] = e + 2;
        this.indices[d + 3] = e + 0;
        this.indices[d + 4] = e + 2;
        this.indices[d + 5] = e + 3;
      }
      this.drawing = false;
      this.currentBatchSize = 0;
      this.currentBaseTexture = null;
      this.dirty = true;
      this.textures = [];
      this.blendModes = [];
      this.shaders = [];
      this.sprites = [];
      this.defaultShader = new b.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
    };
    b.WebGLSpriteBatch.prototype.setContext = function (a) {
      this.gl = a;
      this.vertexBuffer = a.createBuffer();
      this.indexBuffer = a.createBuffer();
      a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW);
      a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
      a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
      this.currentBlendMode = 99999;
      var c = new b.PixiShader(a);
      c.fragmentSrc = this.defaultShader.fragmentSrc;
      c.uniforms = {};
      c.init();
      this.defaultShader.shaders[a.id] = c;
    };
    b.WebGLSpriteBatch.prototype.begin = function (a) {
      this.renderSession = a;
      this.shader = this.renderSession.shaderManager.defaultShader;
      this.start();
    };
    b.WebGLSpriteBatch.prototype.end = function () {
      this.flush();
    };
    b.WebGLSpriteBatch.prototype.render = function (a, b) {
      var c = a.texture;
      var d = a.worldTransform;
      if (b) {
        d = b;
      }
      if (this.currentBatchSize >= this.size) {
        this.flush();
        this.currentBaseTexture = c.baseTexture;
      }
      var e = c._uvs;
      if (e) {
        var h;
        var i;
        var j;
        var k;
        var f = a.anchor.x;
        var g = a.anchor.y;
        if (c.trim) {
          var l = c.trim;
          i = l.x - f * l.width;
          h = i + c.crop.width;
          k = l.y - g * l.height;
          j = k + c.crop.height;
        } else {
          h = c.frame.width * (1 - f);
          i = c.frame.width * -f;
          j = c.frame.height * (1 - g);
          k = c.frame.height * -g;
        }
        var m = 4 * this.currentBatchSize * this.vertSize;
        var n = c.baseTexture.resolution;
        var o = d.a / n;
        var p = d.b / n;
        var q = d.c / n;
        var r = d.d / n;
        var s = d.tx;
        var t = d.ty;
        var u = this.colors;
        var v = this.positions;
        if (this.renderSession.roundPixels) {
          v[m] = o * i + q * k + s | 0;
          v[m + 1] = r * k + p * i + t | 0;
          v[m + 5] = o * h + q * k + s | 0;
          v[m + 6] = r * k + p * h + t | 0;
          v[m + 10] = o * h + q * j + s | 0;
          v[m + 11] = r * j + p * h + t | 0;
          v[m + 15] = o * i + q * j + s | 0;
          v[m + 16] = r * j + p * i + t | 0;
        } else {
          v[m] = o * i + q * k + s;
          v[m + 1] = r * k + p * i + t;
          v[m + 5] = o * h + q * k + s;
          v[m + 6] = r * k + p * h + t;
          v[m + 10] = o * h + q * j + s;
          v[m + 11] = r * j + p * h + t;
          v[m + 15] = o * i + q * j + s;
          v[m + 16] = r * j + p * i + t;
        }
        v[m + 2] = e.x0;
        v[m + 3] = e.y0;
        v[m + 7] = e.x1;
        v[m + 8] = e.y1;
        v[m + 12] = e.x2;
        v[m + 13] = e.y2;
        v[m + 17] = e.x3;
        v[m + 18] = e.y3;
        var w = a.tint;
        u[m + 4] = u[m + 9] = u[m + 14] = u[m + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * a.worldAlpha << 24);
        this.sprites[this.currentBatchSize++] = a;
      }
    };
    b.WebGLSpriteBatch.prototype.renderTilingSprite = function (a) {
      var c = a.tilingTexture;
      if (this.currentBatchSize >= this.size) {
        this.flush();
        this.currentBaseTexture = c.baseTexture;
      }
      if (!a._uvs) {
        a._uvs = new b.TextureUvs();
      }
      var d = a._uvs;
      var e = c.baseTexture.width;
      var f = c.baseTexture.height;
      a.tilePosition.x %= e * a.tileScaleOffset.x;
      a.tilePosition.y %= f * a.tileScaleOffset.y;
      var g = a.tilePosition.x / (e * a.tileScaleOffset.x);
      var h = a.tilePosition.y / (f * a.tileScaleOffset.y);
      var i = a.width / e / (a.tileScale.x * a.tileScaleOffset.x);
      var j = a.height / f / (a.tileScale.y * a.tileScaleOffset.y);
      d.x0 = 0 - g;
      d.y0 = 0 - h;
      d.x1 = 1 * i - g;
      d.y1 = 0 - h;
      d.x2 = 1 * i - g;
      d.y2 = 1 * j - h;
      d.x3 = 0 - g;
      d.y3 = 1 * j - h;
      var k = a.tint;
      var l = (k >> 16) + (65280 & k) + ((255 & k) << 16) + (255 * a.worldAlpha << 24);
      var m = this.positions;
      var n = this.colors;
      var o = a.width;
      var p = a.height;
      var q = a.anchor.x;
      var r = a.anchor.y;
      var s = o * (1 - q);
      var t = o * -q;
      var u = p * (1 - r);
      var v = p * -r;
      var w = 4 * this.currentBatchSize * this.vertSize;
      var x = c.baseTexture.resolution;
      var y = a.worldTransform;
      var z = y.a / x;
      var A = y.b / x;
      var B = y.c / x;
      var C = y.d / x;
      var D = y.tx;
      var E = y.ty;
      m[w++] = z * t + B * v + D;
      m[w++] = C * v + A * t + E;
      m[w++] = d.x0;
      m[w++] = d.y0;
      n[w++] = l;
      m[w++] = z * s + B * v + D;
      m[w++] = C * v + A * s + E;
      m[w++] = d.x1;
      m[w++] = d.y1;
      n[w++] = l;
      m[w++] = z * s + B * u + D;
      m[w++] = C * u + A * s + E;
      m[w++] = d.x2;
      m[w++] = d.y2;
      n[w++] = l;
      m[w++] = z * t + B * u + D;
      m[w++] = C * u + A * t + E;
      m[w++] = d.x3;
      m[w++] = d.y3;
      n[w++] = l;
      this.sprites[this.currentBatchSize++] = a;
    };
    b.WebGLSpriteBatch.prototype.flush = function () {
      if (0 !== this.currentBatchSize) {
        var c;
        var a = this.gl;
        if (this.dirty) {
          this.dirty = false;
          a.activeTexture(a.TEXTURE0);
          a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
          a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          c = this.defaultShader.shaders[a.id];
          var d = 4 * this.vertSize;
          a.vertexAttribPointer(c.aVertexPosition, 2, a.FLOAT, false, d, 0);
          a.vertexAttribPointer(c.aTextureCoord, 2, a.FLOAT, false, d, 8);
          a.vertexAttribPointer(c.colorAttribute, 4, a.UNSIGNED_BYTE, true, d, 16);
        }
        if (this.currentBatchSize > .5 * this.size) {
          a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
        } else {
          var e = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
          a.bufferSubData(a.ARRAY_BUFFER, 0, e);
        }
        var f;
        var g;
        var h;
        var p;
        var i = 0;
        var j = 0;
        var k = null;
        var l = this.renderSession.blendModeManager.currentBlendMode;
        var m = null;
        var n = false;
        var o = false;
        var q = 0;
        for (var r = this.currentBatchSize; q < r; q++) {
          p = this.sprites[q];
          f = p.tilingTexture ? p.tilingTexture.baseTexture : p.texture.baseTexture;
          g = p.blendMode;
          h = p.shader || this.defaultShader;
          n = l !== g;
          o = m !== h;
          var s = f.skipRender;
          if (s && p.children.length > 0) {
            s = false;
          }
          if ((k !== f && !s || n || o) && (this.renderBatch(k, i, j), j = q, i = 0, k = f, n && (l = g, this.renderSession.blendModeManager.setBlendMode(l)), o)) {
            m = h;
            c = m.shaders[a.id];
            if (!c) {
              c = new b.PixiShader(a);
              c.fragmentSrc = m.fragmentSrc;
              c.uniforms = m.uniforms;
              c.init();
              m.shaders[a.id] = c;
            }
            this.renderSession.shaderManager.setShader(c);
            if (c.dirty) {
              c.syncUniforms();
            }
            var t = this.renderSession.projection;
            a.uniform2f(c.projectionVector, t.x, t.y);
            var u = this.renderSession.offset;
            a.uniform2f(c.offsetVector, u.x, u.y);
          }
          i++;
        }
        this.renderBatch(k, i, j);
        this.currentBatchSize = 0;
      }
    };
    b.WebGLSpriteBatch.prototype.renderBatch = function (a, b, c) {
      if (0 !== b) {
        var d = this.gl;
        if (a._dirty[d.id]) {
          if (!this.renderSession.renderer.updateTexture(a)) {
            return;
          }
        } else {
          d.bindTexture(d.TEXTURE_2D, a._glTextures[d.id]);
        }
        d.drawElements(d.TRIANGLES, 6 * b, d.UNSIGNED_SHORT, 6 * c * 2);
        this.renderSession.drawCount++;
      }
    };
    b.WebGLSpriteBatch.prototype.stop = function () {
      this.flush();
      this.dirty = true;
    };
    b.WebGLSpriteBatch.prototype.start = function () {
      this.dirty = true;
    };
    b.WebGLSpriteBatch.prototype.destroy = function () {
      this.vertices = null;
      this.indices = null;
      this.gl.deleteBuffer(this.vertexBuffer);
      this.gl.deleteBuffer(this.indexBuffer);
      this.currentBaseTexture = null;
      this.gl = null;
    };
    b.WebGLFastSpriteBatch = function (a) {
      this.vertSize = 10;
      this.maxSize = 6e3;
      this.size = this.maxSize;
      var c = 4 * this.size * this.vertSize;
      var d = 6 * this.maxSize;
      this.vertices = new b.Float32Array(c);
      this.indices = new b.Uint16Array(d);
      this.vertexBuffer = null;
      this.indexBuffer = null;
      this.lastIndexCount = 0;
      var e = 0;
      for (var f = 0; e < d; e += 6, f += 4) {
        this.indices[e + 0] = f + 0;
        this.indices[e + 1] = f + 1;
        this.indices[e + 2] = f + 2;
        this.indices[e + 3] = f + 0;
        this.indices[e + 4] = f + 2;
        this.indices[e + 5] = f + 3;
      }
      this.drawing = false;
      this.currentBatchSize = 0;
      this.currentBaseTexture = null;
      this.currentBlendMode = 0;
      this.renderSession = null;
      this.shader = null;
      this.matrix = null;
      this.setContext(a);
    };
    b.WebGLFastSpriteBatch.prototype.constructor = b.WebGLFastSpriteBatch;
    b.WebGLFastSpriteBatch.prototype.setContext = function (a) {
      this.gl = a;
      this.vertexBuffer = a.createBuffer();
      this.indexBuffer = a.createBuffer();
      a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.indices, a.STATIC_DRAW);
      a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
      a.bufferData(a.ARRAY_BUFFER, this.vertices, a.DYNAMIC_DRAW);
    };
    b.WebGLFastSpriteBatch.prototype.begin = function (a, b) {
      this.renderSession = b;
      this.shader = this.renderSession.shaderManager.fastShader;
      this.matrix = a.worldTransform.toArray(true);
      this.start();
    };
    b.WebGLFastSpriteBatch.prototype.end = function () {
      this.flush();
    };
    b.WebGLFastSpriteBatch.prototype.render = function (a) {
      var b = a.children;
      var c = b[0];
      if (c.texture._uvs) {
        this.currentBaseTexture = c.texture.baseTexture;
        if (c.blendMode !== this.renderSession.blendModeManager.currentBlendMode) {
          this.flush();
          this.renderSession.blendModeManager.setBlendMode(c.blendMode);
        }
        var d = 0;
        for (var e = b.length; d < e; d++) {
          this.renderSprite(b[d]);
        }
        this.flush();
      }
    };
    b.WebGLFastSpriteBatch.prototype.renderSprite = function (a) {
      if (a.visible && (a.texture.baseTexture === this.currentBaseTexture || a.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = a.texture.baseTexture, a.texture._uvs))) {
        var b;
        var f;
        var g;
        var h;
        var i;
        var j;
        var c = this.vertices;
        b = a.texture._uvs;
        a.texture.frame.width;
        a.texture.frame.height;
        if (a.texture.trim) {
          var k = a.texture.trim;
          g = k.x - a.anchor.x * k.width;
          f = g + a.texture.crop.width;
          i = k.y - a.anchor.y * k.height;
          h = i + a.texture.crop.height;
        } else {
          f = a.texture.frame.width * (1 - a.anchor.x);
          g = a.texture.frame.width * -a.anchor.x;
          h = a.texture.frame.height * (1 - a.anchor.y);
          i = a.texture.frame.height * -a.anchor.y;
        }
        j = 4 * this.currentBatchSize * this.vertSize;
        c[j++] = g;
        c[j++] = i;
        c[j++] = a.position.x;
        c[j++] = a.position.y;
        c[j++] = a.scale.x;
        c[j++] = a.scale.y;
        c[j++] = a.rotation;
        c[j++] = b.x0;
        c[j++] = b.y1;
        c[j++] = a.alpha;
        c[j++] = f;
        c[j++] = i;
        c[j++] = a.position.x;
        c[j++] = a.position.y;
        c[j++] = a.scale.x;
        c[j++] = a.scale.y;
        c[j++] = a.rotation;
        c[j++] = b.x1;
        c[j++] = b.y1;
        c[j++] = a.alpha;
        c[j++] = f;
        c[j++] = h;
        c[j++] = a.position.x;
        c[j++] = a.position.y;
        c[j++] = a.scale.x;
        c[j++] = a.scale.y;
        c[j++] = a.rotation;
        c[j++] = b.x2;
        c[j++] = b.y2;
        c[j++] = a.alpha;
        c[j++] = g;
        c[j++] = h;
        c[j++] = a.position.x;
        c[j++] = a.position.y;
        c[j++] = a.scale.x;
        c[j++] = a.scale.y;
        c[j++] = a.rotation;
        c[j++] = b.x3;
        c[j++] = b.y3;
        c[j++] = a.alpha;
        this.currentBatchSize++;
        if (this.currentBatchSize >= this.size) {
          this.flush();
        }
      }
    };
    b.WebGLFastSpriteBatch.prototype.flush = function () {
      if (0 !== this.currentBatchSize) {
        var a = this.gl;
        if (!this.currentBaseTexture._glTextures[a.id]) {
          this.renderSession.renderer.updateTexture(this.currentBaseTexture, a);
        }
        a.bindTexture(a.TEXTURE_2D, this.currentBaseTexture._glTextures[a.id]);
        if (this.currentBatchSize > .5 * this.size) {
          a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertices);
        } else {
          var b = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
          a.bufferSubData(a.ARRAY_BUFFER, 0, b);
        }
        a.drawElements(a.TRIANGLES, 6 * this.currentBatchSize, a.UNSIGNED_SHORT, 0);
        this.currentBatchSize = 0;
        this.renderSession.drawCount++;
      }
    };
    b.WebGLFastSpriteBatch.prototype.stop = function () {
      this.flush();
    };
    b.WebGLFastSpriteBatch.prototype.start = function () {
      var a = this.gl;
      a.activeTexture(a.TEXTURE0);
      a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
      a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      var b = this.renderSession.projection;
      a.uniform2f(this.shader.projectionVector, b.x, b.y);
      a.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);
      var c = 4 * this.vertSize;
      a.vertexAttribPointer(this.shader.aVertexPosition, 2, a.FLOAT, false, c, 0);
      a.vertexAttribPointer(this.shader.aPositionCoord, 2, a.FLOAT, false, c, 8);
      a.vertexAttribPointer(this.shader.aScale, 2, a.FLOAT, false, c, 16);
      a.vertexAttribPointer(this.shader.aRotation, 1, a.FLOAT, false, c, 24);
      a.vertexAttribPointer(this.shader.aTextureCoord, 2, a.FLOAT, false, c, 28);
      a.vertexAttribPointer(this.shader.colorAttribute, 1, a.FLOAT, false, c, 36);
    };
    b.WebGLFilterManager = function () {
      this.filterStack = [];
      this.offsetX = 0;
      this.offsetY = 0;
    };
    b.WebGLFilterManager.prototype.constructor = b.WebGLFilterManager;
    b.WebGLFilterManager.prototype.setContext = function (a) {
      this.gl = a;
      this.texturePool = [];
      this.initShaderBuffers();
    };
    b.WebGLFilterManager.prototype.begin = function (a, b) {
      this.renderSession = a;
      this.defaultShader = a.shaderManager.defaultShader;
      var c = this.renderSession.projection;
      this.width = 2 * c.x;
      this.height = 2 * -c.y;
      this.buffer = b;
    };
    b.WebGLFilterManager.prototype.pushFilter = function (a) {
      var c = this.gl;
      var d = this.renderSession.projection;
      var e = this.renderSession.offset;
      a._filterArea = a.target.filterArea || a.target.getBounds();
      a._previous_stencil_mgr = this.renderSession.stencilManager;
      this.renderSession.stencilManager = new b.WebGLStencilManager();
      this.renderSession.stencilManager.setContext(c);
      c.disable(c.STENCIL_TEST);
      this.filterStack.push(a);
      var f = a.filterPasses[0];
      this.offsetX += a._filterArea.x;
      this.offsetY += a._filterArea.y;
      var g = this.texturePool.pop();
      if (g) {
        g.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
      } else {
        g = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
      }
      c.bindTexture(c.TEXTURE_2D, g.texture);
      var h = a._filterArea;
      var i = f.padding;
      h.x -= i;
      h.y -= i;
      h.width += 2 * i;
      h.height += 2 * i;
      if (h.x < 0) {
        h.x = 0;
      }
      if (h.width > this.width) {
        h.width = this.width;
      }
      if (h.y < 0) {
        h.y = 0;
      }
      if (h.height > this.height) {
        h.height = this.height;
      }
      c.bindFramebuffer(c.FRAMEBUFFER, g.frameBuffer);
      c.viewport(0, 0, h.width * this.renderSession.resolution, h.height * this.renderSession.resolution);
      d.x = h.width / 2;
      d.y = -h.height / 2;
      e.x = -h.x;
      e.y = -h.y;
      c.colorMask(true, true, true, true);
      c.clearColor(0, 0, 0, 0);
      c.clear(c.COLOR_BUFFER_BIT);
      a._glFilterTexture = g;
    };
    b.WebGLFilterManager.prototype.popFilter = function () {
      var a = this.gl;
      var c = this.filterStack.pop();
      var d = c._filterArea;
      var e = c._glFilterTexture;
      var f = this.renderSession.projection;
      var g = this.renderSession.offset;
      if (c.filterPasses.length > 1) {
        a.viewport(0, 0, d.width * this.renderSession.resolution, d.height * this.renderSession.resolution);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        this.vertexArray[0] = 0;
        this.vertexArray[1] = d.height;
        this.vertexArray[2] = d.width;
        this.vertexArray[3] = d.height;
        this.vertexArray[4] = 0;
        this.vertexArray[5] = 0;
        this.vertexArray[6] = d.width;
        this.vertexArray[7] = 0;
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
        a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
        this.uvArray[2] = d.width / this.width;
        this.uvArray[5] = d.height / this.height;
        this.uvArray[6] = d.width / this.width;
        this.uvArray[7] = d.height / this.height;
        a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
        var h = e;
        var i = this.texturePool.pop();
        if (!i) {
          i = new b.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
        }
        i.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
        a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer);
        a.clear(a.COLOR_BUFFER_BIT);
        a.disable(a.BLEND);
        for (var j = 0; j < c.filterPasses.length - 1; j++) {
          var k = c.filterPasses[j];
          a.bindFramebuffer(a.FRAMEBUFFER, i.frameBuffer);
          a.activeTexture(a.TEXTURE0);
          a.bindTexture(a.TEXTURE_2D, h.texture);
          this.applyFilterPass(k, d, d.width, d.height);
          var l = h;
          h = i;
          i = h;
        }
        a.enable(a.BLEND);
        e = h;
        this.texturePool.push(i);
      }
      var m = c.filterPasses[c.filterPasses.length - 1];
      this.offsetX -= d.x;
      this.offsetY -= d.y;
      var n = this.width;
      var o = this.height;
      var p = 0;
      var q = 0;
      var r = this.buffer;
      if (0 === this.filterStack.length) {
        a.colorMask(true, true, true, true);
      } else {
        var s = this.filterStack[this.filterStack.length - 1];
        d = s._filterArea;
        n = d.width;
        o = d.height;
        p = d.x;
        q = d.y;
        r = s._glFilterTexture.frameBuffer;
      }
      f.x = n / 2;
      f.y = -o / 2;
      g.x = p;
      g.y = q;
      d = c._filterArea;
      var t = d.x - p;
      var u = d.y - q;
      a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
      this.vertexArray[0] = t;
      this.vertexArray[1] = u + d.height;
      this.vertexArray[2] = t + d.width;
      this.vertexArray[3] = u + d.height;
      this.vertexArray[4] = t;
      this.vertexArray[5] = u;
      this.vertexArray[6] = t + d.width;
      this.vertexArray[7] = u;
      a.bufferSubData(a.ARRAY_BUFFER, 0, this.vertexArray);
      a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
      this.uvArray[2] = d.width / this.width;
      this.uvArray[5] = d.height / this.height;
      this.uvArray[6] = d.width / this.width;
      this.uvArray[7] = d.height / this.height;
      a.bufferSubData(a.ARRAY_BUFFER, 0, this.uvArray);
      a.viewport(0, 0, n * this.renderSession.resolution, o * this.renderSession.resolution);
      a.bindFramebuffer(a.FRAMEBUFFER, r);
      a.activeTexture(a.TEXTURE0);
      a.bindTexture(a.TEXTURE_2D, e.texture);
      if (this.renderSession.stencilManager) {
        this.renderSession.stencilManager.destroy();
      }
      this.renderSession.stencilManager = c._previous_stencil_mgr;
      c._previous_stencil_mgr = null;
      if (this.renderSession.stencilManager.count > 0) {
        a.enable(a.STENCIL_TEST);
      } else {
        a.disable(a.STENCIL_TEST);
      }
      this.applyFilterPass(m, d, n, o);
      this.texturePool.push(e);
      c._glFilterTexture = null;
    };
    b.WebGLFilterManager.prototype.applyFilterPass = function (a, c, d, e) {
      var f = this.gl;
      var g = a.shaders[f.id];
      if (!g) {
        g = new b.PixiShader(f);
        g.fragmentSrc = a.fragmentSrc;
        g.uniforms = a.uniforms;
        g.init();
        a.shaders[f.id] = g;
      }
      this.renderSession.shaderManager.setShader(g);
      f.uniform2f(g.projectionVector, d / 2, -e / 2);
      f.uniform2f(g.offsetVector, 0, 0);
      if (a.uniforms.dimensions) {
        a.uniforms.dimensions.value[0] = this.width;
        a.uniforms.dimensions.value[1] = this.height;
        a.uniforms.dimensions.value[2] = this.vertexArray[0];
        a.uniforms.dimensions.value[3] = this.vertexArray[5];
      }
      g.syncUniforms();
      f.bindBuffer(f.ARRAY_BUFFER, this.vertexBuffer);
      f.vertexAttribPointer(g.aVertexPosition, 2, f.FLOAT, false, 0, 0);
      f.bindBuffer(f.ARRAY_BUFFER, this.uvBuffer);
      f.vertexAttribPointer(g.aTextureCoord, 2, f.FLOAT, false, 0, 0);
      f.bindBuffer(f.ARRAY_BUFFER, this.colorBuffer);
      f.vertexAttribPointer(g.colorAttribute, 2, f.FLOAT, false, 0, 0);
      f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0);
      this.renderSession.drawCount++;
    };
    b.WebGLFilterManager.prototype.initShaderBuffers = function () {
      var a = this.gl;
      this.vertexBuffer = a.createBuffer();
      this.uvBuffer = a.createBuffer();
      this.colorBuffer = a.createBuffer();
      this.indexBuffer = a.createBuffer();
      this.vertexArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
      a.bufferData(a.ARRAY_BUFFER, this.vertexArray, a.STATIC_DRAW);
      this.uvArray = new b.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer);
      a.bufferData(a.ARRAY_BUFFER, this.uvArray, a.STATIC_DRAW);
      this.colorArray = new b.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]);
      a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer);
      a.bufferData(a.ARRAY_BUFFER, this.colorArray, a.STATIC_DRAW);
      a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      a.bufferData(a.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), a.STATIC_DRAW);
    };
    b.WebGLFilterManager.prototype.destroy = function () {
      var a = this.gl;
      this.filterStack = null;
      this.offsetX = 0;
      this.offsetY = 0;
      for (var b = 0; b < this.texturePool.length; b++) {
        this.texturePool[b].destroy();
      }
      this.texturePool = null;
      a.deleteBuffer(this.vertexBuffer);
      a.deleteBuffer(this.uvBuffer);
      a.deleteBuffer(this.colorBuffer);
      a.deleteBuffer(this.indexBuffer);
    };
    b.FilterTexture = function (a, c, d, e) {
      this.gl = a;
      this.frameBuffer = a.createFramebuffer();
      this.texture = a.createTexture();
      e = e || b.scaleModes.DEFAULT;
      a.bindTexture(a.TEXTURE_2D, this.texture);
      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST);
      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e === b.scaleModes.LINEAR ? a.LINEAR : a.NEAREST);
      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
      a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
      a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer);
      a.bindFramebuffer(a.FRAMEBUFFER, this.frameBuffer);
      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0);
      this.renderBuffer = a.createRenderbuffer();
      a.bindRenderbuffer(a.RENDERBUFFER, this.renderBuffer);
      a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this.renderBuffer);
      this.resize(c, d);
    };
    b.FilterTexture.prototype.constructor = b.FilterTexture;
    b.FilterTexture.prototype.clear = function () {
      var a = this.gl;
      a.clearColor(0, 0, 0, 0);
      a.clear(a.COLOR_BUFFER_BIT);
    };
    b.FilterTexture.prototype.resize = function (a, b) {
      if (this.width !== a || this.height !== b) {
        this.width = a;
        this.height = b;
        var c = this.gl;
        c.bindTexture(c.TEXTURE_2D, this.texture);
        c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, a, b, 0, c.RGBA, c.UNSIGNED_BYTE, null);
        c.bindRenderbuffer(c.RENDERBUFFER, this.renderBuffer);
        c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, a, b);
      }
    };
    b.FilterTexture.prototype.destroy = function () {
      var a = this.gl;
      a.deleteFramebuffer(this.frameBuffer);
      a.deleteTexture(this.texture);
      this.frameBuffer = null;
      this.texture = null;
    };
    b.CanvasBuffer = function (a, c) {
      this.width = a;
      this.height = c;
      this.canvas = b.CanvasPool.create(this, this.width, this.height);
      this.context = this.canvas.getContext("2d");
      this.canvas.width = a;
      this.canvas.height = c;
    };
    b.CanvasBuffer.prototype.constructor = b.CanvasBuffer;
    b.CanvasBuffer.prototype.clear = function () {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.clearRect(0, 0, this.width, this.height);
    };
    b.CanvasBuffer.prototype.resize = function (a, b) {
      this.width = this.canvas.width = a;
      this.height = this.canvas.height = b;
    };
    b.CanvasBuffer.prototype.destroy = function () {
      b.CanvasPool.remove(this);
    };
    b.CanvasMaskManager = function () {};
    b.CanvasMaskManager.prototype.constructor = b.CanvasMaskManager;
    b.CanvasMaskManager.prototype.pushMask = function (a, c) {
      var d = c.context;
      d.save();
      var e = a.alpha;
      var f = a.worldTransform;
      var g = c.resolution;
      d.setTransform(f.a * g, f.b * g, f.c * g, f.d * g, f.tx * g, f.ty * g);
      b.CanvasGraphics.renderGraphicsMask(a, d);
      d.clip();
      a.worldAlpha = e;
    };
    b.CanvasMaskManager.prototype.popMask = function (a) {
      a.context.restore();
    };
    b.CanvasTinter = function () {};
    b.CanvasTinter.getTintedTexture = function (a, c) {
      var d = a.tintedTexture || b.CanvasPool.create(this);
      b.CanvasTinter.tintMethod(a.texture, c, d);
      return d;
    };
    b.CanvasTinter.tintWithMultiply = function (a, b, c) {
      var d = c.getContext("2d");
      var e = a.crop;
      if (!(c.width === e.width && c.height === e.height)) {
        c.width = e.width;
        c.height = e.height;
      }
      d.clearRect(0, 0, e.width, e.height);
      d.fillStyle = "#" + ("00000" + (0 | b).toString(16)).substr(-6);
      d.fillRect(0, 0, e.width, e.height);
      d.globalCompositeOperation = "multiply";
      d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
      d.globalCompositeOperation = "destination-atop";
      d.drawImage(a.baseTexture.source, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
    };
    b.CanvasTinter.tintWithPerPixel = function (a, c, d) {
      var e = d.getContext("2d");
      var f = a.crop;
      d.width = f.width;
      d.height = f.height;
      e.globalCompositeOperation = "copy";
      e.drawImage(a.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
      var g = b.hex2rgb(c);
      var h = g[0];
      var i = g[1];
      var j = g[2];
      var k = e.getImageData(0, 0, f.width, f.height);
      var l = k.data;
      for (var m = 0; m < l.length; m += 4) {
        l[m + 0] *= h;
        l[m + 1] *= i;
        l[m + 2] *= j;
        if (!b.CanvasTinter.canHandleAlpha) {
          var n = l[m + 3];
          l[m + 0] /= 255 / n;
          l[m + 1] /= 255 / n;
          l[m + 2] /= 255 / n;
        }
      }
      e.putImageData(k, 0, 0);
    };
    b.CanvasTinter.checkInverseAlpha = function () {
      var a = new b.CanvasBuffer(2, 1);
      a.context.fillStyle = "rgba(10, 20, 30, 0.5)";
      a.context.fillRect(0, 0, 1, 1);
      var c = a.context.getImageData(0, 0, 1, 1);
      if (null === c) {
        return false;
      }
      a.context.putImageData(c, 1, 0);
      var d = a.context.getImageData(1, 0, 1, 1);
      return d.data[0] === c.data[0] && d.data[1] === c.data[1] && d.data[2] === c.data[2] && d.data[3] === c.data[3];
    };
    b.CanvasTinter.canHandleAlpha = b.CanvasTinter.checkInverseAlpha();
    b.CanvasTinter.canUseMultiply = b.canUseNewCanvasBlendModes();
    b.CanvasTinter.tintMethod = b.CanvasTinter.canUseMultiply ? b.CanvasTinter.tintWithMultiply : b.CanvasTinter.tintWithPerPixel;
    b.CanvasRenderer = function (a) {
      this.game = a;
      if (!b.defaultRenderer) {
        b.defaultRenderer = this;
      }
      this.type = b.CANVAS_RENDERER;
      this.resolution = a.resolution;
      this.clearBeforeRender = a.clearBeforeRender;
      this.transparent = a.transparent;
      this.autoResize = false;
      this.width = a.width * this.resolution;
      this.height = a.height * this.resolution;
      this.view = a.canvas;
      this.context = this.view.getContext("2d", {
        alpha: this.transparent
      });
      this.refresh = true;
      this.count = 0;
      this.maskManager = new b.CanvasMaskManager();
      this.renderSession = {
        context: this.context,
        maskManager: this.maskManager,
        scaleMode: null,
        smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
        roundPixels: false
      };
      this.mapBlendModes();
      this.resize(this.width, this.height);
    };
    b.CanvasRenderer.prototype.constructor = b.CanvasRenderer;
    b.CanvasRenderer.prototype.render = function (a) {
      this.context.setTransform(1, 0, 0, 1, 0, 0);
      this.context.globalAlpha = 1;
      this.renderSession.currentBlendMode = 0;
      this.renderSession.shakeX = this.game.camera._shake.x;
      this.renderSession.shakeY = this.game.camera._shake.y;
      this.context.globalCompositeOperation = "source-over";
      if (navigator.isCocoonJS && this.view.screencanvas) {
        this.context.fillStyle = "black";
        this.context.clear();
      }
      if (this.clearBeforeRender) {
        if (this.transparent) {
          this.context.clearRect(0, 0, this.width, this.height);
        } else if (a._bgColor) {
          this.context.fillStyle = a._bgColor.rgba;
          this.context.fillRect(0, 0, this.width, this.height);
        }
      }
      this.renderDisplayObject(a);
    };
    b.CanvasRenderer.prototype.destroy = function (a) {
      if (undefined === a) {
        a = true;
      }
      if (a && this.view.parent) {
        this.view.parent.removeChild(this.view);
      }
      this.view = null;
      this.context = null;
      this.maskManager = null;
      this.renderSession = null;
    };
    b.CanvasRenderer.prototype.resize = function (a, c) {
      this.width = a * this.resolution;
      this.height = c * this.resolution;
      this.view.width = this.width;
      this.view.height = this.height;
      if (this.autoResize) {
        this.view.style.width = this.width / this.resolution + "px";
        this.view.style.height = this.height / this.resolution + "px";
      }
      if (this.renderSession.smoothProperty) {
        this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === b.scaleModes.LINEAR;
      }
    };
    b.CanvasRenderer.prototype.renderDisplayObject = function (a, b, c) {
      this.renderSession.context = b || this.context;
      this.renderSession.resolution = this.resolution;
      a._renderCanvas(this.renderSession, c);
    };
    b.CanvasRenderer.prototype.mapBlendModes = function () {
      if (!b.blendModesCanvas) {
        var a = [];
        var c = b.blendModes;
        var d = b.canUseNewCanvasBlendModes();
        a[c.NORMAL] = "source-over";
        a[c.ADD] = "lighter";
        a[c.MULTIPLY] = d ? "multiply" : "source-over";
        a[c.SCREEN] = d ? "screen" : "source-over";
        a[c.OVERLAY] = d ? "overlay" : "source-over";
        a[c.DARKEN] = d ? "darken" : "source-over";
        a[c.LIGHTEN] = d ? "lighten" : "source-over";
        a[c.COLOR_DODGE] = d ? "color-dodge" : "source-over";
        a[c.COLOR_BURN] = d ? "color-burn" : "source-over";
        a[c.HARD_LIGHT] = d ? "hard-light" : "source-over";
        a[c.SOFT_LIGHT] = d ? "soft-light" : "source-over";
        a[c.DIFFERENCE] = d ? "difference" : "source-over";
        a[c.EXCLUSION] = d ? "exclusion" : "source-over";
        a[c.HUE] = d ? "hue" : "source-over";
        a[c.SATURATION] = d ? "saturation" : "source-over";
        a[c.COLOR] = d ? "color" : "source-over";
        a[c.LUMINOSITY] = d ? "luminosity" : "source-over";
        b.blendModesCanvas = a;
      }
    };
    b.BaseTexture = function (a, c) {
      this.resolution = 1;
      this.width = 100;
      this.height = 100;
      this.scaleMode = c || b.scaleModes.DEFAULT;
      this.hasLoaded = false;
      this.source = a;
      this.premultipliedAlpha = true;
      this._glTextures = [];
      this.mipmap = false;
      this._dirty = [true, true, true, true];
      if (a) {
        if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {
          this.hasLoaded = true;
          this.width = this.source.naturalWidth || this.source.width;
          this.height = this.source.naturalHeight || this.source.height;
          this.dirty();
        }
        this.skipRender = false;
        this._powerOf2 = false;
      }
    };
    b.BaseTexture.prototype.constructor = b.BaseTexture;
    b.BaseTexture.prototype.forceLoaded = function (a, b) {
      this.hasLoaded = true;
      this.width = a;
      this.height = b;
      this.dirty();
    };
    b.BaseTexture.prototype.destroy = function () {
      if (this.source) {
        b.CanvasPool.removeByCanvas(this.source);
      }
      this.source = null;
      this.unloadFromGPU();
    };
    b.BaseTexture.prototype.updateSourceImage = function (a) {
      console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.");
    };
    b.BaseTexture.prototype.dirty = function () {
      for (var a = 0; a < this._glTextures.length; a++) {
        this._dirty[a] = true;
      }
    };
    b.BaseTexture.prototype.unloadFromGPU = function () {
      this.dirty();
      for (var a = this._glTextures.length - 1; a >= 0; a--) {
        var c = this._glTextures[a];
        var d = b.glContexts[a];
        if (d && c) {
          d.deleteTexture(c);
        }
      }
      this._glTextures.length = 0;
      this.dirty();
    };
    b.BaseTexture.fromCanvas = function (a, c) {
      if (0 === a.width) {
        a.width = 1;
      }
      if (0 === a.height) {
        a.height = 1;
      }
      return new b.BaseTexture(a, c);
    };
    b.TextureSilentFail = false;
    b.Texture = function (a, c, d, e) {
      this.noFrame = false;
      if (!c) {
        this.noFrame = true;
        c = new b.Rectangle(0, 0, 1, 1);
      }
      if (a instanceof b.Texture) {
        a = a.baseTexture;
      }
      this.baseTexture = a;
      this.frame = c;
      this.trim = e;
      this.valid = false;
      this.isTiling = false;
      this.requiresUpdate = false;
      this.requiresReTint = false;
      this._uvs = null;
      this.width = 0;
      this.height = 0;
      this.crop = d || new b.Rectangle(0, 0, 1, 1);
      if (a.hasLoaded) {
        if (this.noFrame) {
          c = new b.Rectangle(0, 0, a.width, a.height);
        }
        this.setFrame(c);
      }
    };
    b.Texture.prototype.constructor = b.Texture;
    b.Texture.prototype.onBaseTextureLoaded = function () {
      var a = this.baseTexture;
      if (this.noFrame) {
        this.frame = new b.Rectangle(0, 0, a.width, a.height);
      }
      this.setFrame(this.frame);
    };
    b.Texture.prototype.destroy = function (a) {
      if (a) {
        this.baseTexture.destroy();
      }
      this.valid = false;
    };
    b.Texture.prototype.setFrame = function (a) {
      this.noFrame = false;
      this.frame = a;
      this.width = a.width;
      this.height = a.height;
      this.crop.x = a.x;
      this.crop.y = a.y;
      this.crop.width = a.width;
      this.crop.height = a.height;
      if (!this.trim && (a.x + a.width > this.baseTexture.width || a.y + a.height > this.baseTexture.height)) {
        if (!b.TextureSilentFail) {
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
        }
        return void (this.valid = false);
      }
      this.valid = a && a.width && a.height && this.baseTexture.source && this.baseTexture.hasLoaded;
      if (this.trim) {
        this.width = this.trim.width;
        this.height = this.trim.height;
        this.frame.width = this.trim.width;
        this.frame.height = this.trim.height;
      }
      if (this.valid) {
        this._updateUvs();
      }
    };
    b.Texture.prototype._updateUvs = function () {
      if (!this._uvs) {
        this._uvs = new b.TextureUvs();
      }
      var a = this.crop;
      var c = this.baseTexture.width;
      var d = this.baseTexture.height;
      this._uvs.x0 = a.x / c;
      this._uvs.y0 = a.y / d;
      this._uvs.x1 = (a.x + a.width) / c;
      this._uvs.y1 = a.y / d;
      this._uvs.x2 = (a.x + a.width) / c;
      this._uvs.y2 = (a.y + a.height) / d;
      this._uvs.x3 = a.x / c;
      this._uvs.y3 = (a.y + a.height) / d;
    };
    b.Texture.fromCanvas = function (a, c) {
      var d = b.BaseTexture.fromCanvas(a, c);
      return new b.Texture(d);
    };
    b.TextureUvs = function () {
      this.x0 = 0;
      this.y0 = 0;
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.x3 = 0;
      this.y3 = 0;
    };
    b.RenderTexture = function (a, c, d, e, f) {
      this.width = a || 100;
      this.height = c || 100;
      this.resolution = f || 1;
      this.frame = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);
      this.crop = new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);
      this.baseTexture = new b.BaseTexture();
      this.baseTexture.width = this.width * this.resolution;
      this.baseTexture.height = this.height * this.resolution;
      this.baseTexture._glTextures = [];
      this.baseTexture.resolution = this.resolution;
      this.baseTexture.scaleMode = e || b.scaleModes.DEFAULT;
      this.baseTexture.hasLoaded = true;
      b.Texture.call(this, this.baseTexture, new b.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution));
      this.renderer = d || b.defaultRenderer;
      if (this.renderer.type === b.WEBGL_RENDERER) {
        var g = this.renderer.gl;
        this.baseTexture._dirty[g.id] = false;
        this.textureBuffer = new b.FilterTexture(g, this.width, this.height, this.baseTexture.scaleMode);
        this.baseTexture._glTextures[g.id] = this.textureBuffer.texture;
        this.render = this.renderWebGL;
        this.projection = new b.Point(.5 * this.width, .5 * -this.height);
      } else {
        this.render = this.renderCanvas;
        this.textureBuffer = new b.CanvasBuffer(this.width * this.resolution, this.height * this.resolution);
        this.baseTexture.source = this.textureBuffer.canvas;
      }
      this.valid = true;
      this.tempMatrix = new Phaser.Matrix();
      this._updateUvs();
    };
    b.RenderTexture.prototype = Object.create(b.Texture.prototype);
    b.RenderTexture.prototype.constructor = b.RenderTexture;
    b.RenderTexture.prototype.resize = function (a, c, d) {
      if (!(a === this.width && c === this.height)) {
        this.valid = a > 0 && c > 0;
        this.width = a;
        this.height = c;
        this.frame.width = this.crop.width = a * this.resolution;
        this.frame.height = this.crop.height = c * this.resolution;
        if (d) {
          this.baseTexture.width = this.width * this.resolution;
          this.baseTexture.height = this.height * this.resolution;
        }
        if (this.renderer.type === b.WEBGL_RENDERER) {
          this.projection.x = this.width / 2;
          this.projection.y = -this.height / 2;
        }
        if (this.valid) {
          this.textureBuffer.resize(this.width, this.height);
        }
      }
    };
    b.RenderTexture.prototype.clear = function () {
      if (this.valid) {
        if (this.renderer.type === b.WEBGL_RENDERER) {
          this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        }
        this.textureBuffer.clear();
      }
    };
    b.RenderTexture.prototype.renderWebGL = function (a, b, c) {
      if (this.valid && 0 !== a.alpha) {
        var d = a.worldTransform;
        d.identity();
        d.translate(0, 2 * this.projection.y);
        if (b) {
          d.append(b);
        }
        d.scale(1, -1);
        for (var e = 0; e < a.children.length; e++) {
          a.children[e].updateTransform();
        }
        var f = this.renderer.gl;
        f.viewport(0, 0, this.width * this.resolution, this.height * this.resolution);
        f.bindFramebuffer(f.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        if (c) {
          this.textureBuffer.clear();
        }
        this.renderer.spriteBatch.dirty = true;
        this.renderer.renderDisplayObject(a, this.projection, this.textureBuffer.frameBuffer, b);
        this.renderer.spriteBatch.dirty = true;
      }
    };
    b.RenderTexture.prototype.renderCanvas = function (a, b, c) {
      if (this.valid && 0 !== a.alpha) {
        var d = a.worldTransform;
        d.identity();
        if (b) {
          d.append(b);
        }
        for (var e = 0; e < a.children.length; e++) {
          a.children[e].updateTransform();
        }
        if (c) {
          this.textureBuffer.clear();
        }
        var f = this.renderer.resolution;
        this.renderer.resolution = this.resolution;
        this.renderer.renderDisplayObject(a, this.textureBuffer.context, b);
        this.renderer.resolution = f;
      }
    };
    b.RenderTexture.prototype.getImage = function () {
      var a = new Image();
      a.src = this.getBase64();
      return a;
    };
    b.RenderTexture.prototype.getBase64 = function () {
      return this.getCanvas().toDataURL();
    };
    b.RenderTexture.prototype.getCanvas = function () {
      if (this.renderer.type === b.WEBGL_RENDERER) {
        var a = this.renderer.gl;
        var c = this.textureBuffer.width;
        var d = this.textureBuffer.height;
        var e = new Uint8Array(4 * c * d);
        a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer);
        a.readPixels(0, 0, c, d, a.RGBA, a.UNSIGNED_BYTE, e);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        var f = new b.CanvasBuffer(c, d);
        var g = f.context.getImageData(0, 0, c, d);
        g.data.set(e);
        f.context.putImageData(g, 0, 0);
        return f.canvas;
      }
      return this.textureBuffer.canvas;
    };
    b.AbstractFilter = function (a, b) {
      this.passes = [this];
      this.shaders = [];
      this.dirty = true;
      this.padding = 0;
      this.uniforms = b || {};
      this.fragmentSrc = a || [];
    };
    b.AbstractFilter.prototype.constructor = b.AbstractFilter;
    b.AbstractFilter.prototype.syncUniforms = function () {
      var a = 0;
      for (var b = this.shaders.length; a < b; a++) {
        this.shaders[a].dirty = true;
      }
    };
    b.Strip = function (a) {
      b.DisplayObjectContainer.call(this);
      this.texture = a;
      this.uvs = new b.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]);
      this.vertices = new b.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
      this.colors = new b.Float32Array([1, 1, 1, 1]);
      this.indices = new b.Uint16Array([0, 1, 2, 3]);
      this.dirty = true;
      this.blendMode = b.blendModes.NORMAL;
      this.canvasPadding = 0;
      this.drawMode = b.Strip.DrawModes.TRIANGLE_STRIP;
    };
    b.Strip.prototype = Object.create(b.DisplayObjectContainer.prototype);
    b.Strip.prototype.constructor = b.Strip;
    b.Strip.prototype._renderWebGL = function (a) {
      if (!(!this.visible || this.alpha <= 0)) {
        a.spriteBatch.stop();
        if (!this._vertexBuffer) {
          this._initWebGL(a);
        }
        a.shaderManager.setShader(a.shaderManager.stripShader);
        this._renderStrip(a);
        a.spriteBatch.start();
      }
    };
    b.Strip.prototype._initWebGL = function (a) {
      var b = a.gl;
      this._vertexBuffer = b.createBuffer();
      this._indexBuffer = b.createBuffer();
      this._uvBuffer = b.createBuffer();
      this._colorBuffer = b.createBuffer();
      b.bindBuffer(b.ARRAY_BUFFER, this._vertexBuffer);
      b.bufferData(b.ARRAY_BUFFER, this.vertices, b.DYNAMIC_DRAW);
      b.bindBuffer(b.ARRAY_BUFFER, this._uvBuffer);
      b.bufferData(b.ARRAY_BUFFER, this.uvs, b.STATIC_DRAW);
      b.bindBuffer(b.ARRAY_BUFFER, this._colorBuffer);
      b.bufferData(b.ARRAY_BUFFER, this.colors, b.STATIC_DRAW);
      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      b.bufferData(b.ELEMENT_ARRAY_BUFFER, this.indices, b.STATIC_DRAW);
    };
    b.Strip.prototype._renderStrip = function (a) {
      var c = a.gl;
      var d = a.projection;
      var e = a.offset;
      var f = a.shaderManager.stripShader;
      var g = this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP ? c.TRIANGLE_STRIP : c.TRIANGLES;
      a.blendModeManager.setBlendMode(this.blendMode);
      c.uniformMatrix3fv(f.translationMatrix, false, this.worldTransform.toArray(true));
      c.uniform2f(f.projectionVector, d.x, -d.y);
      c.uniform2f(f.offsetVector, -e.x, -e.y);
      c.uniform1f(f.alpha, this.worldAlpha);
      if (this.dirty) {
        this.dirty = false;
        c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer);
        c.bufferData(c.ARRAY_BUFFER, this.vertices, c.STATIC_DRAW);
        c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, false, 0, 0);
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer);
        c.bufferData(c.ARRAY_BUFFER, this.uvs, c.STATIC_DRAW);
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, false, 0, 0);
        c.activeTexture(c.TEXTURE0);
        if (this.texture.baseTexture._dirty[c.id]) {
          a.renderer.updateTexture(this.texture.baseTexture);
        } else {
          c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]);
        }
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        c.bufferData(c.ELEMENT_ARRAY_BUFFER, this.indices, c.STATIC_DRAW);
      } else {
        c.bindBuffer(c.ARRAY_BUFFER, this._vertexBuffer);
        c.bufferSubData(c.ARRAY_BUFFER, 0, this.vertices);
        c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, false, 0, 0);
        c.bindBuffer(c.ARRAY_BUFFER, this._uvBuffer);
        c.vertexAttribPointer(f.aTextureCoord, 2, c.FLOAT, false, 0, 0);
        c.activeTexture(c.TEXTURE0);
        if (this.texture.baseTexture._dirty[c.id]) {
          a.renderer.updateTexture(this.texture.baseTexture);
        } else {
          c.bindTexture(c.TEXTURE_2D, this.texture.baseTexture._glTextures[c.id]);
        }
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
      }
      c.drawElements(g, this.indices.length, c.UNSIGNED_SHORT, 0);
    };
    b.Strip.prototype._renderCanvas = function (a) {
      var c = a.context;
      var d = this.worldTransform;
      var e = d.tx * a.resolution + a.shakeX;
      var f = d.ty * a.resolution + a.shakeY;
      if (a.roundPixels) {
        c.setTransform(d.a, d.b, d.c, d.d, 0 | e, 0 | f);
      } else {
        c.setTransform(d.a, d.b, d.c, d.d, e, f);
      }
      if (this.drawMode === b.Strip.DrawModes.TRIANGLE_STRIP) {
        this._renderCanvasTriangleStrip(c);
      } else {
        this._renderCanvasTriangles(c);
      }
    };
    b.Strip.prototype._renderCanvasTriangleStrip = function (a) {
      var b = this.vertices;
      var c = this.uvs;
      var d = b.length / 2;
      this.count++;
      for (var e = 0; e < d - 2; e++) {
        var f = 2 * e;
        this._renderCanvasDrawTriangle(a, b, c, f, f + 2, f + 4);
      }
    };
    b.Strip.prototype._renderCanvasTriangles = function (a) {
      var b = this.vertices;
      var c = this.uvs;
      var d = this.indices;
      var e = d.length;
      this.count++;
      for (var f = 0; f < e; f += 3) {
        var g = 2 * d[f];
        var h = 2 * d[f + 1];
        var i = 2 * d[f + 2];
        this._renderCanvasDrawTriangle(a, b, c, g, h, i);
      }
    };
    b.Strip.prototype._renderCanvasDrawTriangle = function (a, b, c, d, e, f) {
      var g = this.texture.baseTexture.source;
      var h = this.texture.width;
      var i = this.texture.height;
      var j = b[d];
      var k = b[e];
      var l = b[f];
      var m = b[d + 1];
      var n = b[e + 1];
      var o = b[f + 1];
      var p = c[d] * h;
      var q = c[e] * h;
      var r = c[f] * h;
      var s = c[d + 1] * i;
      var t = c[e + 1] * i;
      var u = c[f + 1] * i;
      if (this.canvasPadding > 0) {
        var v = this.canvasPadding / this.worldTransform.a;
        var w = this.canvasPadding / this.worldTransform.d;
        var x = (j + k + l) / 3;
        var y = (m + n + o) / 3;
        var z = j - x;
        var A = m - y;
        var B = Math.sqrt(z * z + A * A);
        j = x + z / B * (B + v);
        m = y + A / B * (B + w);
        z = k - x;
        A = n - y;
        B = Math.sqrt(z * z + A * A);
        k = x + z / B * (B + v);
        n = y + A / B * (B + w);
        z = l - x;
        A = o - y;
        B = Math.sqrt(z * z + A * A);
        l = x + z / B * (B + v);
        o = y + A / B * (B + w);
      }
      a.save();
      a.beginPath();
      a.moveTo(j, m);
      a.lineTo(k, n);
      a.lineTo(l, o);
      a.closePath();
      a.clip();
      var C = p * t + s * r + q * u - t * r - s * q - p * u;
      var D = j * t + s * l + k * u - t * l - s * k - j * u;
      var E = p * k + j * r + q * l - k * r - j * q - p * l;
      var F = p * t * l + s * k * r + j * q * u - j * t * r - s * q * l - p * k * u;
      var G = m * t + s * o + n * u - t * o - s * n - m * u;
      var H = p * n + m * r + q * o - n * r - m * q - p * o;
      var I = p * t * o + s * n * r + m * q * u - m * t * r - s * q * o - p * n * u;
      a.transform(D / C, G / C, E / C, H / C, F / C, I / C);
      a.drawImage(g, 0, 0);
      a.restore();
    };
    b.Strip.prototype.renderStripFlat = function (a) {
      var b = this.context;
      var c = a.vertices;
      var d = c.length / 2;
      this.count++;
      b.beginPath();
      for (var e = 1; e < d - 2; e++) {
        var f = 2 * e;
        var g = c[f];
        var h = c[f + 2];
        var i = c[f + 4];
        var j = c[f + 1];
        var k = c[f + 3];
        var l = c[f + 5];
        b.moveTo(g, j);
        b.lineTo(h, k);
        b.lineTo(i, l);
      }
      b.fillStyle = "#FF0000";
      b.fill();
      b.closePath();
    };
    b.Strip.prototype.onTextureUpdate = function () {
      this.updateFrame = true;
    };
    b.Strip.prototype.getBounds = function (a) {
      var c = a || this.worldTransform;
      var d = c.a;
      var e = c.b;
      var f = c.c;
      var g = c.d;
      var h = c.tx;
      var i = c.ty;
      var j = -Infinity;
      var k = -Infinity;
      var l = Infinity;
      var m = Infinity;
      var n = this.vertices;
      var o = 0;
      for (var p = n.length; o < p; o += 2) {
        var q = n[o];
        var r = n[o + 1];
        var s = d * q + f * r + h;
        var t = g * r + e * q + i;
        l = s < l ? s : l;
        m = t < m ? t : m;
        j = s > j ? s : j;
        k = t > k ? t : k;
      }
      if (l === -Infinity || k === Infinity) {
        return b.EmptyRectangle;
      }
      var u = this._bounds;
      u.x = l;
      u.width = j - l;
      u.y = m;
      u.height = k - m;
      this._currentBounds = u;
      return u;
    };
    b.Strip.DrawModes = {
      TRIANGLE_STRIP: 0,
      TRIANGLES: 1
    };
    b.Rope = function (a, c) {
      b.Strip.call(this, a);
      this.points = c;
      this.vertices = new b.Float32Array(4 * c.length);
      this.uvs = new b.Float32Array(4 * c.length);
      this.colors = new b.Float32Array(2 * c.length);
      this.indices = new b.Uint16Array(2 * c.length);
      this.refresh();
    };
    b.Rope.prototype = Object.create(b.Strip.prototype);
    b.Rope.prototype.constructor = b.Rope;
    b.Rope.prototype.refresh = function () {
      var a = this.points;
      if (!(a.length < 1)) {
        var b = this.uvs;
        a[0];
        var d = this.indices;
        var e = this.colors;
        this.count -= .2;
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        b[3] = 1;
        e[0] = 1;
        e[1] = 1;
        d[0] = 0;
        d[1] = 1;
        var g;
        var h;
        var i;
        var f = a.length;
        for (var j = 1; j < f; j++) {
          g = a[j];
          h = 4 * j;
          i = j / (f - 1);
          b[h] = i;
          b[h + 1] = 0;
          b[h + 2] = i;
          b[h + 3] = 1;
          h = 2 * j;
          e[h] = 1;
          e[h + 1] = 1;
          h = 2 * j;
          d[h] = h;
          d[h + 1] = h + 1;
          g;
        }
      }
    };
    b.Rope.prototype.updateTransform = function () {
      var a = this.points;
      if (!(a.length < 1)) {
        var d;
        var c = a[0];
        var e = {
          x: 0,
          y: 0
        };
        this.count -= .2;
        var h;
        var i;
        var j;
        var k;
        var l;
        var f = this.vertices;
        var g = a.length;
        for (var m = 0; m < g; m++) {
          h = a[m];
          i = 4 * m;
          d = m < a.length - 1 ? a[m + 1] : h;
          e.y = -(d.x - c.x);
          e.x = d.y - c.y;
          j = 10 * (1 - m / (g - 1));
          if (j > 1) {
            j = 1;
          }
          k = Math.sqrt(0);
          l = this.texture.height / 2;
          e.x /= k;
          e.y /= k;
          e.x *= l;
          e.y *= l;
          f[i] = h.x + 0;
          f[i + 1] = h.y + 0;
          f[i + 2] = h.x - 0;
          f[i + 3] = h.y - 0;
          c = h;
        }
        b.DisplayObjectContainer.prototype.updateTransform.call(this);
      }
    };
    b.Rope.prototype.setTexture = function (a) {
      this.texture = a;
    };
    b.TilingSprite = function (a, c, d) {
      b.Sprite.call(this, a);
      this._width = c || 128;
      this._height = d || 128;
      this.tileScale = new b.Point(1, 1);
      this.tileScaleOffset = new b.Point(1, 1);
      this.tilePosition = new b.Point();
      this.renderable = true;
      this.tint = 16777215;
      this.textureDebug = false;
      this.blendMode = b.blendModes.NORMAL;
      this.canvasBuffer = null;
      this.tilingTexture = null;
      this.tilePattern = null;
      this.refreshTexture = true;
      this.frameWidth = 0;
      this.frameHeight = 0;
    };
    b.TilingSprite.prototype = Object.create(b.Sprite.prototype);
    b.TilingSprite.prototype.constructor = b.TilingSprite;
    b.TilingSprite.prototype.setTexture = function (a) {
      if (this.texture !== a) {
        this.texture = a;
        this.refreshTexture = true;
        this.cachedTint = 16777215;
      }
    };
    b.TilingSprite.prototype._renderWebGL = function (a) {
      if (this.visible && this.renderable && 0 !== this.alpha) {
        if (this._mask) {
          a.spriteBatch.stop();
          a.maskManager.pushMask(this.mask, a);
          a.spriteBatch.start();
        }
        if (this._filters) {
          a.spriteBatch.flush();
          a.filterManager.pushFilter(this._filterBlock);
        }
        if (this.refreshTexture) {
          this.generateTilingTexture(true, a);
          if (!this.tilingTexture) {
            return;
          }
          if (this.tilingTexture.needsUpdate) {
            a.renderer.updateTexture(this.tilingTexture.baseTexture);
            this.tilingTexture.needsUpdate = false;
          }
        }
        a.spriteBatch.renderTilingSprite(this);
        for (var b = 0; b < this.children.length; b++) {
          this.children[b]._renderWebGL(a);
        }
        a.spriteBatch.stop();
        if (this._filters) {
          a.filterManager.popFilter();
        }
        if (this._mask) {
          a.maskManager.popMask(this._mask, a);
        }
        a.spriteBatch.start();
      }
    };
    b.TilingSprite.prototype._renderCanvas = function (a) {
      if (this.visible && this.renderable && 0 !== this.alpha) {
        var c = a.context;
        if (this._mask) {
          a.maskManager.pushMask(this._mask, a);
        }
        c.globalAlpha = this.worldAlpha;
        var d = this.worldTransform;
        var e = a.resolution;
        var f = d.tx * e + a.shakeX;
        var g = d.ty * e + a.shakeY;
        c.setTransform(d.a * e, d.b * e, d.c * e, d.d * e, f, g);
        if (this.refreshTexture) {
          this.generateTilingTexture(false, a);
          if (!this.tilingTexture) {
            return;
          }
          this.tilePattern = c.createPattern(this.tilingTexture.baseTexture.source, "repeat");
        }
        var h = a.currentBlendMode;
        if (this.blendMode !== a.currentBlendMode) {
          a.currentBlendMode = this.blendMode;
          c.globalCompositeOperation = b.blendModesCanvas[a.currentBlendMode];
        }
        var i = this.tilePosition;
        var j = this.tileScale;
        i.x %= this.tilingTexture.baseTexture.width;
        i.y %= this.tilingTexture.baseTexture.height;
        c.scale(j.x, j.y);
        c.translate(i.x + this.anchor.x * -this._width, i.y + this.anchor.y * -this._height);
        c.fillStyle = this.tilePattern;
        var f = -i.x;
        var g = -i.y;
        var k = this._width / j.x;
        var l = this._height / j.y;
        if (a.roundPixels) {
          f |= 0;
          g |= 0;
          k |= 0;
          l |= 0;
        }
        c.fillRect(f, g, k, l);
        c.scale(1 / j.x, 1 / j.y);
        c.translate(-i.x + this.anchor.x * this._width, -i.y + this.anchor.y * this._height);
        if (this._mask) {
          a.maskManager.popMask(a);
        }
        for (var m = 0; m < this.children.length; m++) {
          this.children[m]._renderCanvas(a);
        }
        if (h !== this.blendMode) {
          a.currentBlendMode = h;
          c.globalCompositeOperation = b.blendModesCanvas[h];
        }
      }
    };
    b.TilingSprite.prototype.onTextureUpdate = function () {};
    b.TilingSprite.prototype.generateTilingTexture = function (a, c) {
      if (this.texture.baseTexture.hasLoaded) {
        var d = this.texture;
        var e = d.frame;
        var f = this._frame.sourceSizeW || this._frame.width;
        var g = this._frame.sourceSizeH || this._frame.height;
        var h = 0;
        var i = 0;
        if (this._frame.trimmed) {
          h = this._frame.spriteSourceSizeX;
          i = this._frame.spriteSourceSizeY;
        }
        if (a) {
          f = b.getNextPowerOfTwo(f);
          g = b.getNextPowerOfTwo(g);
        }
        if (this.canvasBuffer) {
          this.canvasBuffer.resize(f, g);
          this.tilingTexture.baseTexture.width = f;
          this.tilingTexture.baseTexture.height = g;
          this.tilingTexture.needsUpdate = true;
        } else {
          this.canvasBuffer = new b.CanvasBuffer(f, g);
          this.tilingTexture = b.Texture.fromCanvas(this.canvasBuffer.canvas);
          this.tilingTexture.isTiling = true;
          this.tilingTexture.needsUpdate = true;
        }
        if (this.textureDebug) {
          this.canvasBuffer.context.strokeStyle = "#00ff00";
          this.canvasBuffer.context.strokeRect(0, 0, f, g);
        }
        var j = d.crop.width;
        var k = d.crop.height;
        if (!(j === f && k === g)) {
          j = f;
          k = g;
        }
        this.canvasBuffer.context.drawImage(d.baseTexture.source, d.crop.x, d.crop.y, d.crop.width, d.crop.height, h, i, j, k);
        this.tileScaleOffset.x = e.width / f;
        this.tileScaleOffset.y = e.height / g;
        this.refreshTexture = false;
        this.tilingTexture.baseTexture._powerOf2 = true;
      }
    };
    b.TilingSprite.prototype.getBounds = function () {
      var a = this._width;
      var b = this._height;
      var c = a * (1 - this.anchor.x);
      var d = a * -this.anchor.x;
      var e = b * (1 - this.anchor.y);
      var f = b * -this.anchor.y;
      var g = this.worldTransform;
      var h = g.a;
      var i = g.b;
      var j = g.c;
      var k = g.d;
      var l = g.tx;
      var m = g.ty;
      var n = h * d + j * f + l;
      var o = k * f + i * d + m;
      var p = h * c + j * f + l;
      var q = k * f + i * c + m;
      var r = h * c + j * e + l;
      var s = k * e + i * c + m;
      var t = h * d + j * e + l;
      var u = k * e + i * d + m;
      var v = -Infinity;
      var w = -Infinity;
      var x = Infinity;
      var y = Infinity;
      x = n < x ? n : x;
      x = p < x ? p : x;
      x = r < x ? r : x;
      x = t < x ? t : x;
      y = o < y ? o : y;
      y = q < y ? q : y;
      y = s < y ? s : y;
      y = u < y ? u : y;
      v = n > v ? n : v;
      v = p > v ? p : v;
      v = r > v ? r : v;
      v = t > v ? t : v;
      w = o > w ? o : w;
      w = q > w ? q : w;
      w = s > w ? s : w;
      w = u > w ? u : w;
      var z = this._bounds;
      z.x = x;
      z.width = v - x;
      z.y = y;
      z.height = w - y;
      this._currentBounds = z;
      return z;
    };
    b.TilingSprite.prototype.destroy = function () {
      b.Sprite.prototype.destroy.call(this);
      if (this.canvasBuffer) {
        this.canvasBuffer.destroy();
        this.canvasBuffer = null;
      }
      this.tileScale = null;
      this.tileScaleOffset = null;
      this.tilePosition = null;
      if (this.tilingTexture) {
        this.tilingTexture.destroy(true);
        this.tilingTexture = null;
      }
    };
    Object.defineProperty(b.TilingSprite.prototype, "width", {
      get: function () {
        return this._width;
      },
      set: function (a) {
        this._width = a;
      }
    });
    Object.defineProperty(b.TilingSprite.prototype, "height", {
      get: function () {
        return this._height;
      },
      set: function (a) {
        this._height = a;
      }
    });
    if ("undefined" != typeof exports) {
      if ("undefined" != typeof module && module.exports) {
        exports = module.exports = b;
      }
      exports.PIXI = b;
    } else if ("undefined" != typeof define && define.amd) {
      define("PIXI", function () {
        return a.PIXI = b;
      }());
    } else {
      a.PIXI = b;
    }
    return b;
  }).call(this);
  (function () {
    function d(a, b) {
      this._scaleFactor = a;
      this._deltaMode = b;
      this.originalEvent = null;
    }
    var a = this;
    var b = b || {
      VERSION: "2.6.2",
      GAMES: [],
      AUTO: 0,
      CANVAS: 1,
      WEBGL: 2,
      HEADLESS: 3,
      NONE: 0,
      LEFT: 1,
      RIGHT: 2,
      UP: 3,
      DOWN: 4,
      SPRITE: 0,
      BUTTON: 1,
      IMAGE: 2,
      GRAPHICS: 3,
      TEXT: 4,
      TILESPRITE: 5,
      BITMAPTEXT: 6,
      GROUP: 7,
      RENDERTEXTURE: 8,
      TILEMAP: 9,
      TILEMAPLAYER: 10,
      EMITTER: 11,
      POLYGON: 12,
      BITMAPDATA: 13,
      CANVAS_FILTER: 14,
      WEBGL_FILTER: 15,
      ELLIPSE: 16,
      SPRITEBATCH: 17,
      RETROFONT: 18,
      POINTER: 19,
      ROPE: 20,
      CIRCLE: 21,
      RECTANGLE: 22,
      LINE: 23,
      MATRIX: 24,
      POINT: 25,
      ROUNDEDRECTANGLE: 26,
      CREATURE: 27,
      VIDEO: 28,
      PENDING_ATLAS: -1,
      HORIZONTAL: 0,
      VERTICAL: 1,
      LANDSCAPE: 0,
      PORTRAIT: 1,
      ANGLE_UP: 270,
      ANGLE_DOWN: 90,
      ANGLE_LEFT: 180,
      ANGLE_RIGHT: 0,
      ANGLE_NORTH_EAST: 315,
      ANGLE_NORTH_WEST: 225,
      ANGLE_SOUTH_EAST: 45,
      ANGLE_SOUTH_WEST: 135,
      TOP_LEFT: 0,
      TOP_CENTER: 1,
      TOP_RIGHT: 2,
      LEFT_TOP: 3,
      LEFT_CENTER: 4,
      LEFT_BOTTOM: 5,
      CENTER: 6,
      RIGHT_TOP: 7,
      RIGHT_CENTER: 8,
      RIGHT_BOTTOM: 9,
      BOTTOM_LEFT: 10,
      BOTTOM_CENTER: 11,
      BOTTOM_RIGHT: 12,
      blendModes: {
        NORMAL: 0,
        ADD: 1,
        MULTIPLY: 2,
        SCREEN: 3,
        OVERLAY: 4,
        DARKEN: 5,
        LIGHTEN: 6,
        COLOR_DODGE: 7,
        COLOR_BURN: 8,
        HARD_LIGHT: 9,
        SOFT_LIGHT: 10,
        DIFFERENCE: 11,
        EXCLUSION: 12,
        HUE: 13,
        SATURATION: 14,
        COLOR: 15,
        LUMINOSITY: 16
      },
      scaleModes: {
        DEFAULT: 0,
        LINEAR: 0,
        NEAREST: 1
      },
      PIXI: PIXI || {}
    };
    if (!Math.trunc) {
      Math.trunc = function (b) {
        return b < 0 ? Math.ceil(b) : Math.floor(b);
      };
    }
    if (!Function.prototype.bind) {
      Function.prototype.bind = function () {
        var a = Array.prototype.slice;
        return function (b) {
          function e() {
            var f = d.concat(a.call(arguments));
            c.apply(this instanceof e ? this : b, f);
          }
          var c = this;
          var d = a.call(arguments, 1);
          if ("function" != typeof c) {
            throw new TypeError();
          }
          e.prototype = function a(b) {
            if (b) {
              a.prototype = b;
            }
            if (!(this instanceof a)) {
              return new a();
            }
          }(c.prototype);
          return e;
        };
      }();
    }
    if (!Array.isArray) {
      Array.isArray = function (a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      };
    }
    if (!Array.prototype.forEach) {
      Array.prototype.forEach = function (a) {
        "use strict";
  
        if (undefined === this || null === this) {
          throw new TypeError();
        }
        var b = Object(this);
        var c = b.length >>> 0;
        if ("function" != typeof a) {
          throw new TypeError();
        }
        var d = arguments.length >= 2 ? arguments[1] : undefined;
        for (var e = 0; e < c; e++) {
          if (e in b) {
            a.call(d, b[e], e, b);
          }
        }
      };
    }
    if ("function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
      var c = function (a) {
        var b = new Array();
        window[a] = function (a) {
          if ("number" == typeof a) {
            Array.call(this, a);
            this.length = a;
            for (var b = 0; b < this.length; b++) {
              this[b] = 0;
            }
          } else {
            Array.call(this, a.length);
            this.length = a.length;
            for (var b = 0; b < this.length; b++) {
              this[b] = a[b];
            }
          }
        };
        window[a].prototype = b;
        window[a].constructor = window[a];
      };
      c("Uint32Array");
      c("Int16Array");
    }
    if (!window.console) {
      window.console = {};
      window.console.log = window.console.assert = function () {};
      window.console.warn = window.console.assert = function () {};
    }
    b.Utils = {
      reverseString: function (a) {
        return a.split("").reverse().join("");
      },
      getProperty: function (a, b) {
        var c = b.split(".");
        var d = c.pop();
        var e = c.length;
        var f = 1;
        for (var g = c[0]; f < e && (a = a[g]);) {
          g = c[f];
          f++;
        }
        return a ? a[d] : null;
      },
      setProperty: function (a, b, c) {
        var d = b.split(".");
        var e = d.pop();
        var f = d.length;
        var g = 1;
        for (var h = d[0]; g < f && (a = a[h]);) {
          h = d[g];
          g++;
        }
        if (a) {
          a[e] = c;
        }
        return a;
      },
      chanceRoll: function (a) {
        if (undefined === a) {
          a = 50;
        }
        return a > 0 && 100 * Math.random() <= a;
      },
      randomChoice: function (a, b) {
        return Math.random() < .5 ? a : b;
      },
      parseDimension: function (a, b) {
        var c = 0;
        var d = 0;
        if ("string" == typeof a) {
          if ("%" === a.substr(-1)) {
            c = parseInt(a, 10) / 100;
            d = 0 === b ? window.innerWidth * c : window.innerHeight * c;
          } else {
            d = parseInt(a, 10);
          }
        } else {
          d = a;
        }
        return d;
      },
      pad: function (a, b, c, d) {
        if (undefined === b) {
          var b = 0;
        }
        if (undefined === c) {
          var c = " ";
        }
        if (undefined === d) {
          var d = 3;
        }
        a = a.toString();
        var e = 0;
        if (b + 1 >= a.length) {
          switch (d) {
            case 1:
              a = new Array(b + 1 - a.length).join(c) + a;
              break;
            case 3:
              var f = Math.ceil((e = b - a.length) / 2);
              var g = e - f;
              a = new Array(g + 1).join(c) + a + new Array(f + 1).join(c);
              break;
            default:
              a += new Array(b + 1 - a.length).join(c);
          }
        }
        return a;
      },
      isPlainObject: function (a) {
        if ("object" != typeof a || a.nodeType || a === a.window) {
          return false;
        }
        try {
          if (a.constructor && !{}.hasOwnProperty.call(a.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
        } catch (a) {
          return false;
        }
        return true;
      },
      extend: function () {
        var a;
        var c;
        var d;
        var e;
        var f;
        var g;
        var h = arguments[0] || {};
        var i = 1;
        var j = arguments.length;
        var k = false;
        if ("boolean" == typeof h) {
          k = h;
          h = arguments[1] || {};
          i = 2;
        }
        for (j === i && (h = this, --i); i < j; i++) {
          if (null != (a = arguments[i])) {
            for (c in a) {
              d = h[c];
              e = a[c];
              if (h !== e) {
                if (k && e && (b.Utils.isPlainObject(e) || (f = Array.isArray(e)))) {
                  if (f) {
                    f = false;
                    g = d && Array.isArray(d) ? d : [];
                  } else {
                    g = d && b.Utils.isPlainObject(d) ? d : {};
                  }
                  h[c] = b.Utils.extend(k, g, e);
                } else if (undefined !== e) {
                  h[c] = e;
                }
              }
            }
          }
        }
        return h;
      },
      mixinPrototype: function (a, b, c) {
        if (undefined === c) {
          c = false;
        }
        var d = Object.keys(b);
        for (var e = 0; e < d.length; e++) {
          var f = d[e];
          var g = b[f];
          if (!(!c && f in a)) {
            if (!g || "function" != typeof g.get && "function" != typeof g.set) {
              a[f] = g;
            } else if ("function" == typeof g.clone) {
              a[f] = g.clone();
            } else {
              Object.defineProperty(a, f, g);
            }
          }
        }
      },
      mixin: function (a, c) {
        if (!a || "object" != typeof a) {
          return c;
        }
        for (var d in a) {
          var e = a[d];
          if (!e.childNodes && !e.cloneNode) {
            var f = typeof a[d];
            if (a[d] && "object" === f) {
              if (typeof c[d] === f) {
                c[d] = b.Utils.mixin(a[d], c[d]);
              } else {
                c[d] = b.Utils.mixin(a[d], new e.constructor());
              }
            } else {
              c[d] = a[d];
            }
          }
        }
        return c;
      }
    };
    b.Circle = function (a, c, d) {
      a = a || 0;
      c = c || 0;
      d = d || 0;
      this.x = a;
      this.y = c;
      this._diameter = d;
      this._radius = 0;
      if (d > 0) {
        this._radius = .5 * d;
      }
      this.type = b.CIRCLE;
    };
    b.Circle.prototype = {
      circumference: function () {
        return Math.PI * this._radius * 2;
      },
      random: function (a) {
        if (undefined === a) {
          a = new b.Point();
        }
        var c = 2 * Math.PI * Math.random();
        var d = Math.random() + Math.random();
        var e = d > 1 ? 2 - d : d;
        var f = e * Math.cos(c);
        var g = e * Math.sin(c);
        a.x = this.x + f * this.radius;
        a.y = this.y + g * this.radius;
        return a;
      },
      getBounds: function () {
        return new b.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
      },
      setTo: function (a, b, c) {
        this.x = a;
        this.y = b;
        this._diameter = c;
        this._radius = .5 * c;
        return this;
      },
      copyFrom: function (a) {
        return this.setTo(a.x, a.y, a.diameter);
      },
      copyTo: function (a) {
        a.x = this.x;
        a.y = this.y;
        a.diameter = this._diameter;
        return a;
      },
      distance: function (a, c) {
        var d = b.Math.distance(this.x, this.y, a.x, a.y);
        return c ? Math.round(d) : d;
      },
      clone: function (a) {
        if (undefined === a || null === a) {
          a = new b.Circle(this.x, this.y, this.diameter);
        } else {
          a.setTo(this.x, this.y, this.diameter);
        }
        return a;
      },
      contains: function (a, c) {
        return b.Circle.contains(this, a, c);
      },
      circumferencePoint: function (a, c, d) {
        return b.Circle.circumferencePoint(this, a, c, d);
      },
      offset: function (a, b) {
        this.x += a;
        this.y += b;
        return this;
      },
      offsetPoint: function (a) {
        return this.offset(a.x, a.y);
      },
      toString: function () {
        return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
      }
    };
    b.Circle.prototype.constructor = b.Circle;
    Object.defineProperty(b.Circle.prototype, "diameter", {
      get: function () {
        return this._diameter;
      },
      set: function (a) {
        if (a > 0) {
          this._diameter = a;
          this._radius = .5 * a;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "radius", {
      get: function () {
        return this._radius;
      },
      set: function (a) {
        if (a > 0) {
          this._radius = a;
          this._diameter = 2 * a;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "left", {
      get: function () {
        return this.x - this._radius;
      },
      set: function (a) {
        if (a > this.x) {
          this._radius = 0;
          this._diameter = 0;
        } else {
          this.radius = this.x - a;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "right", {
      get: function () {
        return this.x + this._radius;
      },
      set: function (a) {
        if (a < this.x) {
          this._radius = 0;
          this._diameter = 0;
        } else {
          this.radius = a - this.x;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "top", {
      get: function () {
        return this.y - this._radius;
      },
      set: function (a) {
        if (a > this.y) {
          this._radius = 0;
          this._diameter = 0;
        } else {
          this.radius = this.y - a;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "bottom", {
      get: function () {
        return this.y + this._radius;
      },
      set: function (a) {
        if (a < this.y) {
          this._radius = 0;
          this._diameter = 0;
        } else {
          this.radius = a - this.y;
        }
      }
    });
    Object.defineProperty(b.Circle.prototype, "area", {
      get: function () {
        return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
      }
    });
    Object.defineProperty(b.Circle.prototype, "empty", {
      get: function () {
        return 0 === this._diameter;
      },
      set: function (a) {
        if (true === a) {
          this.setTo(0, 0, 0);
        }
      }
    });
    b.Circle.contains = function (a, b, c) {
      if (a.radius > 0 && b >= a.left && b <= a.right && c >= a.top && c <= a.bottom) {
        return (a.x - b) * (a.x - b) + (a.y - c) * (a.y - c) <= a.radius * a.radius;
      }
      return false;
    };
    b.Circle.equals = function (a, b) {
      return a.x === b.x && a.y === b.y && a.diameter === b.diameter;
    };
    b.Circle.intersects = function (a, c) {
      return b.Math.distance(a.x, a.y, c.x, c.y) <= a.radius + c.radius;
    };
    b.Circle.circumferencePoint = function (a, c, d, e) {
      if (undefined === d) {
        d = false;
      }
      if (undefined === e) {
        e = new b.Point();
      }
      if (true === d) {
        c = b.Math.degToRad(c);
      }
      e.x = a.x + a.radius * Math.cos(c);
      e.y = a.y + a.radius * Math.sin(c);
      return e;
    };
    b.Circle.intersectsRectangle = function (a, b) {
      var c = Math.abs(a.x - b.x - b.halfWidth);
      if (c > b.halfWidth + a.radius) {
        return false;
      }
      var e = Math.abs(a.y - b.y - b.halfHeight);
      if (e > b.halfHeight + a.radius) {
        return false;
      }
      if (c <= b.halfWidth || e <= b.halfHeight) {
        return true;
      }
      var g = c - b.halfWidth;
      var h = e - b.halfHeight;
      return g * g + h * h <= a.radius * a.radius;
    };
    PIXI.Circle = b.Circle;
    b.Ellipse = function (a, c, d, e) {
      a = a || 0;
      c = c || 0;
      d = d || 0;
      e = e || 0;
      this.x = a;
      this.y = c;
      this.width = d;
      this.height = e;
      this.type = b.ELLIPSE;
    };
    b.Ellipse.prototype = {
      setTo: function (a, b, c, d) {
        this.x = a;
        this.y = b;
        this.width = c;
        this.height = d;
        return this;
      },
      getBounds: function () {
        return new b.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
      },
      copyFrom: function (a) {
        return this.setTo(a.x, a.y, a.width, a.height);
      },
      copyTo: function (a) {
        a.x = this.x;
        a.y = this.y;
        a.width = this.width;
        a.height = this.height;
        return a;
      },
      clone: function (a) {
        if (undefined === a || null === a) {
          a = new b.Ellipse(this.x, this.y, this.width, this.height);
        } else {
          a.setTo(this.x, this.y, this.width, this.height);
        }
        return a;
      },
      contains: function (a, c) {
        return b.Ellipse.contains(this, a, c);
      },
      random: function (a) {
        if (undefined === a) {
          a = new b.Point();
        }
        var c = Math.random() * Math.PI * 2;
        var d = Math.random();
        a.x = Math.sqrt(d) * Math.cos(c);
        a.y = Math.sqrt(d) * Math.sin(c);
        a.x = this.x + a.x * this.width / 2;
        a.y = this.y + a.y * this.height / 2;
        return a;
      },
      toString: function () {
        return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]";
      }
    };
    b.Ellipse.prototype.constructor = b.Ellipse;
    Object.defineProperty(b.Ellipse.prototype, "left", {
      get: function () {
        return this.x;
      },
      set: function (a) {
        this.x = a;
      }
    });
    Object.defineProperty(b.Ellipse.prototype, "right", {
      get: function () {
        return this.x + this.width;
      },
      set: function (a) {
        if (a < this.x) {
          this.width = 0;
        } else {
          this.width = a - this.x;
        }
      }
    });
    Object.defineProperty(b.Ellipse.prototype, "top", {
      get: function () {
        return this.y;
      },
      set: function (a) {
        this.y = a;
      }
    });
    Object.defineProperty(b.Ellipse.prototype, "bottom", {
      get: function () {
        return this.y + this.height;
      },
      set: function (a) {
        if (a < this.y) {
          this.height = 0;
        } else {
          this.height = a - this.y;
        }
      }
    });
    Object.defineProperty(b.Ellipse.prototype, "empty", {
      get: function () {
        return 0 === this.width || 0 === this.height;
      },
      set: function (a) {
        if (true === a) {
          this.setTo(0, 0, 0, 0);
        }
      }
    });
    b.Ellipse.contains = function (a, b, c) {
      if (a.width <= 0 || a.height <= 0) {
        return false;
      }
      var d = (b - a.x) / a.width - .5;
      var e = (c - a.y) / a.height - .5;
      d *= d;
      e *= e;
      return d + e < .25;
    };
    PIXI.Ellipse = b.Ellipse;
    b.Line = function (a, c, d, e) {
      a = a || 0;
      c = c || 0;
      d = d || 0;
      e = e || 0;
      this.start = new b.Point(a, c);
      this.end = new b.Point(d, e);
      this.type = b.LINE;
    };
    b.Line.prototype = {
      setTo: function (a, b, c, d) {
        this.start.setTo(a, b);
        this.end.setTo(c, d);
        return this;
      },
      fromSprite: function (a, b, c) {
        if (undefined === c) {
          c = false;
        }
        return c ? this.setTo(a.center.x, a.center.y, b.center.x, b.center.y) : this.setTo(a.x, a.y, b.x, b.y);
      },
      fromAngle: function (a, b, c, d) {
        this.start.setTo(a, b);
        this.end.setTo(a + Math.cos(c) * d, b + Math.sin(c) * d);
        return this;
      },
      rotate: function (a, b) {
        var c = (this.start.x + this.end.x) / 2;
        var d = (this.start.y + this.end.y) / 2;
        this.start.rotate(c, d, a, b);
        this.end.rotate(c, d, a, b);
        return this;
      },
      rotateAround: function (a, b, c, d) {
        this.start.rotate(a, b, c, d);
        this.end.rotate(a, b, c, d);
        return this;
      },
      intersects: function (a, c, d) {
        return b.Line.intersectsPoints(this.start, this.end, a.start, a.end, c, d);
      },
      reflect: function (a) {
        return b.Line.reflect(this, a);
      },
      midPoint: function (a) {
        if (undefined === a) {
          a = new b.Point();
        }
        a.x = (this.start.x + this.end.x) / 2;
        a.y = (this.start.y + this.end.y) / 2;
        return a;
      },
      centerOn: function (a, b) {
        var c = (this.start.x + this.end.x) / 2;
        var d = (this.start.y + this.end.y) / 2;
        var e = a - c;
        var f = b - d;
        this.start.add(e, f);
        this.end.add(e, f);
      },
      pointOnLine: function (a, b) {
        return (a - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (b - this.start.y);
      },
      pointOnSegment: function (a, b) {
        var c = Math.min(this.start.x, this.end.x);
        var d = Math.max(this.start.x, this.end.x);
        var e = Math.min(this.start.y, this.end.y);
        var f = Math.max(this.start.y, this.end.y);
        return this.pointOnLine(a, b) && a >= c && a <= d && b >= e && b <= f;
      },
      random: function (a) {
        if (undefined === a) {
          a = new b.Point();
        }
        var c = Math.random();
        a.x = this.start.x + c * (this.end.x - this.start.x);
        a.y = this.start.y + c * (this.end.y - this.start.y);
        return a;
      },
      coordinatesOnLine: function (a, b) {
        if (undefined === a) {
          a = 1;
        }
        if (undefined === b) {
          b = [];
        }
        var c = Math.round(this.start.x);
        var d = Math.round(this.start.y);
        var e = Math.round(this.end.x);
        var f = Math.round(this.end.y);
        var g = Math.abs(e - c);
        var h = Math.abs(f - d);
        var i = c < e ? 1 : -1;
        var j = d < f ? 1 : -1;
        var k = g - h;
        b.push([c, d]);
        for (var l = 1; c !== e || d !== f;) {
          var m = k << 1;
          if (m > -h) {
            k -= h;
            c += i;
          }
          if (m < g) {
            k += g;
            d += j;
          }
          if (l % a == 0) {
            b.push([c, d]);
          }
          l++;
        }
        return b;
      },
      clone: function (a) {
        if (undefined === a || null === a) {
          a = new b.Line(this.start.x, this.start.y, this.end.x, this.end.y);
        } else {
          a.setTo(this.start.x, this.start.y, this.end.x, this.end.y);
        }
        return a;
      }
    };
    Object.defineProperty(b.Line.prototype, "length", {
      get: function () {
        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
      }
    });
    Object.defineProperty(b.Line.prototype, "angle", {
      get: function () {
        return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "slope", {
      get: function () {
        return (this.end.y - this.start.y) / (this.end.x - this.start.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "perpSlope", {
      get: function () {
        return -(this.end.x - this.start.x) / (this.end.y - this.start.y);
      }
    });
    Object.defineProperty(b.Line.prototype, "x", {
      get: function () {
        return Math.min(this.start.x, this.end.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "y", {
      get: function () {
        return Math.min(this.start.y, this.end.y);
      }
    });
    Object.defineProperty(b.Line.prototype, "left", {
      get: function () {
        return Math.min(this.start.x, this.end.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "right", {
      get: function () {
        return Math.max(this.start.x, this.end.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "top", {
      get: function () {
        return Math.min(this.start.y, this.end.y);
      }
    });
    Object.defineProperty(b.Line.prototype, "bottom", {
      get: function () {
        return Math.max(this.start.y, this.end.y);
      }
    });
    Object.defineProperty(b.Line.prototype, "width", {
      get: function () {
        return Math.abs(this.start.x - this.end.x);
      }
    });
    Object.defineProperty(b.Line.prototype, "height", {
      get: function () {
        return Math.abs(this.start.y - this.end.y);
      }
    });
    Object.defineProperty(b.Line.prototype, "normalX", {
      get: function () {
        return Math.cos(this.angle - 1.5707963267948966);
      }
    });
    Object.defineProperty(b.Line.prototype, "normalY", {
      get: function () {
        return Math.sin(this.angle - 1.5707963267948966);
      }
    });
    Object.defineProperty(b.Line.prototype, "normalAngle", {
      get: function () {
        return b.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
      }
    });
    b.Line.intersectsPoints = function (a, c, d, e, f, g) {
      if (undefined === f) {
        f = true;
      }
      if (undefined === g) {
        g = new b.Point();
      }
      var h = c.y - a.y;
      var i = e.y - d.y;
      var j = a.x - c.x;
      var k = d.x - e.x;
      var l = c.x * a.y - a.x * c.y;
      var m = e.x * d.y - d.x * e.y;
      var n = h * k - i * j;
      if (0 === n) {
        return null;
      }
      g.x = (j * m - k * l) / n;
      g.y = (i * l - h * m) / n;
      if (f) {
        var o = (e.y - d.y) * (c.x - a.x) - (e.x - d.x) * (c.y - a.y);
        var p = ((e.x - d.x) * (a.y - d.y) - (e.y - d.y) * (a.x - d.x)) / o;
        var q = ((c.x - a.x) * (a.y - d.y) - (c.y - a.y) * (a.x - d.x)) / o;
        return p >= 0 && p <= 1 && q >= 0 && q <= 1 ? g : null;
      }
      return g;
    };
    b.Line.intersects = function (a, c, d, e) {
      return b.Line.intersectsPoints(a.start, a.end, c.start, c.end, d, e);
    };
    b.Line.intersectsRectangle = function (a, c) {
      if (!b.Rectangle.intersects(a, c)) {
        return false;
      }
      var d = a.start.x;
      var e = a.start.y;
      var f = a.end.x;
      var g = a.end.y;
      var h = c.x;
      var i = c.y;
      var j = c.right;
      var k = c.bottom;
      var l = 0;
      if (d >= h && d <= j && e >= i && e <= k || f >= h && f <= j && g >= i && g <= k) {
        return true;
      }
      if (d < h && f >= h) {
        if ((l = e + (g - e) * (h - d) / (f - d)) > i && l <= k) {
          return true;
        }
      } else if (d > j && f <= j && (l = e + (g - e) * (j - d) / (f - d)) >= i && l <= k) {
        return true;
      }
      if (e < i && g >= i) {
        if ((l = d + (f - d) * (i - e) / (g - e)) >= h && l <= j) {
          return true;
        }
      } else if (e > k && g <= k && (l = d + (f - d) * (k - e) / (g - e)) >= h && l <= j) {
        return true;
      }
      return false;
    };
    b.Line.reflect = function (a, b) {
      return 2 * b.normalAngle - 3.141592653589793 - a.angle;
    };
    b.Matrix = function (a, c, d, e, f, g) {
      if (!(undefined !== a && null !== a)) {
        a = 1;
      }
      if (!(undefined !== c && null !== c)) {
        c = 0;
      }
      if (!(undefined !== d && null !== d)) {
        d = 0;
      }
      if (!(undefined !== e && null !== e)) {
        e = 1;
      }
      if (!(undefined !== f && null !== f)) {
        f = 0;
      }
      if (!(undefined !== g && null !== g)) {
        g = 0;
      }
      this.a = a;
      this.b = c;
      this.c = d;
      this.d = e;
      this.tx = f;
      this.ty = g;
      this.type = b.MATRIX;
    };
    b.Matrix.prototype = {
      fromArray: function (a) {
        return this.setTo(a[0], a[1], a[3], a[4], a[2], a[5]);
      },
      setTo: function (a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = e;
        this.ty = f;
        return this;
      },
      clone: function (a) {
        if (undefined === a || null === a) {
          a = new b.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
        } else {
          a.a = this.a;
          a.b = this.b;
          a.c = this.c;
          a.d = this.d;
          a.tx = this.tx;
          a.ty = this.ty;
        }
        return a;
      },
      copyTo: function (a) {
        a.copyFrom(this);
        return a;
      },
      copyFrom: function (a) {
        this.a = a.a;
        this.b = a.b;
        this.c = a.c;
        this.d = a.d;
        this.tx = a.tx;
        this.ty = a.ty;
        return this;
      },
      toArray: function (a, b) {
        if (undefined === b) {
          b = new PIXI.Float32Array(9);
        }
        if (a) {
          b[0] = this.a;
          b[1] = this.b;
          b[2] = 0;
          b[3] = this.c;
          b[4] = this.d;
          b[5] = 0;
          b[6] = this.tx;
          b[7] = this.ty;
          b[8] = 1;
        } else {
          b[0] = this.a;
          b[1] = this.c;
          b[2] = this.tx;
          b[3] = this.b;
          b[4] = this.d;
          b[5] = this.ty;
          b[6] = 0;
          b[7] = 0;
          b[8] = 1;
        }
        return b;
      },
      apply: function (a, c) {
        if (undefined === c) {
          c = new b.Point();
        }
        c.x = this.a * a.x + this.c * a.y + this.tx;
        c.y = this.b * a.x + this.d * a.y + this.ty;
        return c;
      },
      applyInverse: function (a, c) {
        if (undefined === c) {
          c = new b.Point();
        }
        var d = 1 / (this.a * this.d + this.c * -this.b);
        var e = a.x;
        var f = a.y;
        c.x = this.d * d * e + -this.c * d * f + (this.ty * this.c - this.tx * this.d) * d;
        c.y = this.a * d * f + -this.b * d * e + (-this.ty * this.a + this.tx * this.b) * d;
        return c;
      },
      translate: function (a, b) {
        this.tx += a;
        this.ty += b;
        return this;
      },
      scale: function (a, b) {
        this.a *= a;
        this.d *= b;
        this.c *= a;
        this.b *= b;
        this.tx *= a;
        this.ty *= b;
        return this;
      },
      rotate: function (a) {
        var b = Math.cos(a);
        var c = Math.sin(a);
        var d = this.a;
        var e = this.c;
        var f = this.tx;
        this.a = d * b - this.b * c;
        this.b = d * c + this.b * b;
        this.c = e * b - this.d * c;
        this.d = e * c + this.d * b;
        this.tx = f * b - this.ty * c;
        this.ty = f * c + this.ty * b;
        return this;
      },
      append: function (a) {
        var b = this.a;
        var c = this.b;
        var d = this.c;
        var e = this.d;
        this.a = a.a * b + a.b * d;
        this.b = a.a * c + a.b * e;
        this.c = a.c * b + a.d * d;
        this.d = a.c * c + a.d * e;
        this.tx = a.tx * b + a.ty * d + this.tx;
        this.ty = a.tx * c + a.ty * e + this.ty;
        return this;
      },
      identity: function () {
        return this.setTo(1, 0, 0, 1, 0, 0);
      }
    };
    b.identityMatrix = new b.Matrix();
    PIXI.Matrix = b.Matrix;
    PIXI.identityMatrix = b.identityMatrix;
    b.Point = function (a, c) {
      a = a || 0;
      c = c || 0;
      this.x = a;
      this.y = c;
      this.type = b.POINT;
    };
    b.Point.prototype = {
      copyFrom: function (a) {
        return this.setTo(a.x, a.y);
      },
      invert: function () {
        return this.setTo(this.y, this.x);
      },
      setTo: function (a, b) {
        this.x = a || 0;
        this.y = b || (0 !== b ? this.x : 0);
        return this;
      },
      set: function (a, b) {
        this.x = a || 0;
        this.y = b || (0 !== b ? this.x : 0);
        return this;
      },
      add: function (a, b) {
        this.x += a;
        this.y += b;
        return this;
      },
      subtract: function (a, b) {
        this.x -= a;
        this.y -= b;
        return this;
      },
      multiply: function (a, b) {
        this.x *= a;
        this.y *= b;
        return this;
      },
      divide: function (a, b) {
        this.x /= a;
        this.y /= b;
        return this;
      },
      clampX: function (a, c) {
        this.x = b.Math.clamp(this.x, a, c);
        return this;
      },
      clampY: function (a, c) {
        this.y = b.Math.clamp(this.y, a, c);
        return this;
      },
      clamp: function (a, c) {
        this.x = b.Math.clamp(this.x, a, c);
        this.y = b.Math.clamp(this.y, a, c);
        return this;
      },
      clone: function (a) {
        if (undefined === a || null === a) {
          a = new b.Point(this.x, this.y);
        } else {
          a.setTo(this.x, this.y);
        }
        return a;
      },
      copyTo: function (a) {
        a.x = this.x;
        a.y = this.y;
        return a;
      },
      distance: function (a, c) {
        return b.Point.distance(this, a, c);
      },
      equals: function (a) {
        return a.x === this.x && a.y === this.y;
      },
      angle: function (a, c) {
        if (undefined === c) {
          c = false;
        }
        return c ? b.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)) : Math.atan2(a.y - this.y, a.x - this.x);
      },
      rotate: function (a, c, d, e, f) {
        return b.Point.rotate(this, a, c, d, e, f);
      },
      getMagnitude: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      getMagnitudeSq: function () {
        return this.x * this.x + this.y * this.y;
      },
      setMagnitude: function (a) {
        return this.normalize().multiply(a, a);
      },
      normalize: function () {
        if (!this.isZero()) {
          var a = this.getMagnitude();
          this.x /= a;
          this.y /= a;
        }
        return this;
      },
      isZero: function () {
        return 0 === this.x && 0 === this.y;
      },
      dot: function (a) {
        return this.x * a.x + this.y * a.y;
      },
      cross: function (a) {
        return this.x * a.y - this.y * a.x;
      },
      perp: function () {
        return this.setTo(-this.y, this.x);
      },
      rperp: function () {
        return this.setTo(this.y, -this.x);
      },
      normalRightHand: function () {
        return this.setTo(-1 * this.y, this.x);
      },
      floor: function () {
        return this.setTo(Math.floor(this.x), Math.floor(this.y));
      },
      ceil: function () {
        return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
      },
      toString: function () {
        return "[{Point (x=" + this.x + " y=" + this.y + ")}]";
      }
    };
    b.Point.prototype.constructor = b.Point;
    b.Point.add = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      d.x = a.x + c.x;
      d.y = a.y + c.y;
      return d;
    };
    b.Point.subtract = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      d.x = a.x - c.x;
      d.y = a.y - c.y;
      return d;
    };
    b.Point.multiply = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      d.x = a.x * c.x;
      d.y = a.y * c.y;
      return d;
    };
    b.Point.divide = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      d.x = a.x / c.x;
      d.y = a.y / c.y;
      return d;
    };
    b.Point.equals = function (a, b) {
      return a.x === b.x && a.y === b.y;
    };
    b.Point.angle = function (a, b) {
      return Math.atan2(a.y - b.y, a.x - b.x);
    };
    b.Point.negative = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      return c.setTo(-a.x, -a.y);
    };
    b.Point.multiplyAdd = function (a, c, d, e) {
      if (undefined === e) {
        e = new b.Point();
      }
      return e.setTo(a.x + c.x * d, a.y + c.y * d);
    };
    b.Point.interpolate = function (a, c, d, e) {
      if (undefined === e) {
        e = new b.Point();
      }
      return e.setTo(a.x + (c.x - a.x) * d, a.y + (c.y - a.y) * d);
    };
    b.Point.perp = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      return c.setTo(-a.y, a.x);
    };
    b.Point.rperp = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      return c.setTo(a.y, -a.x);
    };
    b.Point.distance = function (a, c, d) {
      var e = b.Math.distance(a.x, a.y, c.x, c.y);
      return d ? Math.round(e) : e;
    };
    b.Point.project = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      var e = a.dot(c) / c.getMagnitudeSq();
      if (0 !== e) {
        d.setTo(e * c.x, e * c.y);
      }
      return d;
    };
    b.Point.projectUnit = function (a, c, d) {
      if (undefined === d) {
        d = new b.Point();
      }
      var e = a.dot(c);
      if (0 !== e) {
        d.setTo(e * c.x, e * c.y);
      }
      return d;
    };
    b.Point.normalRightHand = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      return c.setTo(-1 * a.y, a.x);
    };
    b.Point.normalize = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      var d = a.getMagnitude();
      if (0 !== d) {
        c.setTo(a.x / d, a.y / d);
      }
      return c;
    };
    b.Point.rotate = function (a, c, d, e, f, g) {
      if (f) {
        e = b.Math.degToRad(e);
      }
      if (undefined === g) {
        a.subtract(c, d);
        var h = Math.sin(e);
        var i = Math.cos(e);
        var j = i * a.x - h * a.y;
        var k = h * a.x + i * a.y;
        a.x = j + c;
        a.y = k + d;
      } else {
        var l = e + Math.atan2(a.y - d, a.x - c);
        a.x = c + g * Math.cos(l);
        a.y = d + g * Math.sin(l);
      }
      return a;
    };
    b.Point.centroid = function (a, c) {
      if (undefined === c) {
        c = new b.Point();
      }
      if ("[object Array]" !== Object.prototype.toString.call(a)) {
        throw new Error("Phaser.Point. Parameter 'points' must be an array");
      }
      var d = a.length;
      if (d < 1) {
        throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
      }
      if (1 === d) {
        c.copyFrom(a[0]);
        return c;
      }
      for (var e = 0; e < d; e++) {
        b.Point.add(c, a[e], c);
      }
      c.divide(d, d);
      return c;
    };
    b.Point.parse = function (a, c, d) {
      c = c || "x";
      d = d || "y";
      var e = new b.Point();
      if (a[c]) {
        e.x = parseInt(a[c], 10);
      }
      if (a[d]) {
        e.y = parseInt(a[d], 10);
      }
      return e;
    };
    PIXI.Point = b.Point;
    b.Polygon = function () {
      this.area = 0;
      this._points = [];
      if (arguments.length > 0) {
        this.setTo.apply(this, arguments);
      }
      this.closed = true;
      this.flattened = false;
      this.type = b.POLYGON;
    };
    b.Polygon.prototype = {
      toNumberArray: function (a) {
        if (undefined === a) {
          a = [];
        }
        for (var b = 0; b < this._points.length; b++) {
          if ("number" == typeof this._points[b]) {
            a.push(this._points[b]);
            a.push(this._points[b + 1]);
            b++;
          } else {
            a.push(this._points[b].x);
            a.push(this._points[b].y);
          }
        }
        return a;
      },
      flatten: function () {
        this._points = this.toNumberArray();
        this.flattened = true;
        return this;
      },
      clone: function (a) {
        var c = this._points.slice();
        if (undefined === a || null === a) {
          a = new b.Polygon(c);
        } else {
          a.setTo(c);
        }
        return a;
      },
      contains: function (a, b) {
        var c = false;
        if (this.flattened) {
          var d = -2;
          for (var e = this._points.length - 2; (d += 2) < this._points.length; e = d) {
            var f = this._points[d];
            var g = this._points[d + 1];
            var h = this._points[e];
            var i = this._points[e + 1];
            if ((g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f) {
              c = !c;
            }
          }
        } else {
          var d = -1;
          for (var e = this._points.length - 1; ++d < this._points.length; e = d) {
            var f = this._points[d].x;
            var g = this._points[d].y;
            var h = this._points[e].x;
            var i = this._points[e].y;
            if ((g <= b && b < i || i <= b && b < g) && a < (h - f) * (b - g) / (i - g) + f) {
              c = !c;
            }
          }
        }
        return c;
      },
      setTo: function (a) {
        this.area = 0;
        this._points = [];
        if (arguments.length > 0) {
          if (!Array.isArray(a)) {
            a = Array.prototype.slice.call(arguments);
          }
          var b = Number.MAX_VALUE;
          var c = 0;
          for (var d = a.length; c < d; c++) {
            if ("number" == typeof a[c]) {
              var e = new PIXI.Point(a[c], a[c + 1]);
              c++;
            } else if (Array.isArray(a[c])) {
              var e = new PIXI.Point(a[c][0], a[c][1]);
            } else {
              var e = new PIXI.Point(a[c].x, a[c].y);
            }
            this._points.push(e);
            if (e.y < b) {
              b = e.y;
            }
          }
          this.calculateArea(b);
        }
        return this;
      },
      calculateArea: function (a) {
        var b;
        var c;
        var d;
        var e;
        var f = 0;
        for (var g = this._points.length; f < g; f++) {
          b = this._points[f];
          c = f === g - 1 ? this._points[0] : this._points[f + 1];
          d = (b.y - a + (c.y - a)) / 2;
          e = b.x - c.x;
          this.area += d * e;
        }
        return this.area;
      }
    };
    b.Polygon.prototype.constructor = b.Polygon;
    Object.defineProperty(b.Polygon.prototype, "points", {
      get: function () {
        return this._points;
      },
      set: function (a) {
        if (null != a) {
          this.setTo(a);
        } else {
          this.setTo();
        }
      }
    });
    PIXI.Polygon = b.Polygon;
    b.Rectangle = function (a, c, d, e) {
      a = a || 0;
      c = c || 0;
      d = d || 0;
      e = e || 0;
      this.x = a;
      this.y = c;
      this.width = d;
      this.height = e;
      this.type = b.RECTANGLE;
    };
    b.Rectangle.prototype = {
      offset: function (a, b) {
        this.x += a;
        this.y += b;
        return this;
      },
      offsetPoint: function (a) {
        return this.offset(a.x, a.y);
      },
      setTo: function (a, b, c, d) {
        this.x = a;
        this.y = b;
        this.width = c;
        this.height = d;
        return this;
      },
      scale: function (a, b) {
        if (undefined === a) {
          b = a;
        }
        this.width *= a;
        this.height *= a;
        return this;
      },
      centerOn: function (a, b) {
        this.centerX = a;
        this.centerY = b;
        return this;
      },
      floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
      },
      floorAll: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.width = Math.floor(this.width);
        this.height = Math.floor(this.height);
      },
      ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
      },
      ceilAll: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.width = Math.ceil(this.width);
        this.height = Math.ceil(this.height);
      },
      copyFrom: function (a) {
        return this.setTo(a.x, a.y, a.width, a.height);
      },
      copyTo: function (a) {
        a.x = this.x;
        a.y = this.y;
        a.width = this.width;
        a.height = this.height;
        return a;
      },
      inflate: function (a, c) {
        return b.Rectangle.inflate(this, a, c);
      },
      size: function (a) {
        return b.Rectangle.size(this, a);
      },
      resize: function (a, b) {
        this.width = a;
        this.height = b;
        return this;
      },
      clone: function (a) {
        return b.Rectangle.clone(this, a);
      },
      contains: function (a, c) {
        return b.Rectangle.contains(this, a, c);
      },
      containsRect: function (a) {
        return b.Rectangle.containsRect(a, this);
      },
      equals: function (a) {
        return b.Rectangle.equals(this, a);
      },
      intersection: function (a, c) {
        return b.Rectangle.intersection(this, a, c);
      },
      intersects: function (a) {
        return b.Rectangle.intersects(this, a);
      },
      intersectsRaw: function (a, c, d, e, f) {
        return b.Rectangle.intersectsRaw(this, a, c, d, e, f);
      },
      union: function (a, c) {
        return b.Rectangle.union(this, a, c);
      },
      random: function (a) {
        if (undefined === a) {
          a = new b.Point();
        }
        a.x = this.randomX;
        a.y = this.randomY;
        return a;
      },
      getPoint: function (a, c) {
        if (undefined === c) {
          c = new b.Point();
        }
        switch (a) {
          default:
          case b.TOP_LEFT:
            return c.set(this.x, this.y);
          case b.TOP_CENTER:
            return c.set(this.centerX, this.y);
          case b.TOP_RIGHT:
            return c.set(this.right, this.y);
          case b.LEFT_CENTER:
            return c.set(this.x, this.centerY);
          case b.CENTER:
            return c.set(this.centerX, this.centerY);
          case b.RIGHT_CENTER:
            return c.set(this.right, this.centerY);
          case b.BOTTOM_LEFT:
            return c.set(this.x, this.bottom);
          case b.BOTTOM_CENTER:
            return c.set(this.centerX, this.bottom);
          case b.BOTTOM_RIGHT:
            return c.set(this.right, this.bottom);
        }
      },
      toString: function () {
        return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]";
      }
    };
    Object.defineProperty(b.Rectangle.prototype, "halfWidth", {
      get: function () {
        return Math.round(this.width / 2);
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "halfHeight", {
      get: function () {
        return Math.round(this.height / 2);
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "bottom", {
      get: function () {
        return this.y + this.height;
      },
      set: function (a) {
        if (a <= this.y) {
          this.height = 0;
        } else {
          this.height = a - this.y;
        }
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "bottomLeft", {
      get: function () {
        return new b.Point(this.x, this.bottom);
      },
      set: function (a) {
        this.x = a.x;
        this.bottom = a.y;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "bottomRight", {
      get: function () {
        return new b.Point(this.right, this.bottom);
      },
      set: function (a) {
        this.right = a.x;
        this.bottom = a.y;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "left", {
      get: function () {
        return this.x;
      },
      set: function (a) {
        if (a >= this.right) {
          this.width = 0;
        } else {
          this.width = this.right - a;
        }
        this.x = a;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "right", {
      get: function () {
        return this.x + this.width;
      },
      set: function (a) {
        if (a <= this.x) {
          this.width = 0;
        } else {
          this.width = a - this.x;
        }
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "volume", {
      get: function () {
        return this.width * this.height;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "perimeter", {
      get: function () {
        return 2 * this.width + 2 * this.height;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "centerX", {
      get: function () {
        return this.x + this.halfWidth;
      },
      set: function (a) {
        this.x = a - this.halfWidth;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "centerY", {
      get: function () {
        return this.y + this.halfHeight;
      },
      set: function (a) {
        this.y = a - this.halfHeight;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "randomX", {
      get: function () {
        return this.x + Math.random() * this.width;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "randomY", {
      get: function () {
        return this.y + Math.random() * this.height;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "top", {
      get: function () {
        return this.y;
      },
      set: function (a) {
        if (a >= this.bottom) {
          this.height = 0;
          this.y = a;
        } else {
          this.height = this.bottom - a;
        }
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "topLeft", {
      get: function () {
        return new b.Point(this.x, this.y);
      },
      set: function (a) {
        this.x = a.x;
        this.y = a.y;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "topRight", {
      get: function () {
        return new b.Point(this.x + this.width, this.y);
      },
      set: function (a) {
        this.right = a.x;
        this.y = a.y;
      }
    });
    Object.defineProperty(b.Rectangle.prototype, "empty", {
      get: function () {
        return !this.width || !this.height;
      },
      set: function (a) {
        if (true === a) {
          this.setTo(0, 0, 0, 0);
        }
      }
    });
    b.Rectangle.prototype.constructor = b.Rectangle;
    b.Rectangle.inflate = function (a, b, c) {
      a.x -= b;
      a.width += 2 * b;
      a.y -= c;
      a.height += 2 * c;
      return a;
    };
    b.Rectangle.inflatePoint = function (a, c) {
      return b.Rectangle.inflate(a, c.x, c.y);
    };
    b.Rectangle.size = function (a, c) {
      if (undefined === c || null === c) {
        c = new b.Point(a.width, a.height);
      } else {
        c.setTo(a.width, a.height);
      }
      return c;
    };
    b.Rectangle.clone = function (a, c) {
      if (undefined === c || null === c) {
        c = new b.Rectangle(a.x, a.y, a.width, a.height);
      } else {
        c.setTo(a.x, a.y, a.width, a.height);
      }
      return c;
    };
    b.Rectangle.contains = function (a, b, c) {
      return !(a.width <= 0 || a.height <= 0) && b >= a.x && b < a.right && c >= a.y && c < a.bottom;
    };
    b.Rectangle.containsRaw = function (a, b, c, d, e, f) {
      return e >= a && e < a + c && f >= b && f < b + d;
    };
    b.Rectangle.containsPoint = function (a, c) {
      return b.Rectangle.contains(a, c.x, c.y);
    };
    b.Rectangle.containsRect = function (a, b) {
      return !(a.volume > b.volume) && a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom;
    };
    b.Rectangle.equals = function (a, b) {
      return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    };
    b.Rectangle.sameDimensions = function (a, b) {
      return a.width === b.width && a.height === b.height;
    };
    b.Rectangle.intersection = function (a, c, d) {
      if (undefined === d) {
        d = new b.Rectangle();
      }
      if (b.Rectangle.intersects(a, c)) {
        d.x = Math.max(a.x, c.x);
        d.y = Math.max(a.y, c.y);
        d.width = Math.min(a.right, c.right) - d.x;
        d.height = Math.min(a.bottom, c.bottom) - d.y;
      }
      return d;
    };
    b.Rectangle.intersects = function (a, b) {
      return !(a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) && !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);
    };
    b.Rectangle.intersectsRaw = function (a, b, c, d, e, f) {
      if (undefined === f) {
        f = 0;
      }
      return !(b > a.right + f || c < a.left - f || d > a.bottom + f || e < a.top - f);
    };
    b.Rectangle.union = function (a, c, d) {
      if (undefined === d) {
        d = new b.Rectangle();
      }
      return d.setTo(Math.min(a.x, c.x), Math.min(a.y, c.y), Math.max(a.right, c.right) - Math.min(a.left, c.left), Math.max(a.bottom, c.bottom) - Math.min(a.top, c.top));
    };
    b.Rectangle.aabb = function (a, c) {
      if (undefined === c) {
        c = new b.Rectangle();
      }
      var d = Number.NEGATIVE_INFINITY;
      var e = Number.POSITIVE_INFINITY;
      var f = Number.NEGATIVE_INFINITY;
      var g = Number.POSITIVE_INFINITY;
      a.forEach(function (a) {
        if (a.x > d) {
          d = a.x;
        }
        if (a.x < e) {
          e = a.x;
        }
        if (a.y > f) {
          f = a.y;
        }
        if (a.y < g) {
          g = a.y;
        }
      });
      c.setTo(e, g, d - e, f - g);
      return c;
    };
    PIXI.Rectangle = b.Rectangle;
    PIXI.EmptyRectangle = new b.Rectangle(0, 0, 0, 0);
    b.RoundedRectangle = function (a, c, d, e, f) {
      if (undefined === a) {
        a = 0;
      }
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = 0;
      }
      if (undefined === e) {
        e = 0;
      }
      if (undefined === f) {
        f = 20;
      }
      this.x = a;
      this.y = c;
      this.width = d;
      this.height = e;
      this.radius = f || 20;
      this.type = b.ROUNDEDRECTANGLE;
    };
    b.RoundedRectangle.prototype = {
      clone: function () {
        return new b.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      },
      contains: function (a, b) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var c = this.x;
        if (a >= c && a <= c + this.width) {
          var d = this.y;
          if (b >= d && b <= d + this.height) {
            return true;
          }
        }
        return false;
      }
    };
    b.RoundedRectangle.prototype.constructor = b.RoundedRectangle;
    PIXI.RoundedRectangle = b.RoundedRectangle;
    b.Camera = function (a, c, d, e, f, g) {
      this.game = a;
      this.world = a.world;
      this.id = 0;
      this.view = new b.Rectangle(d, e, f, g);
      this.bounds = new b.Rectangle(d, e, f, g);
      this.deadzone = null;
      this.visible = true;
      this.roundPx = true;
      this.atLimit = {
        x: false,
        y: false
      };
      this.target = null;
      this.displayObject = null;
      this.scale = null;
      this.totalInView = 0;
      this.lerp = new b.Point(1, 1);
      this.onShakeComplete = new b.Signal();
      this.onFlashComplete = new b.Signal();
      this.onFadeComplete = new b.Signal();
      this.fx = null;
      this._targetPosition = new b.Point();
      this._edge = 0;
      this._position = new b.Point();
      this._shake = {
        intensity: 0,
        duration: 0,
        horizontal: false,
        vertical: false,
        shakeBounds: true,
        x: 0,
        y: 0
      };
      this._fxDuration = 0;
      this._fxType = 0;
    };
    b.Camera.FOLLOW_LOCKON = 0;
    b.Camera.FOLLOW_PLATFORMER = 1;
    b.Camera.FOLLOW_TOPDOWN = 2;
    b.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    b.Camera.SHAKE_BOTH = 4;
    b.Camera.SHAKE_HORIZONTAL = 5;
    b.Camera.SHAKE_VERTICAL = 6;
    b.Camera.ENABLE_FX = true;
    b.Camera.prototype = {
      boot: function () {
        this.displayObject = this.game.world;
        this.scale = this.game.world.scale;
        this.game.camera = this;
        if (b.Graphics && b.Camera.ENABLE_FX) {
          this.fx = new b.Graphics(this.game);
          this.game.stage.addChild(this.fx);
        }
      },
      preUpdate: function () {
        this.totalInView = 0;
      },
      follow: function (a, c, d, e) {
        if (undefined === c) {
          c = b.Camera.FOLLOW_LOCKON;
        }
        if (undefined === d) {
          d = 1;
        }
        if (undefined === e) {
          e = 1;
        }
        this.target = a;
        this.lerp.set(d, e);
        var f;
        switch (c) {
          case b.Camera.FOLLOW_PLATFORMER:
            var g = this.width / 8;
            var h = this.height / 3;
            this.deadzone = new b.Rectangle((this.width - g) / 2, (this.height - h) / 2 - .25 * h, g, h);
            break;
          case b.Camera.FOLLOW_TOPDOWN:
            f = Math.max(this.width, this.height) / 4;
            this.deadzone = new b.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
            break;
          case b.Camera.FOLLOW_TOPDOWN_TIGHT:
            f = Math.max(this.width, this.height) / 8;
            this.deadzone = new b.Rectangle((this.width - f) / 2, (this.height - f) / 2, f, f);
            break;
          case b.Camera.FOLLOW_LOCKON:
          default:
            this.deadzone = null;
        }
      },
      unfollow: function () {
        this.target = null;
      },
      focusOn: function (a) {
        this.setPosition(Math.round(a.x - this.view.halfWidth), Math.round(a.y - this.view.halfHeight));
      },
      focusOnXY: function (a, b) {
        this.setPosition(Math.round(a - this.view.halfWidth), Math.round(b - this.view.halfHeight));
      },
      shake: function (a, c, d, e, f) {
        if (undefined === a) {
          a = .05;
        }
        if (undefined === c) {
          c = 500;
        }
        if (undefined === d) {
          d = true;
        }
        if (undefined === e) {
          e = b.Camera.SHAKE_BOTH;
        }
        if (undefined === f) {
          f = true;
        }
        return !(!d && this._shake.duration > 0) && (this._shake.intensity = a, this._shake.duration = c, this._shake.shakeBounds = f, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = e === b.Camera.SHAKE_BOTH || e === b.Camera.SHAKE_HORIZONTAL, this._shake.vertical = e === b.Camera.SHAKE_BOTH || e === b.Camera.SHAKE_VERTICAL, true);
      },
      flash: function (a, b, c) {
        if (undefined === a) {
          a = 16777215;
        }
        if (undefined === b) {
          b = 500;
        }
        if (undefined === c) {
          c = false;
        }
        return !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = b, this._fxType = 0, true);
      },
      fade: function (a, b, c) {
        if (undefined === a) {
          a = 0;
        }
        if (undefined === b) {
          b = 500;
        }
        if (undefined === c) {
          c = false;
        }
        return !(!this.fx || !c && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(a), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = b, this._fxType = 1, true);
      },
      update: function () {
        if (this._fxDuration > 0) {
          this.updateFX();
        }
        if (this._shake.duration > 0) {
          this.updateShake();
        }
        if (this.bounds) {
          this.checkBounds();
        }
        if (this.roundPx) {
          this.view.floor();
          this._shake.x = Math.floor(this._shake.x);
          this._shake.y = Math.floor(this._shake.y);
        }
        this.displayObject.position.x = -this.view.x;
        this.displayObject.position.y = -this.view.y;
      },
      updateFX: function () {
        if (0 === this._fxType) {
          this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration;
          if (this.fx.alpha <= 0) {
            this._fxDuration = 0;
            this.fx.alpha = 0;
            this.onFlashComplete.dispatch();
          }
        } else {
          this.fx.alpha += this.game.time.elapsedMS / this._fxDuration;
          if (this.fx.alpha >= 1) {
            this._fxDuration = 0;
            this.fx.alpha = 1;
            this.onFadeComplete.dispatch();
          }
        }
      },
      updateShake: function () {
        this._shake.duration -= this.game.time.elapsedMS;
        if (this._shake.duration <= 0) {
          this.onShakeComplete.dispatch();
          this._shake.x = 0;
          this._shake.y = 0;
        } else {
          if (this._shake.horizontal) {
            this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width;
          }
          if (this._shake.vertical) {
            this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height;
          }
        }
      },
      updateTarget: function () {
        this._targetPosition.x = this.view.x + this.target.worldPosition.x;
        this._targetPosition.y = this.view.y + this.target.worldPosition.y;
        if (this.deadzone) {
          this._edge = this._targetPosition.x - this.view.x;
          if (this._edge < this.deadzone.left) {
            this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x);
          } else if (this._edge > this.deadzone.right) {
            this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x);
          }
          this._edge = this._targetPosition.y - this.view.y;
          if (this._edge < this.deadzone.top) {
            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y);
          } else if (this._edge > this.deadzone.bottom) {
            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y);
          }
        } else {
          this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x);
          this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y);
        }
        if (this.bounds) {
          this.checkBounds();
        }
        if (this.roundPx) {
          this.view.floor();
        }
        this.displayObject.position.x = -this.view.x;
        this.displayObject.position.y = -this.view.y;
      },
      setBoundsToWorld: function () {
        if (this.bounds) {
          this.bounds.copyFrom(this.game.world.bounds);
        }
      },
      checkBounds: function () {
        this.atLimit.x = false;
        this.atLimit.y = false;
        var a = this.view.x + this._shake.x;
        var b = this.view.right + this._shake.x;
        var c = this.view.y + this._shake.y;
        var d = this.view.bottom + this._shake.y;
        if (a <= this.bounds.x * this.scale.x) {
          this.atLimit.x = true;
          this.view.x = this.bounds.x * this.scale.x;
          if (!this._shake.shakeBounds) {
            this._shake.x = 0;
          }
        }
        if (b >= this.bounds.right * this.scale.x) {
          this.atLimit.x = true;
          this.view.x = this.bounds.right * this.scale.x - this.width;
          if (!this._shake.shakeBounds) {
            this._shake.x = 0;
          }
        }
        if (c <= this.bounds.top * this.scale.y) {
          this.atLimit.y = true;
          this.view.y = this.bounds.top * this.scale.y;
          if (!this._shake.shakeBounds) {
            this._shake.y = 0;
          }
        }
        if (d >= this.bounds.bottom * this.scale.y) {
          this.atLimit.y = true;
          this.view.y = this.bounds.bottom * this.scale.y - this.height;
          if (!this._shake.shakeBounds) {
            this._shake.y = 0;
          }
        }
      },
      setPosition: function (a, b) {
        this.view.x = a;
        this.view.y = b;
        if (this.bounds) {
          this.checkBounds();
        }
      },
      setSize: function (a, b) {
        this.view.width = a;
        this.view.height = b;
      },
      reset: function () {
        this.target = null;
        this.view.x = 0;
        this.view.y = 0;
        this._shake.duration = 0;
        this.resetFX();
      },
      resetFX: function () {
        this.fx.clear();
        this.fx.alpha = 0;
        this._fxDuration = 0;
      }
    };
    b.Camera.prototype.constructor = b.Camera;
    Object.defineProperty(b.Camera.prototype, "x", {
      get: function () {
        return this.view.x;
      },
      set: function (a) {
        this.view.x = a;
        if (this.bounds) {
          this.checkBounds();
        }
      }
    });
    Object.defineProperty(b.Camera.prototype, "y", {
      get: function () {
        return this.view.y;
      },
      set: function (a) {
        this.view.y = a;
        if (this.bounds) {
          this.checkBounds();
        }
      }
    });
    Object.defineProperty(b.Camera.prototype, "position", {
      get: function () {
        this._position.set(this.view.x, this.view.y);
        return this._position;
      },
      set: function (a) {
        if (undefined !== a.x) {
          this.view.x = a.x;
        }
        if (undefined !== a.y) {
          this.view.y = a.y;
        }
        if (this.bounds) {
          this.checkBounds();
        }
      }
    });
    Object.defineProperty(b.Camera.prototype, "width", {
      get: function () {
        return this.view.width;
      },
      set: function (a) {
        this.view.width = a;
      }
    });
    Object.defineProperty(b.Camera.prototype, "height", {
      get: function () {
        return this.view.height;
      },
      set: function (a) {
        this.view.height = a;
      }
    });
    Object.defineProperty(b.Camera.prototype, "shakeIntensity", {
      get: function () {
        return this._shake.intensity;
      },
      set: function (a) {
        this._shake.intensity = a;
      }
    });
    b.State = function () {
      this.game = null;
      this.key = "";
      this.add = null;
      this.make = null;
      this.camera = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.math = null;
      this.sound = null;
      this.scale = null;
      this.stage = null;
      this.state = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.particles = null;
      this.physics = null;
      this.rnd = null;
    };
    b.State.prototype = {
      init: function () {},
      preload: function () {},
      loadUpdate: function () {},
      loadRender: function () {},
      create: function () {},
      update: function () {},
      preRender: function () {},
      render: function () {},
      resize: function () {},
      paused: function () {},
      resumed: function () {},
      pauseUpdate: function () {},
      shutdown: function () {}
    };
    b.State.prototype.constructor = b.State;
    b.StateManager = function (a, c) {
      this.game = a;
      this.states = {};
      this._pendingState = null;
      if (undefined !== c && null !== c) {
        this._pendingState = c;
      }
      this._clearWorld = false;
      this._clearCache = false;
      this._created = false;
      this._args = [];
      this.current = "";
      this.onStateChange = new b.Signal();
      this.onInitCallback = null;
      this.onPreloadCallback = null;
      this.onCreateCallback = null;
      this.onUpdateCallback = null;
      this.onRenderCallback = null;
      this.onResizeCallback = null;
      this.onPreRenderCallback = null;
      this.onLoadUpdateCallback = null;
      this.onLoadRenderCallback = null;
      this.onPausedCallback = null;
      this.onResumedCallback = null;
      this.onPauseUpdateCallback = null;
      this.onShutDownCallback = null;
    };
    b.StateManager.prototype = {
      boot: function () {
        this.game.onPause.add(this.pause, this);
        this.game.onResume.add(this.resume, this);
        if (null !== this._pendingState && "string" != typeof this._pendingState) {
          this.add("default", this._pendingState, true);
        }
      },
      add: function (a, c, d) {
        if (undefined === d) {
          d = false;
        }
        var e;
        if (c instanceof b.State) {
          e = c;
        } else if ("object" == typeof c) {
          e = c;
          e.game = this.game;
        } else if ("function" == typeof c) {
          e = new c(this.game);
        }
        this.states[a] = e;
        if (d) {
          if (this.game.isBooted) {
            this.start(a);
          } else {
            this._pendingState = a;
          }
        }
        return e;
      },
      remove: function (a) {
        if (this.current === a) {
          this.callbackContext = null;
          this.onInitCallback = null;
          this.onShutDownCallback = null;
          this.onPreloadCallback = null;
          this.onLoadRenderCallback = null;
          this.onLoadUpdateCallback = null;
          this.onCreateCallback = null;
          this.onUpdateCallback = null;
          this.onPreRenderCallback = null;
          this.onRenderCallback = null;
          this.onResizeCallback = null;
          this.onPausedCallback = null;
          this.onResumedCallback = null;
          this.onPauseUpdateCallback = null;
        }
        delete this.states[a];
      },
      start: function (a, b, c) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          c = false;
        }
        if (this.checkState(a)) {
          this._pendingState = a;
          this._clearWorld = b;
          this._clearCache = c;
          if (arguments.length > 3) {
            this._args = Array.prototype.splice.call(arguments, 3);
          }
        }
      },
      restart: function (a, b) {
        if (undefined === a) {
          a = true;
        }
        if (undefined === b) {
          b = false;
        }
        this._pendingState = this.current;
        this._clearWorld = a;
        this._clearCache = b;
        if (arguments.length > 2) {
          this._args = Array.prototype.slice.call(arguments, 2);
        }
      },
      dummy: function () {},
      preUpdate: function () {
        if (this._pendingState && this.game.isBooted) {
          var a = this.current;
          this.clearCurrentState();
          this.setCurrentState(this._pendingState);
          this.onStateChange.dispatch(this.current, a);
          if (this.current !== this._pendingState) {
            return;
          }
          this._pendingState = null;
          if (this.onPreloadCallback) {
            this.game.load.reset(true);
            this.onPreloadCallback.call(this.callbackContext, this.game);
            if (0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks()) {
              this.loadComplete();
            } else {
              this.game.load.start();
            }
          } else {
            this.loadComplete();
          }
        }
      },
      clearCurrentState: function () {
        if (this.current) {
          if (this.onShutDownCallback) {
            this.onShutDownCallback.call(this.callbackContext, this.game);
          }
          this.game.tweens.removeAll();
          this.game.camera.reset();
          this.game.input.reset(true);
          this.game.physics.clear();
          this.game.time.removeAll();
          this.game.scale.reset(this._clearWorld);
          if (this.game.debug) {
            this.game.debug.reset();
          }
          if (this._clearWorld) {
            this.game.world.shutdown();
            if (this._clearCache) {
              this.game.cache.destroy();
            }
          }
        }
      },
      checkState: function (a) {
        return this.states[a] ? !!(this.states[a].preload || this.states[a].create || this.states[a].update || this.states[a].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), false) : (console.warn("Phaser.StateManager - No state found with the key: " + a), false);
      },
      link: function (a) {
        this.states[a].game = this.game;
        this.states[a].add = this.game.add;
        this.states[a].make = this.game.make;
        this.states[a].camera = this.game.camera;
        this.states[a].cache = this.game.cache;
        this.states[a].input = this.game.input;
        this.states[a].load = this.game.load;
        this.states[a].math = this.game.math;
        this.states[a].sound = this.game.sound;
        this.states[a].scale = this.game.scale;
        this.states[a].state = this;
        this.states[a].stage = this.game.stage;
        this.states[a].time = this.game.time;
        this.states[a].tweens = this.game.tweens;
        this.states[a].world = this.game.world;
        this.states[a].particles = this.game.particles;
        this.states[a].rnd = this.game.rnd;
        this.states[a].physics = this.game.physics;
        this.states[a].key = a;
      },
      unlink: function (a) {
        if (this.states[a]) {
          this.states[a].game = null;
          this.states[a].add = null;
          this.states[a].make = null;
          this.states[a].camera = null;
          this.states[a].cache = null;
          this.states[a].input = null;
          this.states[a].load = null;
          this.states[a].math = null;
          this.states[a].sound = null;
          this.states[a].scale = null;
          this.states[a].state = null;
          this.states[a].stage = null;
          this.states[a].time = null;
          this.states[a].tweens = null;
          this.states[a].world = null;
          this.states[a].particles = null;
          this.states[a].rnd = null;
          this.states[a].physics = null;
        }
      },
      setCurrentState: function (a) {
        this.callbackContext = this.states[a];
        this.link(a);
        this.onInitCallback = this.states[a].init || this.dummy;
        this.onPreloadCallback = this.states[a].preload || null;
        this.onLoadRenderCallback = this.states[a].loadRender || null;
        this.onLoadUpdateCallback = this.states[a].loadUpdate || null;
        this.onCreateCallback = this.states[a].create || null;
        this.onUpdateCallback = this.states[a].update || null;
        this.onPreRenderCallback = this.states[a].preRender || null;
        this.onRenderCallback = this.states[a].render || null;
        this.onResizeCallback = this.states[a].resize || null;
        this.onPausedCallback = this.states[a].paused || null;
        this.onResumedCallback = this.states[a].resumed || null;
        this.onPauseUpdateCallback = this.states[a].pauseUpdate || null;
        this.onShutDownCallback = this.states[a].shutdown || this.dummy;
        if ("" !== this.current) {
          this.game.physics.reset();
        }
        this.current = a;
        this._created = false;
        this.onInitCallback.apply(this.callbackContext, this._args);
        if (a === this._pendingState) {
          this._args = [];
        }
        this.game._kickstart = true;
      },
      getCurrentState: function () {
        return this.states[this.current];
      },
      loadComplete: function () {
        if (false === this._created && this.onLoadUpdateCallback) {
          this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        }
        if (false === this._created && this.onCreateCallback) {
          this._created = true;
          this.onCreateCallback.call(this.callbackContext, this.game);
        } else {
          this._created = true;
        }
      },
      pause: function () {
        if (this._created && this.onPausedCallback) {
          this.onPausedCallback.call(this.callbackContext, this.game);
        }
      },
      resume: function () {
        if (this._created && this.onResumedCallback) {
          this.onResumedCallback.call(this.callbackContext, this.game);
        }
      },
      update: function () {
        if (this._created) {
          if (this.onUpdateCallback) {
            this.onUpdateCallback.call(this.callbackContext, this.game);
          }
        } else if (this.onLoadUpdateCallback) {
          this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        }
      },
      pauseUpdate: function () {
        if (this._created) {
          if (this.onPauseUpdateCallback) {
            this.onPauseUpdateCallback.call(this.callbackContext, this.game);
          }
        } else if (this.onLoadUpdateCallback) {
          this.onLoadUpdateCallback.call(this.callbackContext, this.game);
        }
      },
      preRender: function (a) {
        if (this._created && this.onPreRenderCallback) {
          this.onPreRenderCallback.call(this.callbackContext, this.game, a);
        }
      },
      resize: function (a, b) {
        if (this.onResizeCallback) {
          this.onResizeCallback.call(this.callbackContext, a, b);
        }
      },
      render: function () {
        if (this._created) {
          if (this.onRenderCallback) {
            if (this.game.renderType === b.CANVAS) {
              this.game.context.save();
              this.game.context.setTransform(1, 0, 0, 1, 0, 0);
              this.onRenderCallback.call(this.callbackContext, this.game);
              this.game.context.restore();
            } else {
              this.onRenderCallback.call(this.callbackContext, this.game);
            }
          }
        } else if (this.onLoadRenderCallback) {
          this.onLoadRenderCallback.call(this.callbackContext, this.game);
        }
      },
      destroy: function () {
        this._clearWorld = true;
        this._clearCache = true;
        this.clearCurrentState();
        this.callbackContext = null;
        this.onInitCallback = null;
        this.onShutDownCallback = null;
        this.onPreloadCallback = null;
        this.onLoadRenderCallback = null;
        this.onLoadUpdateCallback = null;
        this.onCreateCallback = null;
        this.onUpdateCallback = null;
        this.onRenderCallback = null;
        this.onPausedCallback = null;
        this.onResumedCallback = null;
        this.onPauseUpdateCallback = null;
        this.game = null;
        this.states = {};
        this._pendingState = null;
        this.current = "";
      }
    };
    b.StateManager.prototype.constructor = b.StateManager;
    Object.defineProperty(b.StateManager.prototype, "created", {
      get: function () {
        return this._created;
      }
    });
    b.Signal = function () {};
    b.Signal.prototype = {
      _bindings: null,
      _prevParams: null,
      memorize: false,
      _shouldPropagate: true,
      active: true,
      _boundDispatch: false,
      validateListener: function (a, b) {
        if ("function" != typeof a) {
          throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", b));
        }
      },
      _registerListener: function (a, c, d, e, f) {
        var h;
        var g = this._indexOfListener(a, d);
        if (-1 !== g) {
          h = this._bindings[g];
          if (h.isOnce() !== c) {
            throw new Error("You cannot add" + (c ? "" : "Once") + "() then add" + (c ? "Once" : "") + "() the same listener without removing the relationship first.");
          }
        } else {
          h = new b.SignalBinding(this, a, c, d, e, f);
          this._addBinding(h);
        }
        if (this.memorize && this._prevParams) {
          h.execute(this._prevParams);
        }
        return h;
      },
      _addBinding: function (a) {
        if (!this._bindings) {
          this._bindings = [];
        }
        var b = this._bindings.length;
        do {
          b--;
        } while (this._bindings[b] && a._priority <= this._bindings[b]._priority);
        this._bindings.splice(b + 1, 0, a);
      },
      _indexOfListener: function (a, b) {
        if (!this._bindings) {
          return -1;
        }
        if (undefined === b) {
          b = null;
        }
        var d;
        for (var c = this._bindings.length; c--;) {
          d = this._bindings[c];
          if (d._listener === a && d.context === b) {
            return c;
          }
        }
        return -1;
      },
      has: function (a, b) {
        return -1 !== this._indexOfListener(a, b);
      },
      add: function (a, b, c) {
        this.validateListener(a, "add");
        var d = [];
        if (arguments.length > 3) {
          for (var e = 3; e < arguments.length; e++) {
            d.push(arguments[e]);
          }
        }
        return this._registerListener(a, false, b, c, d);
      },
      addOnce: function (a, b, c) {
        this.validateListener(a, "addOnce");
        var d = [];
        if (arguments.length > 3) {
          for (var e = 3; e < arguments.length; e++) {
            d.push(arguments[e]);
          }
        }
        return this._registerListener(a, true, b, c, d);
      },
      remove: function (a, b) {
        this.validateListener(a, "remove");
        var c = this._indexOfListener(a, b);
        if (-1 !== c) {
          this._bindings[c]._destroy();
          this._bindings.splice(c, 1);
        }
        return a;
      },
      removeAll: function (a) {
        if (undefined === a) {
          a = null;
        }
        if (this._bindings) {
          for (var b = this._bindings.length; b--;) {
            if (a) {
              if (this._bindings[b].context === a) {
                this._bindings[b]._destroy();
                this._bindings.splice(b, 1);
              }
            } else {
              this._bindings[b]._destroy();
            }
          }
          if (!a) {
            this._bindings.length = 0;
          }
        }
      },
      getNumListeners: function () {
        return this._bindings ? this._bindings.length : 0;
      },
      halt: function () {
        this._shouldPropagate = false;
      },
      dispatch: function () {
        if (this.active && this._bindings) {
          var c;
          var a = Array.prototype.slice.call(arguments);
          var b = this._bindings.length;
          if (this.memorize) {
            this._prevParams = a;
          }
          if (b) {
            c = this._bindings.slice();
            this._shouldPropagate = true;
            do {
              b--;
            } while (c[b] && this._shouldPropagate && false !== c[b].execute(a));
          }
        }
      },
      forget: function () {
        if (this._prevParams) {
          this._prevParams = null;
        }
      },
      dispose: function () {
        this.removeAll();
        this._bindings = null;
        if (this._prevParams) {
          this._prevParams = null;
        }
      },
      toString: function () {
        return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
      }
    };
    Object.defineProperty(b.Signal.prototype, "boundDispatch", {
      get: function () {
        var a = this;
        return this._boundDispatch || (this._boundDispatch = function () {
          return a.dispatch.apply(a, arguments);
        });
      }
    });
    b.Signal.prototype.constructor = b.Signal;
    b.SignalBinding = function (a, b, c, d, e, f) {
      this._listener = b;
      if (c) {
        this._isOnce = true;
      }
      if (null != d) {
        this.context = d;
      }
      this._signal = a;
      if (e) {
        this._priority = e;
      }
      if (f && f.length) {
        this._args = f;
      }
    };
    b.SignalBinding.prototype = {
      context: null,
      _isOnce: false,
      _priority: 0,
      _args: null,
      callCount: 0,
      active: true,
      params: null,
      execute: function (a) {
        var b;
        var c;
        if (this.active && this._listener) {
          c = this.params ? this.params.concat(a) : a;
          if (this._args) {
            c = c.concat(this._args);
          }
          b = this._listener.apply(this.context, c);
          this.callCount++;
          if (this._isOnce) {
            this.detach();
          }
        }
        return b;
      },
      detach: function () {
        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
      },
      isBound: function () {
        return !!this._signal && !!this._listener;
      },
      isOnce: function () {
        return this._isOnce;
      },
      getListener: function () {
        return this._listener;
      },
      getSignal: function () {
        return this._signal;
      },
      _destroy: function () {
        delete this._signal;
        delete this._listener;
        delete this.context;
      },
      toString: function () {
        return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
      }
    };
    b.SignalBinding.prototype.constructor = b.SignalBinding;
    b.Filter = function (a, c, d) {
      this.game = a;
      this.type = b.WEBGL_FILTER;
      this.passes = [this];
      this.shaders = [];
      this.dirty = true;
      this.padding = 0;
      this.prevPoint = new b.Point();
      var e = new Date();
      this.uniforms = {
        resolution: {
          type: "2f",
          value: {
            x: 256,
            y: 256
          }
        },
        time: {
          type: "1f",
          value: 0
        },
        mouse: {
          type: "2f",
          value: {
            x: 0,
            y: 0
          }
        },
        date: {
          type: "4fv",
          value: [e.getFullYear(), e.getMonth(), e.getDate(), 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds()]
        },
        sampleRate: {
          type: "1f",
          value: 44100
        },
        iChannel0: {
          type: "sampler2D",
          value: null,
          textureData: {
            repeat: true
          }
        },
        iChannel1: {
          type: "sampler2D",
          value: null,
          textureData: {
            repeat: true
          }
        },
        iChannel2: {
          type: "sampler2D",
          value: null,
          textureData: {
            repeat: true
          }
        },
        iChannel3: {
          type: "sampler2D",
          value: null,
          textureData: {
            repeat: true
          }
        }
      };
      if (c) {
        for (var f in c) this.uniforms[f] = c[f];
      }
      this.fragmentSrc = d || "";
    };
    b.Filter.prototype = {
      init: function () {},
      setResolution: function (a, b) {
        this.uniforms.resolution.value.x = a;
        this.uniforms.resolution.value.y = b;
      },
      update: function (a) {
        if (undefined !== a) {
          var b = a.x / this.game.width;
          var c = 1 - a.y / this.game.height;
          if (!(b === this.prevPoint.x && c === this.prevPoint.y)) {
            this.uniforms.mouse.value.x = b.toFixed(2);
            this.uniforms.mouse.value.y = c.toFixed(2);
            this.prevPoint.set(b, c);
          }
        }
        this.uniforms.time.value = this.game.time.totalElapsedSeconds();
      },
      addToWorld: function (a, b, c, d, e, f) {
        if (undefined === e) {
          e = 0;
        }
        if (undefined === f) {
          f = 0;
        }
        if (undefined !== c && null !== c) {
          this.width = c;
        } else {
          c = this.width;
        }
        if (undefined !== d && null !== d) {
          this.height = d;
        } else {
          d = this.height;
        }
        var g = this.game.add.image(a, b, "__default");
        g.width = c;
        g.height = d;
        g.anchor.set(e, f);
        g.filters = [this];
        return g;
      },
      destroy: function () {
        this.game = null;
      }
    };
    b.Filter.prototype.constructor = b.Filter;
    Object.defineProperty(b.Filter.prototype, "width", {
      get: function () {
        return this.uniforms.resolution.value.x;
      },
      set: function (a) {
        this.uniforms.resolution.value.x = a;
      }
    });
    Object.defineProperty(b.Filter.prototype, "height", {
      get: function () {
        return this.uniforms.resolution.value.y;
      },
      set: function (a) {
        this.uniforms.resolution.value.y = a;
      }
    });
    b.Plugin = function (a, b) {
      if (undefined === b) {
        b = null;
      }
      this.game = a;
      this.parent = b;
      this.active = false;
      this.visible = false;
      this.hasPreUpdate = false;
      this.hasUpdate = false;
      this.hasPostUpdate = false;
      this.hasRender = false;
      this.hasPostRender = false;
    };
    b.Plugin.prototype = {
      preUpdate: function () {},
      update: function () {},
      render: function () {},
      postRender: function () {},
      destroy: function () {
        this.game = null;
        this.parent = null;
        this.active = false;
        this.visible = false;
      }
    };
    b.Plugin.prototype.constructor = b.Plugin;
    b.PluginManager = function (a) {
      this.game = a;
      this.plugins = [];
      this._len = 0;
      this._i = 0;
    };
    b.PluginManager.prototype = {
      add: function (a) {
        var b = Array.prototype.slice.call(arguments, 1);
        var c = false;
        if ("function" == typeof a) {
          a = new a(this.game, this);
        } else {
          a.game = this.game;
          a.parent = this;
        }
        if ("function" == typeof a.preUpdate) {
          a.hasPreUpdate = true;
          c = true;
        }
        if ("function" == typeof a.update) {
          a.hasUpdate = true;
          c = true;
        }
        if ("function" == typeof a.postUpdate) {
          a.hasPostUpdate = true;
          c = true;
        }
        if ("function" == typeof a.render) {
          a.hasRender = true;
          c = true;
        }
        if ("function" == typeof a.postRender) {
          a.hasPostRender = true;
          c = true;
        }
        return c ? ((a.hasPreUpdate || a.hasUpdate || a.hasPostUpdate) && (a.active = true), (a.hasRender || a.hasPostRender) && (a.visible = true), this._len = this.plugins.push(a), "function" == typeof a.init && a.init.apply(a, b), a) : null;
      },
      remove: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i] === a) {
            if (b) {
              a.destroy();
            }
            this.plugins.splice(this._i, 1);
            return void this._len--;
          }
        }
      },
      removeAll: function () {
        for (this._i = this._len; this._i--;) {
          this.plugins[this._i].destroy();
        }
        this.plugins.length = 0;
        this._len = 0;
      },
      preUpdate: function () {
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) {
            this.plugins[this._i].preUpdate();
          }
        }
      },
      update: function () {
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) {
            this.plugins[this._i].update();
          }
        }
      },
      postUpdate: function () {
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) {
            this.plugins[this._i].postUpdate();
          }
        }
      },
      render: function () {
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) {
            this.plugins[this._i].render();
          }
        }
      },
      postRender: function () {
        for (this._i = this._len; this._i--;) {
          if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) {
            this.plugins[this._i].postRender();
          }
        }
      },
      destroy: function () {
        this.removeAll();
        this.game = null;
      }
    };
    b.PluginManager.prototype.constructor = b.PluginManager;
    b.Stage = function (a) {
      this.game = a;
      PIXI.DisplayObjectContainer.call(this);
      this.name = "_stage_root";
      this.disableVisibilityChange = false;
      this.exists = true;
      this.worldTransform = new PIXI.Matrix();
      this.stage = this;
      this.currentRenderOrderID = 0;
      this._hiddenVar = "hidden";
      this._onChange = null;
      this._bgColor = {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        color: 0,
        rgba: "#000000"
      };
      if (!this.game.transparent) {
        this._bgColor.a = 1;
      }
      if (a.config) {
        this.parseConfig(a.config);
      }
    };
    b.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    b.Stage.prototype.constructor = b.Stage;
    b.Stage.prototype.parseConfig = function (a) {
      if (a.disableVisibilityChange) {
        this.disableVisibilityChange = a.disableVisibilityChange;
      }
      if (a.backgroundColor) {
        this.setBackgroundColor(a.backgroundColor);
      }
    };
    b.Stage.prototype.boot = function () {
      b.DOM.getOffset(this.game.canvas, this.offset);
      b.Canvas.setUserSelect(this.game.canvas, "none");
      b.Canvas.setTouchAction(this.game.canvas, "none");
      this.checkVisibility();
    };
    b.Stage.prototype.preUpdate = function () {
      this.currentRenderOrderID = 0;
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].preUpdate();
      }
    };
    b.Stage.prototype.update = function () {
      for (var a = this.children.length; a--;) {
        this.children[a].update();
      }
    };
    b.Stage.prototype.postUpdate = function () {
      this.game.camera.update();
      if (this.game.camera.target) {
        this.game.camera.target.postUpdate();
        this.updateTransform();
        this.game.camera.updateTarget();
      }
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].postUpdate();
      }
      this.updateTransform();
    };
    b.Stage.prototype.updateTransform = function () {
      this.worldAlpha = 1;
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].updateTransform();
      }
    };
    b.Stage.prototype.checkVisibility = function () {
      if (undefined !== document.hidden) {
        this._hiddenVar = "visibilitychange";
      } else if (undefined !== document.webkitHidden) {
        this._hiddenVar = "webkitvisibilitychange";
      } else if (undefined !== document.mozHidden) {
        this._hiddenVar = "mozvisibilitychange";
      } else if (undefined !== document.msHidden) {
        this._hiddenVar = "msvisibilitychange";
      } else {
        this._hiddenVar = null;
      }
      var a = this;
      this._onChange = function (b) {
        return a.visibilityChange(b);
      };
      if (this._hiddenVar) {
        document.addEventListener(this._hiddenVar, this._onChange, false);
      }
      window.onblur = this._onChange;
      window.onfocus = this._onChange;
      window.onpagehide = this._onChange;
      window.onpageshow = this._onChange;
      if (this.game.device.cocoonJSApp) {
        CocoonJS.App.onSuspended.addEventListener(function () {
          b.Stage.prototype.visibilityChange.call(a, {
            type: "pause"
          });
        });
        CocoonJS.App.onActivated.addEventListener(function () {
          b.Stage.prototype.visibilityChange.call(a, {
            type: "resume"
          });
        });
      }
    };
    b.Stage.prototype.visibilityChange = function (a) {
      if ("pagehide" === a.type || "blur" === a.type || "pageshow" === a.type || "focus" === a.type) {
        return void ("pagehide" === a.type || "blur" === a.type ? this.game.focusLoss(a) : "pageshow" !== a.type && "focus" !== a.type || this.game.focusGain(a));
      }
      if (!this.disableVisibilityChange) {
        if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type) {
          this.game.gamePaused(a);
        } else {
          this.game.gameResumed(a);
        }
      }
    };
    b.Stage.prototype.setBackgroundColor = function (a) {
      if (!this.game.transparent) {
        b.Color.valueToColor(a, this._bgColor);
        b.Color.updateColor(this._bgColor);
        this._bgColor.r /= 255;
        this._bgColor.g /= 255;
        this._bgColor.b /= 255;
        this._bgColor.a = 1;
      }
    };
    b.Stage.prototype.destroy = function () {
      if (this._hiddenVar) {
        document.removeEventListener(this._hiddenVar, this._onChange, false);
      }
      window.onpagehide = null;
      window.onpageshow = null;
      window.onblur = null;
      window.onfocus = null;
    };
    Object.defineProperty(b.Stage.prototype, "backgroundColor", {
      get: function () {
        return this._bgColor.color;
      },
      set: function (a) {
        this.setBackgroundColor(a);
      }
    });
    Object.defineProperty(b.Stage.prototype, "smoothed", {
      get: function () {
        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
      },
      set: function (a) {
        PIXI.scaleModes.DEFAULT = a ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST;
      }
    });
    b.Group = function (a, c, d, e, f, g) {
      if (undefined === e) {
        e = false;
      }
      if (undefined === f) {
        f = false;
      }
      if (undefined === g) {
        g = b.Physics.ARCADE;
      }
      this.game = a;
      if (undefined === c) {
        c = a.world;
      }
      this.name = d || "group";
      this.z = 0;
      PIXI.DisplayObjectContainer.call(this);
      if (e) {
        this.game.stage.addChild(this);
        this.z = this.game.stage.children.length;
      } else if (c) {
        c.addChild(this);
        this.z = c.children.length;
      }
      this.type = b.GROUP;
      this.physicsType = b.GROUP;
      this.alive = true;
      this.exists = true;
      this.ignoreDestroy = false;
      this.pendingDestroy = false;
      this.classType = b.Sprite;
      this.cursor = null;
      this.inputEnableChildren = false;
      this.onChildInputDown = new b.Signal();
      this.onChildInputUp = new b.Signal();
      this.onChildInputOver = new b.Signal();
      this.onChildInputOut = new b.Signal();
      this.enableBody = f;
      this.enableBodyDebug = false;
      this.physicsBodyType = g;
      this.physicsSortDirection = null;
      this.onDestroy = new b.Signal();
      this.cursorIndex = 0;
      this.fixedToCamera = false;
      this.cameraOffset = new b.Point();
      this.hash = [];
      this._sortProperty = "z";
    };
    b.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    b.Group.prototype.constructor = b.Group;
    b.Group.RETURN_NONE = 0;
    b.Group.RETURN_TOTAL = 1;
    b.Group.RETURN_CHILD = 2;
    b.Group.RETURN_ALL = 3;
    b.Group.SORT_ASCENDING = -1;
    b.Group.SORT_DESCENDING = 1;
    b.Group.prototype.add = function (a, b, c) {
      if (undefined === b) {
        b = false;
      }
      return a.parent === this ? a : (a.body && a.parent && a.parent.hash && a.parent.removeFromHash(a), undefined === c ? (a.z = this.children.length, this.addChild(a)) : (this.addChildAt(a, c), this.updateZ()), this.enableBody && a.hasOwnProperty("body") && null === a.body ? this.game.physics.enable(a, this.physicsBodyType) : a.body && this.addToHash(a), !this.inputEnableChildren || a.input && !a.inputEnabled || (a.inputEnabled = true), !b && a.events && a.events.onAddedToGroup$dispatch(a, this), null === this.cursor && (this.cursor = a), a);
    };
    b.Group.prototype.addAt = function (a, b, c) {
      this.add(a, c, b);
    };
    b.Group.prototype.addToHash = function (a) {
      if (a.parent === this) {
        if (-1 === this.hash.indexOf(a)) {
          this.hash.push(a);
          return true;
        }
      }
      return false;
    };
    b.Group.prototype.removeFromHash = function (a) {
      if (a) {
        var b = this.hash.indexOf(a);
        if (-1 !== b) {
          this.hash.splice(b, 1);
          return true;
        }
      }
      return false;
    };
    b.Group.prototype.addMultiple = function (a, c) {
      if (a instanceof b.Group) {
        a.moveAll(this, c);
      } else if (Array.isArray(a)) {
        for (var d = 0; d < a.length; d++) {
          this.add(a[d], c);
        }
      }
      return a;
    };
    b.Group.prototype.getAt = function (a) {
      return a < 0 || a >= this.children.length ? -1 : this.getChildAt(a);
    };
    b.Group.prototype.create = function (a, b, c, d, e, f) {
      if (undefined === e) {
        e = true;
      }
      var g = new this.classType(this.game, a, b, c, d);
      g.exists = e;
      g.visible = e;
      g.alive = e;
      return this.add(g, false, f);
    };
    b.Group.prototype.createMultiple = function (a, b, c, d) {
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = false;
      }
      if (!Array.isArray(b)) {
        b = [b];
      }
      if (!Array.isArray(c)) {
        c = [c];
      }
      var e = this;
      var f = [];
      b.forEach(function (b) {
        c.forEach(function (c) {
          for (var g = 0; g < a; g++) {
            f.push(e.create(0, 0, b, c, d));
          }
        });
      });
      return f;
    };
    b.Group.prototype.updateZ = function () {
      for (var a = this.children.length; a--;) {
        this.children[a].z = a;
      }
    };
    b.Group.prototype.align = function (a, c, d, e, f, g) {
      if (undefined === f) {
        f = b.TOP_LEFT;
      }
      if (undefined === g) {
        g = 0;
      }
      if (0 === this.children.length || g > this.children.length || -1 === a && -1 === c) {
        return false;
      }
      var h = new b.Rectangle(0, 0, d, e);
      var i = a * d;
      var j = c * e;
      for (var k = g; k < this.children.length; k++) {
        var l = this.children[k];
        if (l.alignIn) {
          l.alignIn(h, f);
          if (-1 === a) {
            h.y += e;
            if (h.y === j) {
              h.x += d;
              h.y = 0;
            }
          } else if (-1 === c) {
            h.x += d;
            if (h.x === i) {
              h.x = 0;
              h.y += e;
            }
          } else {
            h.x += d;
            if (h.x === i && (h.x = 0, h.y += e, h.y === j)) {
              return true;
            }
          }
        }
      }
      return true;
    };
    b.Group.prototype.resetCursor = function (a) {
      if (undefined === a) {
        a = 0;
      }
      if (a > this.children.length - 1) {
        a = 0;
      }
      if (this.cursor) {
        this.cursorIndex = a;
        this.cursor = this.children[this.cursorIndex];
        return this.cursor;
      }
    };
    b.Group.prototype.next = function () {
      if (this.cursor) {
        if (this.cursorIndex >= this.children.length - 1) {
          this.cursorIndex = 0;
        } else {
          this.cursorIndex++;
        }
        this.cursor = this.children[this.cursorIndex];
        return this.cursor;
      }
    };
    b.Group.prototype.previous = function () {
      if (this.cursor) {
        if (0 === this.cursorIndex) {
          this.cursorIndex = this.children.length - 1;
        } else {
          this.cursorIndex--;
        }
        this.cursor = this.children[this.cursorIndex];
        return this.cursor;
      }
    };
    b.Group.prototype.swap = function (a, b) {
      this.swapChildren(a, b);
      this.updateZ();
    };
    b.Group.prototype.bringToTop = function (a) {
      if (a.parent === this && this.getIndex(a) < this.children.length) {
        this.remove(a, false, true);
        this.add(a, true);
      }
      return a;
    };
    b.Group.prototype.sendToBack = function (a) {
      if (a.parent === this && this.getIndex(a) > 0) {
        this.remove(a, false, true);
        this.addAt(a, 0, true);
      }
      return a;
    };
    b.Group.prototype.moveUp = function (a) {
      if (a.parent === this && this.getIndex(a) < this.children.length - 1) {
        var b = this.getIndex(a);
        var c = this.getAt(b + 1);
        if (c) {
          this.swap(a, c);
        }
      }
      return a;
    };
    b.Group.prototype.moveDown = function (a) {
      if (a.parent === this && this.getIndex(a) > 0) {
        var b = this.getIndex(a);
        var c = this.getAt(b - 1);
        if (c) {
          this.swap(a, c);
        }
      }
      return a;
    };
    b.Group.prototype.xy = function (a, b, c) {
      if (a < 0 || a > this.children.length) {
        return -1;
      }
      this.getChildAt(a).x = b;
      this.getChildAt(a).y = c;
    };
    b.Group.prototype.reverse = function () {
      this.children.reverse();
      this.updateZ();
    };
    b.Group.prototype.getIndex = function (a) {
      return this.children.indexOf(a);
    };
    b.Group.prototype.getByName = function (a) {
      for (var b = 0; b < this.children.length; b++) {
        if (this.children[b].name === a) {
          return this.children[b];
        }
      }
      return null;
    };
    b.Group.prototype.replace = function (a, c) {
      var d = this.getIndex(a);
      if (-1 !== d) {
        if (c.parent) {
          if (c.parent instanceof b.Group) {
            c.parent.remove(c);
          } else {
            c.parent.removeChild(c);
          }
        }
        this.remove(a);
        this.addAt(c, d);
        return a;
      }
    };
    b.Group.prototype.hasProperty = function (a, b) {
      var c = b.length;
      return 1 === c && b[0] in a || 2 === c && b[0] in a && b[1] in a[b[0]] || 3 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] || 4 === c && b[0] in a && b[1] in a[b[0]] && b[2] in a[b[0]][b[1]] && b[3] in a[b[0]][b[1]][b[2]];
    };
    b.Group.prototype.setProperty = function (a, b, c, d, e) {
      if (undefined === e) {
        e = false;
      }
      d = d || 0;
      if (!this.hasProperty(a, b) && (!e || d > 0)) {
        return false;
      }
      var f = b.length;
      if (1 === f) {
        if (0 === d) {
          a[b[0]] = c;
        } else if (1 === d) {
          a[b[0]] += c;
        } else if (2 === d) {
          a[b[0]] -= c;
        } else if (3 === d) {
          a[b[0]] *= c;
        } else if (4 === d) {
          a[b[0]] /= c;
        }
      } else if (2 === f) {
        if (0 === d) {
          a[b[0]][b[1]] = c;
        } else if (1 === d) {
          a[b[0]][b[1]] += c;
        } else if (2 === d) {
          a[b[0]][b[1]] -= c;
        } else if (3 === d) {
          a[b[0]][b[1]] *= c;
        } else if (4 === d) {
          a[b[0]][b[1]] /= c;
        }
      } else if (3 === f) {
        if (0 === d) {
          a[b[0]][b[1]][b[2]] = c;
        } else if (1 === d) {
          a[b[0]][b[1]][b[2]] += c;
        } else if (2 === d) {
          a[b[0]][b[1]][b[2]] -= c;
        } else if (3 === d) {
          a[b[0]][b[1]][b[2]] *= c;
        } else if (4 === d) {
          a[b[0]][b[1]][b[2]] /= c;
        }
      } else if (4 === f) {
        if (0 === d) {
          a[b[0]][b[1]][b[2]][b[3]] = c;
        } else if (1 === d) {
          a[b[0]][b[1]][b[2]][b[3]] += c;
        } else if (2 === d) {
          a[b[0]][b[1]][b[2]][b[3]] -= c;
        } else if (3 === d) {
          a[b[0]][b[1]][b[2]][b[3]] *= c;
        } else if (4 === d) {
          a[b[0]][b[1]][b[2]][b[3]] /= c;
        }
      }
      return true;
    };
    b.Group.prototype.checkProperty = function (a, c, d, e) {
      if (undefined === e) {
        e = false;
      }
      return !(!b.Utils.getProperty(a, c) && e) && b.Utils.getProperty(a, c) === d;
    };
    b.Group.prototype.set = function (a, b, c, d, e, f, g) {
      if (undefined === g) {
        g = false;
      }
      b = b.split(".");
      if (undefined === d) {
        d = false;
      }
      if (undefined === e) {
        e = false;
      }
      if ((false === d || d && a.alive) && (false === e || e && a.visible)) {
        return this.setProperty(a, b, c, f, g);
      }
    };
    b.Group.prototype.setAll = function (a, b, c, d, e, f) {
      if (undefined === c) {
        c = false;
      }
      if (undefined === d) {
        d = false;
      }
      if (undefined === f) {
        f = false;
      }
      a = a.split(".");
      e = e || 0;
      for (var g = 0; g < this.children.length; g++) {
        if ((!c || c && this.children[g].alive) && (!d || d && this.children[g].visible)) {
          this.setProperty(this.children[g], a, b, e, f);
        }
      }
    };
    b.Group.prototype.setAllChildren = function (a, c, d, e, f, g) {
      if (undefined === d) {
        d = false;
      }
      if (undefined === e) {
        e = false;
      }
      if (undefined === g) {
        g = false;
      }
      f = f || 0;
      for (var h = 0; h < this.children.length; h++) {
        if ((!d || d && this.children[h].alive) && (!e || e && this.children[h].visible)) {
          if (this.children[h] instanceof b.Group) {
            this.children[h].setAllChildren(a, c, d, e, f, g);
          } else {
            this.setProperty(this.children[h], a.split("."), c, f, g);
          }
        }
      }
    };
    b.Group.prototype.checkAll = function (a, b, c, d, e) {
      if (undefined === c) {
        c = false;
      }
      if (undefined === d) {
        d = false;
      }
      if (undefined === e) {
        e = false;
      }
      for (var f = 0; f < this.children.length; f++) {
        if ((!c || c && this.children[f].alive) && (!d || d && this.children[f].visible) && !this.checkProperty(this.children[f], a, b, e)) {
          return false;
        }
      }
      return true;
    };
    b.Group.prototype.addAll = function (a, b, c, d) {
      this.setAll(a, b, c, d, 1);
    };
    b.Group.prototype.subAll = function (a, b, c, d) {
      this.setAll(a, b, c, d, 2);
    };
    b.Group.prototype.multiplyAll = function (a, b, c, d) {
      this.setAll(a, b, c, d, 3);
    };
    b.Group.prototype.divideAll = function (a, b, c, d) {
      this.setAll(a, b, c, d, 4);
    };
    b.Group.prototype.callAllExists = function (a, b) {
      var c;
      if (arguments.length > 2) {
        c = [];
        for (var d = 2; d < arguments.length; d++) {
          c.push(arguments[d]);
        }
      }
      for (var d = 0; d < this.children.length; d++) {
        if (this.children[d].exists === b && this.children[d][a]) {
          this.children[d][a].apply(this.children[d], c);
        }
      }
    };
    b.Group.prototype.callbackFromArray = function (a, b, c) {
      if (1 === c) {
        if (a[b[0]]) {
          return a[b[0]];
        }
      } else if (2 === c) {
        if (a[b[0]][b[1]]) {
          return a[b[0]][b[1]];
        }
      } else if (3 === c) {
        if (a[b[0]][b[1]][b[2]]) {
          return a[b[0]][b[1]][b[2]];
        }
      } else if (4 === c) {
        if (a[b[0]][b[1]][b[2]][b[3]]) {
          return a[b[0]][b[1]][b[2]][b[3]];
        }
      } else if (a[b]) {
        return a[b];
      }
      return false;
    };
    b.Group.prototype.callAll = function (a, b) {
      if (undefined !== a) {
        a = a.split(".");
        var c = a.length;
        if (undefined === b || null === b || "" === b) {
          b = null;
        } else if ("string" == typeof b) {
          b = b.split(".");
          var d = b.length;
        }
        var e;
        if (arguments.length > 2) {
          e = [];
          for (var f = 2; f < arguments.length; f++) {
            e.push(arguments[f]);
          }
        }
        var g = null;
        var h = null;
        for (var f = 0; f < this.children.length; f++) {
          g = this.callbackFromArray(this.children[f], a, c);
          if (b && g) {
            h = this.callbackFromArray(this.children[f], b, d);
            if (g) {
              g.apply(h, e);
            }
          } else if (g) {
            g.apply(this.children[f], e);
          }
        }
      }
    };
    b.Group.prototype.preUpdate = function () {
      if (this.pendingDestroy) {
        this.destroy();
        return false;
      }
      if (!this.exists || !this.parent.exists) {
        this.renderOrderID = -1;
        return false;
      }
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].preUpdate();
      }
      return true;
    };
    b.Group.prototype.update = function () {
      for (var a = this.children.length; a--;) {
        this.children[a].update();
      }
    };
    b.Group.prototype.postUpdate = function () {
      if (this.fixedToCamera) {
        this.x = this.game.camera.view.x + this.cameraOffset.x;
        this.y = this.game.camera.view.y + this.cameraOffset.y;
      }
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].postUpdate();
      }
    };
    b.Group.prototype.filter = function (a, c) {
      var d = -1;
      var e = this.children.length;
      for (var f = []; ++d < e;) {
        var g = this.children[d];
        if ((!c || c && g.exists) && a(g, d, this.children)) {
          f.push(g);
        }
      }
      return new b.ArraySet(f);
    };
    b.Group.prototype.forEach = function (a, b, c) {
      if (undefined === c) {
        c = false;
      }
      if (arguments.length <= 3) {
        for (var d = 0; d < this.children.length; d++) {
          if (!c || c && this.children[d].exists) {
            a.call(b, this.children[d]);
          }
        }
      } else {
        var e = [null];
        for (var d = 3; d < arguments.length; d++) {
          e.push(arguments[d]);
        }
        for (var d = 0; d < this.children.length; d++) {
          if (!c || c && this.children[d].exists) {
            e[0] = this.children[d];
            a.apply(b, e);
          }
        }
      }
    };
    b.Group.prototype.forEachExists = function (a, c) {
      var d;
      if (arguments.length > 2) {
        d = [null];
        for (var e = 2; e < arguments.length; e++) {
          d.push(arguments[e]);
        }
      }
      this.iterate("exists", true, b.Group.RETURN_TOTAL, a, c, d);
    };
    b.Group.prototype.forEachAlive = function (a, c) {
      var d;
      if (arguments.length > 2) {
        d = [null];
        for (var e = 2; e < arguments.length; e++) {
          d.push(arguments[e]);
        }
      }
      this.iterate("alive", true, b.Group.RETURN_TOTAL, a, c, d);
    };
    b.Group.prototype.forEachDead = function (a, c) {
      var d;
      if (arguments.length > 2) {
        d = [null];
        for (var e = 2; e < arguments.length; e++) {
          d.push(arguments[e]);
        }
      }
      this.iterate("alive", false, b.Group.RETURN_TOTAL, a, c, d);
    };
    b.Group.prototype.sort = function (a, c) {
      if (!(this.children.length < 2)) {
        if (undefined === a) {
          a = "z";
        }
        if (undefined === c) {
          c = b.Group.SORT_ASCENDING;
        }
        this._sortProperty = a;
        if (c === b.Group.SORT_ASCENDING) {
          this.children.sort(this.ascendingSortHandler.bind(this));
        } else {
          this.children.sort(this.descendingSortHandler.bind(this));
        }
        this.updateZ();
      }
    };
    b.Group.prototype.customSort = function (a, b) {
      if (!(this.children.length < 2)) {
        this.children.sort(a.bind(b));
        this.updateZ();
      }
    };
    b.Group.prototype.ascendingSortHandler = function (a, b) {
      return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
    };
    b.Group.prototype.descendingSortHandler = function (a, b) {
      return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
    };
    b.Group.prototype.iterate = function (a, c, d, e, f, g) {
      if (0 === this.children.length) {
        if (d === b.Group.RETURN_TOTAL) {
          return 0;
        }
        if (d === b.Group.RETURN_ALL) {
          return [];
        }
      }
      var h = 0;
      if (d === b.Group.RETURN_ALL) {
        var i = [];
      }
      for (var j = 0; j < this.children.length; j++) {
        if (this.children[j][a] === c) {
          h++;
          if (e) {
            if (g) {
              g[0] = this.children[j];
              e.apply(f, g);
            } else {
              e.call(f, this.children[j]);
            }
          }
          if (d === b.Group.RETURN_CHILD) {
            return this.children[j];
          }
          if (d === b.Group.RETURN_ALL) {
            i.push(this.children[j]);
          }
        }
      }
      return d === b.Group.RETURN_TOTAL ? h : d === b.Group.RETURN_ALL ? i : null;
    };
    b.Group.prototype.getFirstExists = function (a, c, d, e, f, g) {
      if (undefined === c) {
        c = false;
      }
      if ("boolean" != typeof a) {
        a = true;
      }
      var h = this.iterate("exists", a, b.Group.RETURN_CHILD);
      return null === h && c ? this.create(d, e, f, g) : this.resetChild(h, d, e, f, g);
    };
    b.Group.prototype.getFirstAlive = function (a, c, d, e, f) {
      if (undefined === a) {
        a = false;
      }
      var g = this.iterate("alive", true, b.Group.RETURN_CHILD);
      return null === g && a ? this.create(c, d, e, f) : this.resetChild(g, c, d, e, f);
    };
    b.Group.prototype.getFirstDead = function (a, c, d, e, f) {
      if (undefined === a) {
        a = false;
      }
      var g = this.iterate("alive", false, b.Group.RETURN_CHILD);
      return null === g && a ? this.create(c, d, e, f) : this.resetChild(g, c, d, e, f);
    };
    b.Group.prototype.resetChild = function (a, b, c, d, e) {
      return null === a ? null : (undefined === b && (b = null), undefined === c && (c = null), null !== b && null !== c && a.reset(b, c), undefined !== d && a.loadTexture(d, e), a);
    };
    b.Group.prototype.getTop = function () {
      if (this.children.length > 0) {
        return this.children[this.children.length - 1];
      }
    };
    b.Group.prototype.getBottom = function () {
      if (this.children.length > 0) {
        return this.children[0];
      }
    };
    b.Group.prototype.getClosestTo = function (a, c, d) {
      var e = Number.MAX_VALUE;
      var f = 0;
      var g = null;
      for (var h = 0; h < this.children.length; h++) {
        var i = this.children[h];
        if (i.exists && (f = Math.abs(b.Point.distance(a, i))) < e && (!c || c.call(d, i, f))) {
          e = f;
          g = i;
        }
      }
      return g;
    };
    b.Group.prototype.getFurthestFrom = function (a, c, d) {
      var e = 0;
      var f = 0;
      var g = null;
      for (var h = 0; h < this.children.length; h++) {
        var i = this.children[h];
        if (i.exists && (f = Math.abs(b.Point.distance(a, i))) > e && (!c || c.call(d, i, f))) {
          e = f;
          g = i;
        }
      }
      return g;
    };
    b.Group.prototype.countLiving = function () {
      return this.iterate("alive", true, b.Group.RETURN_TOTAL);
    };
    b.Group.prototype.countDead = function () {
      return this.iterate("alive", false, b.Group.RETURN_TOTAL);
    };
    b.Group.prototype.getRandom = function (a, c) {
      if (undefined === a) {
        a = 0;
      }
      if (undefined === c) {
        c = this.children.length;
      }
      return 0 === c ? null : b.ArrayUtils.getRandomItem(this.children, a, c);
    };
    b.Group.prototype.getRandomExists = function (a, b) {
      var c = this.getAll("exists", true, a, b);
      return this.game.rnd.pick(c);
    };
    b.Group.prototype.getAll = function (a, b, c, d) {
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = this.children.length;
      }
      var e = [];
      for (var f = c; f < d; f++) {
        var g = this.children[f];
        if (a && g[a] === b) {
          e.push(g);
        }
      }
      return e;
    };
    b.Group.prototype.remove = function (a, b, c) {
      if (undefined === b) {
        b = false;
      }
      if (undefined === c) {
        c = false;
      }
      if (0 === this.children.length || -1 === this.children.indexOf(a)) {
        return false;
      }
      if (!(c || !a.events || a.destroyPhase)) {
        a.events.onRemovedFromGroup$dispatch(a, this);
      }
      var d = this.removeChild(a);
      this.removeFromHash(a);
      this.updateZ();
      if (this.cursor === a) {
        this.next();
      }
      if (b && d) {
        d.destroy(true);
      }
      return true;
    };
    b.Group.prototype.moveAll = function (a, c) {
      if (undefined === c) {
        c = false;
      }
      if (this.children.length > 0 && a instanceof b.Group) {
        do {
          a.add(this.children[0], c);
        } while (this.children.length > 0);
        this.hash = [];
        this.cursor = null;
      }
      return a;
    };
    b.Group.prototype.removeAll = function (a, b, c) {
      if (undefined === a) {
        a = false;
      }
      if (undefined === b) {
        b = false;
      }
      if (undefined === c) {
        c = false;
      }
      if (0 !== this.children.length) {
        do {
          if (!b && this.children[0].events) {
            this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
          }
          var d = this.removeChild(this.children[0]);
          this.removeFromHash(d);
          if (a && d) {
            d.destroy(true, c);
          }
        } while (this.children.length > 0);
        this.hash = [];
        this.cursor = null;
      }
    };
    b.Group.prototype.removeBetween = function (a, b, c, d) {
      if (undefined === b) {
        b = this.children.length - 1;
      }
      if (undefined === c) {
        c = false;
      }
      if (undefined === d) {
        d = false;
      }
      if (0 !== this.children.length) {
        if (a > b || a < 0 || b > this.children.length) {
          return false;
        }
        for (var e = b; e >= a;) {
          if (!d && this.children[e].events) {
            this.children[e].events.onRemovedFromGroup$dispatch(this.children[e], this);
          }
          var f = this.removeChild(this.children[e]);
          this.removeFromHash(f);
          if (c && f) {
            f.destroy(true);
          }
          if (this.cursor === this.children[e]) {
            this.cursor = null;
          }
          e--;
        }
        this.updateZ();
      }
    };
    b.Group.prototype.destroy = function (a, b) {
      if (!(null === this.game || this.ignoreDestroy)) {
        if (undefined === a) {
          a = true;
        }
        if (undefined === b) {
          b = false;
        }
        this.onDestroy.dispatch(this, a, b);
        this.removeAll(a);
        this.cursor = null;
        this.filters = null;
        this.pendingDestroy = false;
        if (!b) {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.game = null;
          this.exists = false;
        }
      }
    };
    Object.defineProperty(b.Group.prototype, "total", {
      get: function () {
        return this.iterate("exists", true, b.Group.RETURN_TOTAL);
      }
    });
    Object.defineProperty(b.Group.prototype, "length", {
      get: function () {
        return this.children.length;
      }
    });
    Object.defineProperty(b.Group.prototype, "angle", {
      get: function () {
        return b.Math.radToDeg(this.rotation);
      },
      set: function (a) {
        this.rotation = b.Math.degToRad(a);
      }
    });
    Object.defineProperty(b.Group.prototype, "centerX", {
      get: function () {
        return this.getBounds(this.parent).centerX;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.x - b.x;
        this.x = a + c - b.halfWidth;
      }
    });
    Object.defineProperty(b.Group.prototype, "centerY", {
      get: function () {
        return this.getBounds(this.parent).centerY;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.y - b.y;
        this.y = a + c - b.halfHeight;
      }
    });
    Object.defineProperty(b.Group.prototype, "left", {
      get: function () {
        return this.getBounds(this.parent).left;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.x - b.x;
        this.x = a + c;
      }
    });
    Object.defineProperty(b.Group.prototype, "right", {
      get: function () {
        return this.getBounds(this.parent).right;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.x - b.x;
        this.x = a + c - b.width;
      }
    });
    Object.defineProperty(b.Group.prototype, "top", {
      get: function () {
        return this.getBounds(this.parent).top;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.y - b.y;
        this.y = a + c;
      }
    });
    Object.defineProperty(b.Group.prototype, "bottom", {
      get: function () {
        return this.getBounds(this.parent).bottom;
      },
      set: function (a) {
        var b = this.getBounds(this.parent);
        var c = this.y - b.y;
        this.y = a + c - b.height;
      }
    });
    b.World = function (a) {
      b.Group.call(this, a, null, "__world", false);
      this.bounds = new b.Rectangle(0, 0, a.width, a.height);
      this.camera = null;
      this._definedSize = false;
      this._width = a.width;
      this._height = a.height;
      this.game.state.onStateChange.add(this.stateChange, this);
    };
    b.World.prototype = Object.create(b.Group.prototype);
    b.World.prototype.constructor = b.World;
    b.World.prototype.boot = function () {
      this.camera = new b.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
      this.game.stage.addChild(this);
      this.camera.boot();
    };
    b.World.prototype.stateChange = function () {
      this.x = 0;
      this.y = 0;
      this.camera.reset();
    };
    b.World.prototype.setBounds = function (a, b, c, d) {
      this._definedSize = true;
      this._width = c;
      this._height = d;
      this.bounds.setTo(a, b, c, d);
      this.x = a;
      this.y = b;
      if (this.camera.bounds) {
        this.camera.bounds.setTo(a, b, Math.max(c, this.game.width), Math.max(d, this.game.height));
      }
      this.game.physics.setBoundsToWorld();
    };
    b.World.prototype.resize = function (a, b) {
      if (this._definedSize) {
        if (a < this._width) {
          a = this._width;
        }
        if (b < this._height) {
          b = this._height;
        }
      }
      this.bounds.width = a;
      this.bounds.height = b;
      this.game.camera.setBoundsToWorld();
      this.game.physics.setBoundsToWorld();
    };
    b.World.prototype.shutdown = function () {
      this.destroy(true, true);
    };
    b.World.prototype.wrap = function (a, b, c, d, e) {
      if (undefined === b) {
        b = 0;
      }
      if (undefined === c) {
        c = false;
      }
      if (undefined === d) {
        d = true;
      }
      if (undefined === e) {
        e = true;
      }
      if (c) {
        a.getBounds();
        if (d) {
          if (a.x + a._currentBounds.width < this.bounds.x) {
            a.x = this.bounds.right;
          } else if (a.x > this.bounds.right) {
            a.x = this.bounds.left;
          }
        }
        if (e) {
          if (a.y + a._currentBounds.height < this.bounds.top) {
            a.y = this.bounds.bottom;
          } else if (a.y > this.bounds.bottom) {
            a.y = this.bounds.top;
          }
        }
      } else {
        if (d && a.x + b < this.bounds.x) {
          a.x = this.bounds.right + b;
        } else if (d && a.x - b > this.bounds.right) {
          a.x = this.bounds.left - b;
        }
        if (e && a.y + b < this.bounds.top) {
          a.y = this.bounds.bottom + b;
        } else if (e && a.y - b > this.bounds.bottom) {
          a.y = this.bounds.top - b;
        }
      }
    };
    Object.defineProperty(b.World.prototype, "width", {
      get: function () {
        return this.bounds.width;
      },
      set: function (a) {
        if (a < this.game.width) {
          a = this.game.width;
        }
        this.bounds.width = a;
        this._width = a;
        this._definedSize = true;
      }
    });
    Object.defineProperty(b.World.prototype, "height", {
      get: function () {
        return this.bounds.height;
      },
      set: function (a) {
        if (a < this.game.height) {
          a = this.game.height;
        }
        this.bounds.height = a;
        this._height = a;
        this._definedSize = true;
      }
    });
    Object.defineProperty(b.World.prototype, "centerX", {
      get: function () {
        return this.bounds.halfWidth + this.bounds.x;
      }
    });
    Object.defineProperty(b.World.prototype, "centerY", {
      get: function () {
        return this.bounds.halfHeight + this.bounds.y;
      }
    });
    Object.defineProperty(b.World.prototype, "randomX", {
      get: function () {
        return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width);
      }
    });
    Object.defineProperty(b.World.prototype, "randomY", {
      get: function () {
        return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height);
      }
    });
    b.Game = function (a, c, d, e, f, g, h, i) {
      this.id = b.GAMES.push(this) - 1;
      this.config = null;
      this.physicsConfig = i;
      this.parent = "";
      this.width = 800;
      this.height = 600;
      this.resolution = 1;
      this._width = 800;
      this._height = 600;
      this.transparent = false;
      this.antialias = true;
      this.preserveDrawingBuffer = false;
      this.clearBeforeRender = true;
      this.renderer = null;
      this.renderType = b.AUTO;
      this.state = null;
      this.isBooted = false;
      this.isRunning = false;
      this.raf = null;
      this.add = null;
      this.make = null;
      this.cache = null;
      this.input = null;
      this.load = null;
      this.math = null;
      this.net = null;
      this.scale = null;
      this.sound = null;
      this.stage = null;
      this.time = null;
      this.tweens = null;
      this.world = null;
      this.physics = null;
      this.plugins = null;
      this.rnd = null;
      this.device = b.Device;
      this.camera = null;
      this.canvas = null;
      this.context = null;
      this.debug = null;
      this.particles = null;
      this.create = null;
      this.lockRender = false;
      this.stepping = false;
      this.pendingStep = false;
      this.stepCount = 0;
      this.onPause = null;
      this.onResume = null;
      this.onBlur = null;
      this.onFocus = null;
      this._paused = false;
      this._codePaused = false;
      this.currentUpdateID = 0;
      this.updatesThisFrame = 1;
      this._deltaTime = 0;
      this._lastCount = 0;
      this._spiraling = 0;
      this._kickstart = true;
      this.fpsProblemNotifier = new b.Signal();
      this.forceSingleUpdate = true;
      this._nextFpsNotification = 0;
      if (1 === arguments.length && "object" == typeof arguments[0]) {
        this.parseConfig(arguments[0]);
      } else {
        this.config = {
          enableDebug: true
        };
        if (undefined !== a) {
          this._width = a;
        }
        if (undefined !== c) {
          this._height = c;
        }
        if (undefined !== d) {
          this.renderType = d;
        }
        if (undefined !== e) {
          this.parent = e;
        }
        if (undefined !== g) {
          this.transparent = g;
        }
        if (undefined !== h) {
          this.antialias = h;
        }
        this.rnd = new b.RandomDataGenerator([(Date.now() * Math.random()).toString()]);
        this.state = new b.StateManager(this, f);
      }
      this.device.whenReady(this.boot, this);
      return this;
    };
    b.Game.prototype = {
      parseConfig: function (a) {
        this.config = a;
        if (undefined === a.enableDebug) {
          this.config.enableDebug = true;
        }
        if (a.width) {
          this._width = a.width;
        }
        if (a.height) {
          this._height = a.height;
        }
        if (a.renderer) {
          this.renderType = a.renderer;
        }
        if (a.parent) {
          this.parent = a.parent;
        }
        if (undefined !== a.transparent) {
          this.transparent = a.transparent;
        }
        if (undefined !== a.antialias) {
          this.antialias = a.antialias;
        }
        if (a.resolution) {
          this.resolution = a.resolution;
        }
        if (undefined !== a.preserveDrawingBuffer) {
          this.preserveDrawingBuffer = a.preserveDrawingBuffer;
        }
        if (a.physicsConfig) {
          this.physicsConfig = a.physicsConfig;
        }
        var c = [(Date.now() * Math.random()).toString()];
        if (a.seed) {
          c = a.seed;
        }
        this.rnd = new b.RandomDataGenerator(c);
        var d = null;
        if (a.state) {
          d = a.state;
        }
        this.state = new b.StateManager(this, d);
      },
      boot: function () {
        if (!this.isBooted) {
          this.onPause = new b.Signal();
          this.onResume = new b.Signal();
          this.onBlur = new b.Signal();
          this.onFocus = new b.Signal();
          this.isBooted = true;
          PIXI.game = this;
          this.math = b.Math;
          this.scale = new b.ScaleManager(this, this._width, this._height);
          this.stage = new b.Stage(this);
          this.setUpRenderer();
          this.world = new b.World(this);
          this.add = new b.GameObjectFactory(this);
          this.make = new b.GameObjectCreator(this);
          this.cache = new b.Cache(this);
          this.load = new b.Loader(this);
          this.time = new b.Time(this);
          this.tweens = new b.TweenManager(this);
          this.input = new b.Input(this);
          this.sound = new b.SoundManager(this);
          this.physics = new b.Physics(this, this.physicsConfig);
          this.particles = new b.Particles(this);
          this.create = new b.Create(this);
          this.plugins = new b.PluginManager(this);
          this.net = new b.Net(this);
          this.time.boot();
          this.stage.boot();
          this.world.boot();
          this.scale.boot();
          this.input.boot();
          this.sound.boot();
          this.state.boot();
          if (this.config.enableDebug) {
            this.debug = new b.Utils.Debug(this);
            this.debug.boot();
          } else {
            this.debug = {
              preUpdate: function () {},
              update: function () {},
              reset: function () {}
            };
          }
          this.showDebugHeader();
          this.isRunning = true;
          if (this.config && this.config.forceSetTimeOut) {
            this.raf = new b.RequestAnimationFrame(this, this.config.forceSetTimeOut);
          } else {
            this.raf = new b.RequestAnimationFrame(this, false);
          }
          this._kickstart = true;
          if (window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus)) {
            window.focus();
          }
          this.raf.start();
        }
      },
      showDebugHeader: function () {
        if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
          var a = b.VERSION;
          var c = "Canvas";
          var d = "HTML Audio";
          var e = 1;
          if (this.renderType === b.WEBGL) {
            c = "WebGL";
            e++;
          } else if (this.renderType === b.HEADLESS) {
            c = "Headless";
          }
          if (this.device.webAudio) {
            d = "WebAudio";
            e++;
          }
          if (this.device.chrome) {
            var f = ["%c %c %c Phaser v" + a + " | Pixi.js | " + c + " | " + d + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"];
            for (var g = 0; g < 3; g++) {
              if (g < e) {
                f.push("color: #ff2424; background: #fff");
              } else {
                f.push("color: #959595; background: #fff");
              }
            }
            console.log.apply(console, f);
          } else if (window.console) {
            console.log("Phaser v" + a + " | Pixi.js " + PIXI.VERSION + " | " + c + " | " + d + " | http://phaser.io");
          }
        }
      },
      setUpRenderer: function () {
        if (this.config.canvas) {
          this.canvas = this.config.canvas;
        } else {
          this.canvas = b.Canvas.create(this, this.width, this.height, this.config.canvasID, true);
        }
        if (this.config.canvasStyle) {
          this.canvas.style = this.config.canvasStyle;
        } else {
          this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
        }
        if (this.renderType === b.HEADLESS || this.renderType === b.CANVAS || this.renderType === b.AUTO && !this.device.webGL) {
          if (!this.device.canvas) {
            throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
          }
          this.renderType = b.CANVAS;
          this.renderer = new PIXI.CanvasRenderer(this);
          this.context = this.renderer.context;
        } else {
          this.renderType = b.WEBGL;
          this.renderer = new PIXI.WebGLRenderer(this);
          this.context = null;
          this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), false);
          this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), false);
        }
        if (this.device.cocoonJS) {
          this.canvas.screencanvas = this.renderType === b.CANVAS;
        }
        if (this.renderType !== b.HEADLESS) {
          this.stage.smoothed = this.antialias;
          b.Canvas.addToDOM(this.canvas, this.parent, false);
          b.Canvas.setTouchAction(this.canvas);
        }
      },
      contextLost: function (a) {
        a.preventDefault();
        this.renderer.contextLost = true;
      },
      contextRestored: function () {
        this.renderer.initContext();
        this.cache.clearGLTextures();
        this.renderer.contextLost = false;
      },
      update: function (a) {
        this.time.update(a);
        if (this._kickstart) {
          this.updateLogic(this.time.desiredFpsMult);
          this.updateRender(this.time.slowMotion * this.time.desiredFps);
          return void (this._kickstart = false);
        }
        if (this._spiraling > 1 && !this.forceSingleUpdate) {
          if (this.time.time > this._nextFpsNotification) {
            this._nextFpsNotification = this.time.time + 1e4;
            this.fpsProblemNotifier.dispatch();
          }
          this._deltaTime = 0;
          this._spiraling = 0;
          this.updateRender(this.time.slowMotion * this.time.desiredFps);
        } else {
          var b = 1e3 * this.time.slowMotion / this.time.desiredFps;
          this._deltaTime += Math.max(Math.min(3 * b, this.time.elapsed), 0);
          var c = 0;
          this.updatesThisFrame = Math.floor(this._deltaTime / b);
          for (this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= b && (this._deltaTime -= b, this.currentUpdateID = c, this.updateLogic(this.time.desiredFpsMult), c++, !this.forceSingleUpdate || 1 !== c);) {
            this.time.refresh();
          }
          if (c > this._lastCount) {
            this._spiraling++;
          } else if (c < this._lastCount) {
            this._spiraling = 0;
          }
          this._lastCount = c;
          this.updateRender(this._deltaTime / b);
        }
      },
      updateLogic: function (a) {
        if (this._paused || this.pendingStep) {
          this.scale.pauseUpdate();
          this.state.pauseUpdate();
          this.debug.preUpdate();
        } else {
          if (this.stepping) {
            this.pendingStep = true;
          }
          this.scale.preUpdate();
          this.debug.preUpdate();
          this.camera.preUpdate();
          this.physics.preUpdate();
          this.state.preUpdate(a);
          this.plugins.preUpdate(a);
          this.stage.preUpdate();
          this.state.update();
          this.stage.update();
          this.tweens.update();
          this.sound.update();
          this.input.update();
          this.physics.update();
          this.particles.update();
          this.plugins.update();
          this.stage.postUpdate();
          this.plugins.postUpdate();
        }
        this.stage.updateTransform();
      },
      updateRender: function (a) {
        if (!this.lockRender) {
          this.state.preRender(a);
          if (this.renderType !== b.HEADLESS) {
            this.renderer.render(this.stage);
            this.plugins.render(a);
            this.state.render(a);
          }
          this.plugins.postRender(a);
        }
      },
      enableStep: function () {
        this.stepping = true;
        this.pendingStep = false;
        this.stepCount = 0;
      },
      disableStep: function () {
        this.stepping = false;
        this.pendingStep = false;
      },
      step: function () {
        this.pendingStep = false;
        this.stepCount++;
      },
      destroy: function () {
        this.raf.stop();
        this.state.destroy();
        this.sound.destroy();
        this.scale.destroy();
        this.stage.destroy();
        this.input.destroy();
        this.physics.destroy();
        this.plugins.destroy();
        this.state = null;
        this.sound = null;
        this.scale = null;
        this.stage = null;
        this.input = null;
        this.physics = null;
        this.plugins = null;
        this.cache = null;
        this.load = null;
        this.time = null;
        this.world = null;
        this.isBooted = false;
        this.renderer.destroy(false);
        b.Canvas.removeFromDOM(this.canvas);
        PIXI.defaultRenderer = null;
        b.GAMES[this.id] = null;
      },
      gamePaused: function (a) {
        if (!this._paused) {
          this._paused = true;
          this.time.gamePaused();
          if (this.sound.muteOnPause) {
            this.sound.setMute();
          }
          this.onPause.dispatch(a);
          if (this.device.cordova && this.device.iOS) {
            this.lockRender = true;
          }
        }
      },
      gameResumed: function (a) {
        if (this._paused && !this._codePaused) {
          this._paused = false;
          this.time.gameResumed();
          this.input.reset();
          if (this.sound.muteOnPause) {
            this.sound.unsetMute();
          }
          this.onResume.dispatch(a);
          if (this.device.cordova && this.device.iOS) {
            this.lockRender = false;
          }
        }
      },
      focusLoss: function (a) {
        this.onBlur.dispatch(a);
        if (!this.stage.disableVisibilityChange) {
          this.gamePaused(a);
        }
      },
      focusGain: function (a) {
        this.onFocus.dispatch(a);
        if (!this.stage.disableVisibilityChange) {
          this.gameResumed(a);
        }
      }
    };
    b.Game.prototype.constructor = b.Game;
    Object.defineProperty(b.Game.prototype, "paused", {
      get: function () {
        return this._paused;
      },
      set: function (a) {
        if (true === a) {
          if (false === this._paused) {
            this._paused = true;
            this.sound.setMute();
            this.time.gamePaused();
            this.onPause.dispatch(this);
          }
          this._codePaused = true;
        } else {
          if (this._paused) {
            this._paused = false;
            this.input.reset();
            this.sound.unsetMute();
            this.time.gameResumed();
            this.onResume.dispatch(this);
          }
          this._codePaused = false;
        }
      }
    });
    b.Input = function (a) {
      this.game = a;
      this.hitCanvas = null;
      this.hitContext = null;
      this.moveCallbacks = [];
      this.customCandidateHandler = null;
      this.customCandidateHandlerContext = null;
      this.pollRate = 0;
      this.enabled = true;
      this.multiInputOverride = b.Input.MOUSE_TOUCH_COMBINE;
      this.position = null;
      this.speed = null;
      this.circle = null;
      this.scale = null;
      this.maxPointers = -1;
      this.tapRate = 200;
      this.doubleTapRate = 300;
      this.holdRate = 2e3;
      this.justPressedRate = 200;
      this.justReleasedRate = 200;
      this.recordPointerHistory = false;
      this.recordRate = 100;
      this.recordLimit = 100;
      this.pointer1 = null;
      this.pointer2 = null;
      this.pointer3 = null;
      this.pointer4 = null;
      this.pointer5 = null;
      this.pointer6 = null;
      this.pointer7 = null;
      this.pointer8 = null;
      this.pointer9 = null;
      this.pointer10 = null;
      this.pointers = [];
      this.activePointer = null;
      this.mousePointer = null;
      this.mouse = null;
      this.keyboard = null;
      this.touch = null;
      this.mspointer = null;
      this.gamepad = null;
      this.resetLocked = false;
      this.onDown = null;
      this.onUp = null;
      this.onTap = null;
      this.onHold = null;
      this.minPriorityID = 0;
      this.interactiveItems = new b.ArraySet();
      this._localPoint = new b.Point();
      this._pollCounter = 0;
      this._oldPosition = null;
      this._x = 0;
      this._y = 0;
    };
    b.Input.MOUSE_OVERRIDES_TOUCH = 0;
    b.Input.TOUCH_OVERRIDES_MOUSE = 1;
    b.Input.MOUSE_TOUCH_COMBINE = 2;
    b.Input.MAX_POINTERS = 10;
    b.Input.prototype = {
      boot: function () {
        this.mousePointer = new b.Pointer(this.game, 0, b.PointerMode.CURSOR);
        this.addPointer();
        this.addPointer();
        this.mouse = new b.Mouse(this.game);
        this.touch = new b.Touch(this.game);
        this.mspointer = new b.MSPointer(this.game);
        if (b.Keyboard) {
          this.keyboard = new b.Keyboard(this.game);
        }
        if (b.Gamepad) {
          this.gamepad = new b.Gamepad(this.game);
        }
        this.onDown = new b.Signal();
        this.onUp = new b.Signal();
        this.onTap = new b.Signal();
        this.onHold = new b.Signal();
        this.scale = new b.Point(1, 1);
        this.speed = new b.Point();
        this.position = new b.Point();
        this._oldPosition = new b.Point();
        this.circle = new b.Circle(0, 0, 44);
        this.activePointer = this.mousePointer;
        this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1);
        this.hitContext = this.hitCanvas.getContext("2d");
        this.mouse.start();
        this.touch.start();
        this.mspointer.start();
        this.mousePointer.active = true;
        if (this.keyboard) {
          this.keyboard.start();
        }
        var a = this;
        this._onClickTrampoline = function (b) {
          a.onClickTrampoline(b);
        };
        this.game.canvas.addEventListener("click", this._onClickTrampoline, false);
      },
      destroy: function () {
        this.mouse.stop();
        this.touch.stop();
        this.mspointer.stop();
        if (this.keyboard) {
          this.keyboard.stop();
        }
        if (this.gamepad) {
          this.gamepad.stop();
        }
        this.moveCallbacks = [];
        PIXI.CanvasPool.remove(this);
        this.game.canvas.removeEventListener("click", this._onClickTrampoline);
      },
      setInteractiveCandidateHandler: function (a, b) {
        this.customCandidateHandler = a;
        this.customCandidateHandlerContext = b;
      },
      addMoveCallback: function (a, b) {
        this.moveCallbacks.push({
          callback: a,
          context: b
        });
      },
      deleteMoveCallback: function (a, b) {
        for (var c = this.moveCallbacks.length; c--;) {
          if (this.moveCallbacks[c].callback === a && this.moveCallbacks[c].context === b) {
            return void this.moveCallbacks.splice(c, 1);
          }
        }
      },
      addPointer: function () {
        if (this.pointers.length >= b.Input.MAX_POINTERS) {
          console.warn("Phaser.Input.addPointer: Maximum limit of " + b.Input.MAX_POINTERS + " pointers reached.");
          return null;
        }
        var a = this.pointers.length + 1;
        var c = new b.Pointer(this.game, a, b.PointerMode.TOUCH);
        this.pointers.push(c);
        this["pointer" + a] = c;
        return c;
      },
      update: function () {
        if (this.keyboard) {
          this.keyboard.update();
        }
        if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
          return void this._pollCounter++;
        }
        this.speed.x = this.position.x - this._oldPosition.x;
        this.speed.y = this.position.y - this._oldPosition.y;
        this._oldPosition.copyFrom(this.position);
        this.mousePointer.update();
        if (this.gamepad && this.gamepad.active) {
          this.gamepad.update();
        }
        for (var a = 0; a < this.pointers.length; a++) {
          this.pointers[a].update();
        }
        this._pollCounter = 0;
      },
      reset: function (a) {
        if (this.game.isBooted && !this.resetLocked) {
          if (undefined === a) {
            a = false;
          }
          this.mousePointer.reset();
          if (this.keyboard) {
            this.keyboard.reset(a);
          }
          if (this.gamepad) {
            this.gamepad.reset();
          }
          for (var c = 0; c < this.pointers.length; c++) {
            this.pointers[c].reset();
          }
          if ("none" !== this.game.canvas.style.cursor) {
            this.game.canvas.style.cursor = "inherit";
          }
          if (a) {
            this.onDown.dispose();
            this.onUp.dispose();
            this.onTap.dispose();
            this.onHold.dispose();
            this.onDown = new b.Signal();
            this.onUp = new b.Signal();
            this.onTap = new b.Signal();
            this.onHold = new b.Signal();
            this.moveCallbacks = [];
          }
          this._pollCounter = 0;
        }
      },
      resetSpeed: function (a, b) {
        this._oldPosition.setTo(a, b);
        this.speed.setTo(0, 0);
      },
      startPointer: function (a) {
        if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) {
          return null;
        }
        if (!this.pointer1.active) {
          return this.pointer1.start(a);
        }
        if (!this.pointer2.active) {
          return this.pointer2.start(a);
        }
        for (var b = 2; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (!c.active) {
            return c.start(a);
          }
        }
        return null;
      },
      updatePointer: function (a) {
        if (this.pointer1.active && this.pointer1.identifier === a.identifier) {
          return this.pointer1.move(a);
        }
        if (this.pointer2.active && this.pointer2.identifier === a.identifier) {
          return this.pointer2.move(a);
        }
        for (var b = 2; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (c.active && c.identifier === a.identifier) {
            return c.move(a);
          }
        }
        return null;
      },
      stopPointer: function (a) {
        if (this.pointer1.active && this.pointer1.identifier === a.identifier) {
          return this.pointer1.stop(a);
        }
        if (this.pointer2.active && this.pointer2.identifier === a.identifier) {
          return this.pointer2.stop(a);
        }
        for (var b = 2; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (c.active && c.identifier === a.identifier) {
            return c.stop(a);
          }
        }
        return null;
      },
      countActivePointers: function (a) {
        if (undefined === a) {
          a = this.pointers.length;
        }
        var b = a;
        for (var c = 0; c < this.pointers.length && b > 0; c++) {
          if (this.pointers[c].active) {
            b--;
          }
        }
        return a - b;
      },
      getPointer: function (a) {
        if (undefined === a) {
          a = false;
        }
        for (var b = 0; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (c.active === a) {
            return c;
          }
        }
        return null;
      },
      getPointerFromIdentifier: function (a) {
        for (var b = 0; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (c.identifier === a) {
            return c;
          }
        }
        return null;
      },
      getPointerFromId: function (a) {
        for (var b = 0; b < this.pointers.length; b++) {
          var c = this.pointers[b];
          if (c.pointerId === a) {
            return c;
          }
        }
        return null;
      },
      getLocalPosition: function (a, c, d) {
        if (undefined === d) {
          d = new b.Point();
        }
        var e = a.worldTransform;
        var f = 1 / (e.a * e.d + e.c * -e.b);
        return d.setTo(e.d * f * c.x + -e.c * f * c.y + (e.ty * e.c - e.tx * e.d) * f, e.a * f * c.y + -e.b * f * c.x + (-e.ty * e.a + e.tx * e.b) * f);
      },
      hitTest: function (a, c, d) {
        if (!a.worldVisible) {
          return false;
        }
        this.getLocalPosition(a, c, this._localPoint);
        d.copyFrom(this._localPoint);
        if (a.hitArea && a.hitArea.contains) {
          return a.hitArea.contains(this._localPoint.x, this._localPoint.y);
        }
        if (a instanceof b.TileSprite) {
          var e = a.width;
          var f = a.height;
          var g = -e * a.anchor.x;
          if (this._localPoint.x >= g && this._localPoint.x < g + e) {
            var h = -f * a.anchor.y;
            if (this._localPoint.y >= h && this._localPoint.y < h + f) {
              return true;
            }
          }
        } else if (a instanceof PIXI.Sprite) {
          var e = a.texture.frame.width;
          var f = a.texture.frame.height;
          var g = -e * a.anchor.x;
          if (this._localPoint.x >= g && this._localPoint.x < g + e) {
            var h = -f * a.anchor.y;
            if (this._localPoint.y >= h && this._localPoint.y < h + f) {
              return true;
            }
          }
        } else if (a instanceof b.Graphics) {
          for (var i = 0; i < a.graphicsData.length; i++) {
            var j = a.graphicsData[i];
            if (j.fill && j.shape && j.shape.contains(this._localPoint.x, this._localPoint.y)) {
              return true;
            }
          }
        }
        for (var i = 0; i < a.children.length; i++) {
          if (this.hitTest(a.children[i], c, d)) {
            return true;
          }
        }
        return false;
      },
      onClickTrampoline: function () {
        this.activePointer.processClickTrampolines();
      }
    };
    b.Input.prototype.constructor = b.Input;
    Object.defineProperty(b.Input.prototype, "x", {
      get: function () {
        return this._x;
      },
      set: function (a) {
        this._x = Math.floor(a);
      }
    });
    Object.defineProperty(b.Input.prototype, "y", {
      get: function () {
        return this._y;
      },
      set: function (a) {
        this._y = Math.floor(a);
      }
    });
    Object.defineProperty(b.Input.prototype, "pollLocked", {
      get: function () {
        return this.pollRate > 0 && this._pollCounter < this.pollRate;
      }
    });
    Object.defineProperty(b.Input.prototype, "totalInactivePointers", {
      get: function () {
        return this.pointers.length - this.countActivePointers();
      }
    });
    Object.defineProperty(b.Input.prototype, "totalActivePointers", {
      get: function () {
        return this.countActivePointers();
      }
    });
    Object.defineProperty(b.Input.prototype, "worldX", {
      get: function () {
        return this.game.camera.view.x + this.x;
      }
    });
    Object.defineProperty(b.Input.prototype, "worldY", {
      get: function () {
        return this.game.camera.view.y + this.y;
      }
    });
    b.Mouse = function (a) {
      this.game = a;
      this.input = a.input;
      this.callbackContext = this.game;
      this.mouseDownCallback = null;
      this.mouseUpCallback = null;
      this.mouseOutCallback = null;
      this.mouseOverCallback = null;
      this.mouseWheelCallback = null;
      this.capture = false;
      this.button = -1;
      this.wheelDelta = 0;
      this.enabled = true;
      this.locked = false;
      this.stopOnGameOut = false;
      this.pointerLock = new b.Signal();
      this.event = null;
      this._onMouseDown = null;
      this._onMouseMove = null;
      this._onMouseUp = null;
      this._onMouseOut = null;
      this._onMouseOver = null;
      this._onMouseWheel = null;
      this._wheelEvent = null;
    };
    b.Mouse.NO_BUTTON = -1;
    b.Mouse.LEFT_BUTTON = 0;
    b.Mouse.MIDDLE_BUTTON = 1;
    b.Mouse.RIGHT_BUTTON = 2;
    b.Mouse.BACK_BUTTON = 3;
    b.Mouse.FORWARD_BUTTON = 4;
    b.Mouse.WHEEL_UP = 1;
    b.Mouse.WHEEL_DOWN = -1;
    b.Mouse.prototype = {
      start: function () {
        if ((!this.game.device.android || false !== this.game.device.chrome) && null === this._onMouseDown) {
          var a = this;
          this._onMouseDown = function (b) {
            return a.onMouseDown(b);
          };
          this._onMouseMove = function (b) {
            return a.onMouseMove(b);
          };
          this._onMouseUp = function (b) {
            return a.onMouseUp(b);
          };
          this._onMouseUpGlobal = function (b) {
            return a.onMouseUpGlobal(b);
          };
          this._onMouseOutGlobal = function (b) {
            return a.onMouseOutGlobal(b);
          };
          this._onMouseOut = function (b) {
            return a.onMouseOut(b);
          };
          this._onMouseOver = function (b) {
            return a.onMouseOver(b);
          };
          this._onMouseWheel = function (b) {
            return a.onMouseWheel(b);
          };
          var b = this.game.canvas;
          b.addEventListener("mousedown", this._onMouseDown, true);
          b.addEventListener("mousemove", this._onMouseMove, true);
          b.addEventListener("mouseup", this._onMouseUp, true);
          if (!this.game.device.cocoonJS) {
            window.addEventListener("mouseup", this._onMouseUpGlobal, true);
            window.addEventListener("mouseout", this._onMouseOutGlobal, true);
            b.addEventListener("mouseover", this._onMouseOver, true);
            b.addEventListener("mouseout", this._onMouseOut, true);
          }
          var c = this.game.device.wheelEvent;
          if (c) {
            b.addEventListener(c, this._onMouseWheel, true);
            if ("mousewheel" === c) {
              this._wheelEvent = new d(-.025, 1);
            } else if ("DOMMouseScroll" === c) {
              this._wheelEvent = new d(1, 1);
            }
          }
        }
      },
      onMouseDown: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.mouseDownCallback) {
          this.mouseDownCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = 0;
          this.input.mousePointer.start(a);
        }
      },
      onMouseMove: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.mouseMoveCallback) {
          this.mouseMoveCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = 0;
          this.input.mousePointer.move(a);
        }
      },
      onMouseUp: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.mouseUpCallback) {
          this.mouseUpCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = 0;
          this.input.mousePointer.stop(a);
        }
      },
      onMouseUpGlobal: function (a) {
        if (!this.input.mousePointer.withinGame) {
          if (this.mouseUpCallback) {
            this.mouseUpCallback.call(this.callbackContext, a);
          }
          a.identifier = 0;
          this.input.mousePointer.stop(a);
        }
      },
      onMouseOutGlobal: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        this.input.mousePointer.withinGame = false;
        if (this.input.enabled && this.enabled) {
          this.input.mousePointer.stop(a);
          this.input.mousePointer.leftButton.stop(a);
          this.input.mousePointer.rightButton.stop(a);
        }
      },
      onMouseOut: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        this.input.mousePointer.withinGame = false;
        if (this.mouseOutCallback) {
          this.mouseOutCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled && this.stopOnGameOut) {
          a.identifier = 0;
          this.input.mousePointer.stop(a);
        }
      },
      onMouseOver: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        this.input.mousePointer.withinGame = true;
        if (this.mouseOverCallback) {
          this.mouseOverCallback.call(this.callbackContext, a);
        }
      },
      onMouseWheel: function (a) {
        if (this._wheelEvent) {
          a = this._wheelEvent.bindEvent(a);
        }
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        this.wheelDelta = b.Math.clamp(-a.deltaY, -1, 1);
        if (this.mouseWheelCallback) {
          this.mouseWheelCallback.call(this.callbackContext, a);
        }
      },
      requestPointerLock: function () {
        if (this.game.device.pointerLock) {
          var a = this.game.canvas;
          a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock;
          a.requestPointerLock();
          var b = this;
          this._pointerLockChange = function (a) {
            return b.pointerLockChange(a);
          };
          document.addEventListener("pointerlockchange", this._pointerLockChange, true);
          document.addEventListener("mozpointerlockchange", this._pointerLockChange, true);
          document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true);
        }
      },
      pointerLockChange: function (a) {
        var b = this.game.canvas;
        if (document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b) {
          this.locked = true;
          this.pointerLock.dispatch(true, a);
        } else {
          this.locked = false;
          this.pointerLock.dispatch(false, a);
        }
      },
      releasePointerLock: function () {
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
        document.exitPointerLock();
        document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
        document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
        document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
      },
      stop: function () {
        var a = this.game.canvas;
        a.removeEventListener("mousedown", this._onMouseDown, true);
        a.removeEventListener("mousemove", this._onMouseMove, true);
        a.removeEventListener("mouseup", this._onMouseUp, true);
        a.removeEventListener("mouseover", this._onMouseOver, true);
        a.removeEventListener("mouseout", this._onMouseOut, true);
        var b = this.game.device.wheelEvent;
        if (b) {
          a.removeEventListener(b, this._onMouseWheel, true);
        }
        window.removeEventListener("mouseup", this._onMouseUpGlobal, true);
        window.removeEventListener("mouseout", this._onMouseOutGlobal, true);
        document.removeEventListener("pointerlockchange", this._pointerLockChange, true);
        document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
        document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, true);
      }
    };
    b.Mouse.prototype.constructor = b.Mouse;
    d.prototype = {};
    d.prototype.constructor = d;
    d.prototype.bindEvent = function (a) {
      if (!d._stubsGenerated && a) {
        var b = function (a) {
          return function () {
            var b = this.originalEvent[a];
            return "function" != typeof b ? b : b.bind(this.originalEvent);
          };
        };
        for (var c in a) if (!(c in d.prototype)) {
          Object.defineProperty(d.prototype, c, {
            get: b(c)
          });
        }
        d._stubsGenerated = true;
      }
      this.originalEvent = a;
      return this;
    };
    Object.defineProperties(d.prototype, {
      type: {
        value: "wheel"
      },
      deltaMode: {
        get: function () {
          return this._deltaMode;
        }
      },
      deltaY: {
        get: function () {
          return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
        }
      },
      deltaX: {
        get: function () {
          return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
        }
      },
      deltaZ: {
        value: 0
      }
    });
    b.MSPointer = function (a) {
      this.game = a;
      this.input = a.input;
      this.callbackContext = this.game;
      this.pointerDownCallback = null;
      this.pointerMoveCallback = null;
      this.pointerUpCallback = null;
      this.capture = true;
      this.button = -1;
      this.event = null;
      this.enabled = true;
      this._onMSPointerDown = null;
      this._onMSPointerMove = null;
      this._onMSPointerUp = null;
      this._onMSPointerUpGlobal = null;
      this._onMSPointerOut = null;
      this._onMSPointerOver = null;
    };
    b.MSPointer.prototype = {
      start: function () {
        if (null === this._onMSPointerDown) {
          var a = this;
          if (this.game.device.mspointer) {
            this._onMSPointerDown = function (b) {
              return a.onPointerDown(b);
            };
            this._onMSPointerMove = function (b) {
              return a.onPointerMove(b);
            };
            this._onMSPointerUp = function (b) {
              return a.onPointerUp(b);
            };
            this._onMSPointerUpGlobal = function (b) {
              return a.onPointerUpGlobal(b);
            };
            this._onMSPointerOut = function (b) {
              return a.onPointerOut(b);
            };
            this._onMSPointerOver = function (b) {
              return a.onPointerOver(b);
            };
            var b = this.game.canvas;
            b.addEventListener("MSPointerDown", this._onMSPointerDown, false);
            b.addEventListener("MSPointerMove", this._onMSPointerMove, false);
            b.addEventListener("MSPointerUp", this._onMSPointerUp, false);
            b.addEventListener("pointerdown", this._onMSPointerDown, false);
            b.addEventListener("pointermove", this._onMSPointerMove, false);
            b.addEventListener("pointerup", this._onMSPointerUp, false);
            b.style["-ms-content-zooming"] = "none";
            b.style["-ms-touch-action"] = "none";
            if (!this.game.device.cocoonJS) {
              window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, true);
              b.addEventListener("MSPointerOver", this._onMSPointerOver, true);
              b.addEventListener("MSPointerOut", this._onMSPointerOut, true);
              window.addEventListener("pointerup", this._onMSPointerUpGlobal, true);
              b.addEventListener("pointerover", this._onMSPointerOver, true);
              b.addEventListener("pointerout", this._onMSPointerOut, true);
            }
          }
        }
      },
      onPointerDown: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.pointerDownCallback) {
          this.pointerDownCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = a.pointerId;
          if ("mouse" === a.pointerType || 4 === a.pointerType) {
            this.input.mousePointer.start(a);
          } else {
            this.input.startPointer(a);
          }
        }
      },
      onPointerMove: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.pointerMoveCallback) {
          this.pointerMoveCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = a.pointerId;
          if ("mouse" === a.pointerType || 4 === a.pointerType) {
            this.input.mousePointer.move(a);
          } else {
            this.input.updatePointer(a);
          }
        }
      },
      onPointerUp: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if (this.pointerUpCallback) {
          this.pointerUpCallback.call(this.callbackContext, a);
        }
        if (this.input.enabled && this.enabled) {
          a.identifier = a.pointerId;
          if ("mouse" === a.pointerType || 4 === a.pointerType) {
            this.input.mousePointer.stop(a);
          } else {
            this.input.stopPointer(a);
          }
        }
      },
      onPointerUpGlobal: function (a) {
        if ("mouse" !== a.pointerType && 4 !== a.pointerType || this.input.mousePointer.withinGame) {
          var b = this.input.getPointerFromIdentifier(a.identifier);
          if (b && b.withinGame) {
            this.onPointerUp(a);
          }
        } else {
          this.onPointerUp(a);
        }
      },
      onPointerOut: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if ("mouse" === a.pointerType || 4 === a.pointerType) {
          this.input.mousePointer.withinGame = false;
        } else {
          var b = this.input.getPointerFromIdentifier(a.identifier);
          if (b) {
            b.withinGame = false;
          }
        }
        if (this.input.mouse.mouseOutCallback) {
          this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, a);
        }
        if (this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut) {
          a.identifier = 0;
          if (b) {
            b.stop(a);
          } else {
            this.input.mousePointer.stop(a);
          }
        }
      },
      onPointerOver: function (a) {
        this.event = a;
        if (this.capture) {
          a.preventDefault();
        }
        if ("mouse" === a.pointerType || 4 === a.pointerType) {
          this.input.mousePointer.withinGame = true;
        } else {
          var b = this.input.getPointerFromIdentifier(a.identifier);
          if (b) {
            b.withinGame = true;
          }
        }
        if (this.input.mouse.mouseOverCallback) {
          this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, a);
        }
      },
      stop: function () {
        var a = this.game.canvas;
        a.removeEventListener("MSPointerDown", this._onMSPointerDown, false);
        a.removeEventListener("MSPointerMove", this._onMSPointerMove, false);
        a.removeEventListener("MSPointerUp", this._onMSPointerUp, false);
        a.removeEventListener("pointerdown", this._onMSPointerDown, false);
        a.removeEventListener("pointermove", this._onMSPointerMove, false);
        a.removeEventListener("pointerup", this._onMSPointerUp, false);
        window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, true);
        a.removeEventListener("MSPointerOver", this._onMSPointerOver, true);
        a.removeEventListener("MSPointerOut", this._onMSPointerOut, true);
        window.removeEventListener("pointerup", this._onMSPointerUpGlobal, true);
        a.removeEventListener("pointerover", this._onMSPointerOver, true);
        a.removeEventListener("pointerout", this._onMSPointerOut, true);
      }
    };
    b.MSPointer.prototype.constructor = b.MSPointer;
    b.DeviceButton = function (a, c) {
      this.parent = a;
      this.game = a.game;
      this.event = null;
      this.isDown = false;
      this.isUp = true;
      this.timeDown = 0;
      this.timeUp = 0;
      this.repeats = 0;
      this.altKey = false;
      this.shiftKey = false;
      this.ctrlKey = false;
      this.value = 0;
      this.buttonCode = c;
      this.onDown = new b.Signal();
      this.onUp = new b.Signal();
      this.onFloat = new b.Signal();
    };
    b.DeviceButton.prototype = {
      start: function (a, b) {
        if (!this.isDown) {
          this.isDown = true;
          this.isUp = false;
          this.timeDown = this.game.time.time;
          this.repeats = 0;
          this.event = a;
          this.value = b;
          if (a) {
            this.altKey = a.altKey;
            this.shiftKey = a.shiftKey;
            this.ctrlKey = a.ctrlKey;
          }
          this.onDown.dispatch(this, b);
        }
      },
      stop: function (a, b) {
        if (!this.isUp) {
          this.isDown = false;
          this.isUp = true;
          this.timeUp = this.game.time.time;
          this.event = a;
          this.value = b;
          if (a) {
            this.altKey = a.altKey;
            this.shiftKey = a.shiftKey;
            this.ctrlKey = a.ctrlKey;
          }
          this.onUp.dispatch(this, b);
        }
      },
      padFloat: function (a) {
        this.value = a;
        this.onFloat.dispatch(this, a);
      },
      justPressed: function (a) {
        a = a || 250;
        return this.isDown && this.timeDown + a > this.game.time.time;
      },
      justReleased: function (a) {
        a = a || 250;
        return this.isUp && this.timeUp + a > this.game.time.time;
      },
      reset: function () {
        this.isDown = false;
        this.isUp = true;
        this.timeDown = this.game.time.time;
        this.repeats = 0;
        this.altKey = false;
        this.shiftKey = false;
        this.ctrlKey = false;
      },
      destroy: function () {
        this.onDown.dispose();
        this.onUp.dispose();
        this.onFloat.dispose();
        this.parent = null;
        this.game = null;
      }
    };
    b.DeviceButton.prototype.constructor = b.DeviceButton;
    Object.defineProperty(b.DeviceButton.prototype, "duration", {
      get: function () {
        return this.isUp ? -1 : this.game.time.time - this.timeDown;
      }
    });
    b.Pointer = function (a, c, d) {
      this.game = a;
      this.id = c;
      this.type = b.POINTER;
      this.exists = true;
      this.identifier = 0;
      this.pointerId = null;
      this.pointerMode = d || b.PointerMode.CURSOR | b.PointerMode.CONTACT;
      this.target = null;
      this.button = null;
      this.leftButton = new b.DeviceButton(this, b.Pointer.LEFT_BUTTON);
      this.middleButton = new b.DeviceButton(this, b.Pointer.MIDDLE_BUTTON);
      this.rightButton = new b.DeviceButton(this, b.Pointer.RIGHT_BUTTON);
      this.backButton = new b.DeviceButton(this, b.Pointer.BACK_BUTTON);
      this.forwardButton = new b.DeviceButton(this, b.Pointer.FORWARD_BUTTON);
      this.eraserButton = new b.DeviceButton(this, b.Pointer.ERASER_BUTTON);
      this._holdSent = false;
      this._history = [];
      this._nextDrop = 0;
      this._stateReset = false;
      this.withinGame = false;
      this.clientX = -1;
      this.clientY = -1;
      this.pageX = -1;
      this.pageY = -1;
      this.screenX = -1;
      this.screenY = -1;
      this.rawMovementX = 0;
      this.rawMovementY = 0;
      this.movementX = 0;
      this.movementY = 0;
      this.x = -1;
      this.y = -1;
      this.isMouse = 0 === c;
      this.isDown = false;
      this.isUp = true;
      this.timeDown = 0;
      this.timeUp = 0;
      this.previousTapTime = 0;
      this.totalTouches = 0;
      this.msSinceLastClick = Number.MAX_VALUE;
      this.targetObject = null;
      this.interactiveCandidates = [];
      this.active = false;
      this.dirty = false;
      this.position = new b.Point();
      this.positionDown = new b.Point();
      this.positionUp = new b.Point();
      this.circle = new b.Circle(0, 0, 44);
      this._clickTrampolines = null;
      this._trampolineTargetObject = null;
    };
    b.Pointer.NO_BUTTON = 0;
    b.Pointer.LEFT_BUTTON = 1;
    b.Pointer.RIGHT_BUTTON = 2;
    b.Pointer.MIDDLE_BUTTON = 4;
    b.Pointer.BACK_BUTTON = 8;
    b.Pointer.FORWARD_BUTTON = 16;
    b.Pointer.ERASER_BUTTON = 32;
    b.Pointer.prototype = {
      resetButtons: function () {
        this.isDown = false;
        this.isUp = true;
        if (this.isMouse) {
          this.leftButton.reset();
          this.middleButton.reset();
          this.rightButton.reset();
          this.backButton.reset();
          this.forwardButton.reset();
          this.eraserButton.reset();
        }
      },
      processButtonsDown: function (a, c) {
        if (b.Pointer.LEFT_BUTTON & a) {
          this.leftButton.start(c);
        }
        if (b.Pointer.RIGHT_BUTTON & a) {
          this.rightButton.start(c);
        }
        if (b.Pointer.MIDDLE_BUTTON & a) {
          this.middleButton.start(c);
        }
        if (b.Pointer.BACK_BUTTON & a) {
          this.backButton.start(c);
        }
        if (b.Pointer.FORWARD_BUTTON & a) {
          this.forwardButton.start(c);
        }
        if (b.Pointer.ERASER_BUTTON & a) {
          this.eraserButton.start(c);
        }
      },
      processButtonsUp: function (a, c) {
        if (a === b.Mouse.LEFT_BUTTON) {
          this.leftButton.stop(c);
        }
        if (a === b.Mouse.RIGHT_BUTTON) {
          this.rightButton.stop(c);
        }
        if (a === b.Mouse.MIDDLE_BUTTON) {
          this.middleButton.stop(c);
        }
        if (a === b.Mouse.BACK_BUTTON) {
          this.backButton.stop(c);
        }
        if (a === b.Mouse.FORWARD_BUTTON) {
          this.forwardButton.stop(c);
        }
        if (5 === a) {
          this.eraserButton.stop(c);
        }
      },
      updateButtons: function (a) {
        this.button = a.button;
        var b = "down" === a.type.toLowerCase().substr(-4);
        if (undefined !== a.buttons) {
          if (b) {
            this.processButtonsDown(a.buttons, a);
          } else {
            this.processButtonsUp(a.button, a);
          }
        } else if (b) {
          this.leftButton.start(a);
        } else {
          this.leftButton.stop(a);
          this.rightButton.stop(a);
        }
        if (1 === a.buttons && a.ctrlKey && this.leftButton.isDown) {
          this.leftButton.stop(a);
          this.rightButton.start(a);
        }
        this.isUp = true;
        this.isDown = false;
        if (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) {
          this.isUp = false;
          this.isDown = true;
        }
      },
      start: function (a) {
        var c = this.game.input;
        if (a.pointerId) {
          this.pointerId = a.pointerId;
        }
        this.identifier = a.identifier;
        this.target = a.target;
        if (this.isMouse) {
          this.updateButtons(a);
        } else {
          this.isDown = true;
          this.isUp = false;
        }
        this.active = true;
        this.withinGame = true;
        this.dirty = false;
        this._history = [];
        this._clickTrampolines = null;
        this._trampolineTargetObject = null;
        this.msSinceLastClick = this.game.time.time - this.timeDown;
        this.timeDown = this.game.time.time;
        this._holdSent = false;
        this.move(a, true);
        this.positionDown.setTo(this.x, this.y);
        if (c.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || c.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || c.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === c.totalActivePointers) {
          c.x = this.x;
          c.y = this.y;
          c.position.setTo(this.x, this.y);
          c.onDown.dispatch(this, a);
          c.resetSpeed(this.x, this.y);
        }
        this._stateReset = false;
        this.totalTouches++;
        if (null !== this.targetObject) {
          this.targetObject._touchedHandler(this);
        }
        return this;
      },
      update: function () {
        var a = this.game.input;
        if (this.active) {
          if (this.dirty) {
            if (a.interactiveItems.total > 0) {
              this.processInteractiveObjects(false);
            }
            this.dirty = false;
          }
          if (false === this._holdSent && this.duration >= a.holdRate) {
            if (a.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || a.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || a.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === a.totalActivePointers) {
              a.onHold.dispatch(this);
            }
            this._holdSent = true;
          }
          if (a.recordPointerHistory && this.game.time.time >= this._nextDrop) {
            this._nextDrop = this.game.time.time + a.recordRate;
            this._history.push({
              x: this.position.x,
              y: this.position.y
            });
            if (this._history.length > a.recordLimit) {
              this._history.shift();
            }
          }
        }
      },
      move: function (a, c) {
        var d = this.game.input;
        if (!d.pollLocked) {
          if (undefined === c) {
            c = false;
          }
          if (undefined !== a.button) {
            this.button = a.button;
          }
          if (c && this.isMouse) {
            this.updateButtons(a);
          }
          this.clientX = a.clientX;
          this.clientY = a.clientY;
          this.pageX = a.pageX;
          this.pageY = a.pageY;
          this.screenX = a.screenX;
          this.screenY = a.screenY;
          if (this.isMouse && d.mouse.locked && !c) {
            this.rawMovementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0;
            this.rawMovementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0;
            this.movementX += this.rawMovementX;
            this.movementY += this.rawMovementY;
          }
          this.x = (this.pageX - this.game.scale.offset.x) * d.scale.x;
          this.y = (this.pageY - this.game.scale.offset.y) * d.scale.y;
          this.position.setTo(this.x, this.y);
          this.circle.x = this.x;
          this.circle.y = this.y;
          if (d.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || d.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || d.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === d.totalActivePointers) {
            d.activePointer = this;
            d.x = this.x;
            d.y = this.y;
            d.position.setTo(d.x, d.y);
            d.circle.x = d.x;
            d.circle.y = d.y;
          }
          this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
          if (this.game.paused) {
            return this;
          }
          for (var e = d.moveCallbacks.length; e--;) {
            d.moveCallbacks[e].callback.call(d.moveCallbacks[e].context, this, this.x, this.y, c);
          }
          if (null !== this.targetObject && true === this.targetObject.isDragged) {
            if (false === this.targetObject.update(this)) {
              this.targetObject = null;
            }
          } else if (d.interactiveItems.total > 0) {
            this.processInteractiveObjects(c);
          }
          return this;
        }
      },
      processInteractiveObjects: function (a) {
        var b = 0;
        var c = -1;
        var d = null;
        var e = this.game.input.interactiveItems.first;
        for (this.interactiveCandidates = []; e;) {
          e.checked = false;
          if (e.validForInput(c, b, false)) {
            e.checked = true;
            if (a && e.checkPointerDown(this, true) || !a && e.checkPointerOver(this, true)) {
              b = e.sprite.renderOrderID;
              c = e.priorityID;
              d = e;
              this.interactiveCandidates.push(e);
            }
          }
          e = this.game.input.interactiveItems.next;
        }
        for (e = this.game.input.interactiveItems.first; e;) {
          if (!e.checked && e.validForInput(c, b, true) && (a && e.checkPointerDown(this, false) || !a && e.checkPointerOver(this, false))) {
            b = e.sprite.renderOrderID;
            c = e.priorityID;
            d = e;
            this.interactiveCandidates.push(e);
          }
          e = this.game.input.interactiveItems.next;
        }
        if (this.game.input.customCandidateHandler) {
          d = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, d);
        }
        this.swapTarget(d, false);
        return null !== this.targetObject;
      },
      swapTarget: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (null === a) {
          if (this.targetObject) {
            this.targetObject._pointerOutHandler(this, b);
            this.targetObject = null;
          }
        } else if (null === this.targetObject) {
          this.targetObject = a;
          a._pointerOverHandler(this, b);
        } else if (this.targetObject === a) {
          if (false === a.update(this)) {
            this.targetObject = null;
          }
        } else {
          this.targetObject._pointerOutHandler(this, b);
          this.targetObject = a;
          this.targetObject._pointerOverHandler(this, b);
        }
      },
      leave: function (a) {
        this.withinGame = false;
        this.move(a, false);
      },
      stop: function (a) {
        var c = this.game.input;
        return this._stateReset && this.withinGame ? void a.preventDefault() : (this.timeUp = this.game.time.time, (c.multiInputOverride === b.Input.MOUSE_OVERRIDES_TOUCH || c.multiInputOverride === b.Input.MOUSE_TOUCH_COMBINE || c.multiInputOverride === b.Input.TOUCH_OVERRIDES_MOUSE && 0 === c.totalActivePointers) && (c.onUp.dispatch(this, a), this.duration >= 0 && this.duration <= c.tapRate && (this.timeUp - this.previousTapTime < c.doubleTapRate ? c.onTap.dispatch(this, true) : c.onTap.dispatch(this, false), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(a) : (this.isDown = false, this.isUp = true), this.id > 0 && (this.active = false), this.withinGame = this.game.scale.bounds.contains(a.pageX, a.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), false === this.isMouse && c.currentPointers--, c.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this);
      },
      justPressed: function (a) {
        a = a || this.game.input.justPressedRate;
        return true === this.isDown && this.timeDown + a > this.game.time.time;
      },
      justReleased: function (a) {
        a = a || this.game.input.justReleasedRate;
        return this.isUp && this.timeUp + a > this.game.time.time;
      },
      addClickTrampoline: function (a, b, c, d) {
        if (this.isDown) {
          var e = this._clickTrampolines = this._clickTrampolines || [];
          for (var f = 0; f < e.length; f++) {
            if (e[f].name === a) {
              e.splice(f, 1);
              break;
            }
          }
          e.push({
            name: a,
            targetObject: this.targetObject,
            callback: b,
            callbackContext: c,
            callbackArgs: d
          });
        }
      },
      processClickTrampolines: function () {
        var a = this._clickTrampolines;
        if (a) {
          for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (c.targetObject === this._trampolineTargetObject) {
              c.callback.apply(c.callbackContext, c.callbackArgs);
            }
          }
          this._clickTrampolines = null;
          this._trampolineTargetObject = null;
        }
      },
      reset: function () {
        if (false === this.isMouse) {
          this.active = false;
        }
        this.pointerId = null;
        this.identifier = null;
        this.dirty = false;
        this.totalTouches = 0;
        this._holdSent = false;
        this._history.length = 0;
        this._stateReset = true;
        this.resetButtons();
        if (this.targetObject) {
          this.targetObject._releasedHandler(this);
        }
        this.targetObject = null;
      },
      resetMovement: function () {
        this.movementX = 0;
        this.movementY = 0;
      }
    };
    b.Pointer.prototype.constructor = b.Pointer;
    Object.defineProperty(b.Pointer.prototype, "duration", {
      get: function () {
        return this.isUp ? -1 : this.game.time.time - this.timeDown;
      }
    });
    Object.defineProperty(b.Pointer.prototype, "worldX", {
      get: function () {
        return this.game.world.camera.x + this.x;
      }
    });
    Object.defineProperty(b.Pointer.prototype, "worldY", {
      get: function () {
        return this.game.world.camera.y + this.y;
      }
    });
    b.PointerMode = {
      CURSOR: 1,
      CONTACT: 2
    };
    b.Touch = function (a) {
      this.game = a;
      this.enabled = true;
      this.touchLockCallbacks = [];
      this.callbackContext = this.game;
      this.touchStartCallback = null;
      this.touchMoveCallback = null;
      this.touchEndCallback = null;
      this.touchEnterCallback = null;
      this.touchLeaveCallback = null;
      this.touchCancelCallback = null;
      this.preventDefault = true;
      this.event = null;
      this._onTouchStart = null;
      this._onTouchMove = null;
      this._onTouchEnd = null;
      this._onTouchEnter = null;
      this._onTouchLeave = null;
      this._onTouchCancel = null;
      this._onTouchMove = null;
    };
    b.Touch.prototype = {
      start: function () {
        if (null === this._onTouchStart) {
          var a = this;
          if (this.game.device.touch) {
            this._onTouchStart = function (b) {
              return a.onTouchStart(b);
            };
            this._onTouchMove = function (b) {
              return a.onTouchMove(b);
            };
            this._onTouchEnd = function (b) {
              return a.onTouchEnd(b);
            };
            this._onTouchEnter = function (b) {
              return a.onTouchEnter(b);
            };
            this._onTouchLeave = function (b) {
              return a.onTouchLeave(b);
            };
            this._onTouchCancel = function (b) {
              return a.onTouchCancel(b);
            };
            this.game.canvas.addEventListener("touchstart", this._onTouchStart, false);
            this.game.canvas.addEventListener("touchmove", this._onTouchMove, false);
            this.game.canvas.addEventListener("touchend", this._onTouchEnd, false);
            this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false);
            if (!this.game.device.cocoonJS) {
              this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
              this.game.canvas.addEventListener("touchleave", this._onTouchLeave, false);
            }
          }
        }
      },
      consumeDocumentTouches: function () {
        this._documentTouchMove = function (a) {
          a.preventDefault();
        };
        document.addEventListener("touchmove", this._documentTouchMove, false);
      },
      addTouchLockCallback: function (a, b, c) {
        if (undefined === c) {
          c = false;
        }
        this.touchLockCallbacks.push({
          callback: a,
          context: b,
          onEnd: c
        });
      },
      removeTouchLockCallback: function (a, b) {
        for (var c = this.touchLockCallbacks.length; c--;) {
          if (this.touchLockCallbacks[c].callback === a && this.touchLockCallbacks[c].context === b) {
            this.touchLockCallbacks.splice(c, 1);
            return true;
          }
        }
        return false;
      },
      onTouchStart: function (a) {
        for (var b = this.touchLockCallbacks.length; b--;) {
          var c = this.touchLockCallbacks[b];
          if (!c.onEnd && c.callback.call(c.context, this, a)) {
            this.touchLockCallbacks.splice(b, 1);
          }
        }
        this.event = a;
        if (this.game.input.enabled && this.enabled) {
          if (this.touchStartCallback) {
            this.touchStartCallback.call(this.callbackContext, a);
          }
          if (this.preventDefault) {
            a.preventDefault();
          }
          for (var b = 0; b < a.changedTouches.length; b++) {
            this.game.input.startPointer(a.changedTouches[b]);
          }
        }
      },
      onTouchCancel: function (a) {
        this.event = a;
        if (this.touchCancelCallback) {
          this.touchCancelCallback.call(this.callbackContext, a);
        }
        if (this.game.input.enabled && this.enabled) {
          if (this.preventDefault) {
            a.preventDefault();
          }
          for (var b = 0; b < a.changedTouches.length; b++) {
            this.game.input.stopPointer(a.changedTouches[b]);
          }
        }
      },
      onTouchEnter: function (a) {
        this.event = a;
        if (this.touchEnterCallback) {
          this.touchEnterCallback.call(this.callbackContext, a);
        }
        if (this.game.input.enabled && this.enabled && this.preventDefault) {
          a.preventDefault();
        }
      },
      onTouchLeave: function (a) {
        this.event = a;
        if (this.touchLeaveCallback) {
          this.touchLeaveCallback.call(this.callbackContext, a);
        }
        if (this.preventDefault) {
          a.preventDefault();
        }
      },
      onTouchMove: function (a) {
        this.event = a;
        if (this.touchMoveCallback) {
          this.touchMoveCallback.call(this.callbackContext, a);
        }
        if (this.preventDefault) {
          a.preventDefault();
        }
        for (var b = 0; b < a.changedTouches.length; b++) {
          this.game.input.updatePointer(a.changedTouches[b]);
        }
      },
      onTouchEnd: function (a) {
        for (var b = this.touchLockCallbacks.length; b--;) {
          var c = this.touchLockCallbacks[b];
          if (c.onEnd && c.callback.call(c.context, this, a)) {
            this.touchLockCallbacks.splice(b, 1);
          }
        }
        this.event = a;
        if (this.touchEndCallback) {
          this.touchEndCallback.call(this.callbackContext, a);
        }
        if (this.preventDefault) {
          a.preventDefault();
        }
        for (var b = 0; b < a.changedTouches.length; b++) {
          this.game.input.stopPointer(a.changedTouches[b]);
        }
      },
      stop: function () {
        if (this.game.device.touch) {
          this.game.canvas.removeEventListener("touchstart", this._onTouchStart);
          this.game.canvas.removeEventListener("touchmove", this._onTouchMove);
          this.game.canvas.removeEventListener("touchend", this._onTouchEnd);
          this.game.canvas.removeEventListener("touchenter", this._onTouchEnter);
          this.game.canvas.removeEventListener("touchleave", this._onTouchLeave);
          this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel);
        }
      }
    };
    b.Touch.prototype.constructor = b.Touch;
    b.InputHandler = function (a) {
      this.sprite = a;
      this.game = a.game;
      this.enabled = false;
      this.checked = false;
      this.priorityID = 0;
      this.useHandCursor = false;
      this._setHandCursor = false;
      this.isDragged = false;
      this.allowHorizontalDrag = true;
      this.allowVerticalDrag = true;
      this.bringToTop = false;
      this.snapOffset = null;
      this.snapOnDrag = false;
      this.snapOnRelease = false;
      this.snapX = 0;
      this.snapY = 0;
      this.snapOffsetX = 0;
      this.snapOffsetY = 0;
      this.pixelPerfectOver = false;
      this.pixelPerfectClick = false;
      this.pixelPerfectAlpha = 255;
      this.draggable = false;
      this.boundsRect = null;
      this.boundsSprite = null;
      this.scaleLayer = false;
      this.dragOffset = new b.Point();
      this.dragFromCenter = false;
      this.dragStopBlocksInputUp = false;
      this.dragStartPoint = new b.Point();
      this.dragDistanceThreshold = 0;
      this.dragTimeThreshold = 0;
      this.downPoint = new b.Point();
      this.snapPoint = new b.Point();
      this._dragPoint = new b.Point();
      this._dragPhase = false;
      this._pendingDrag = false;
      this._dragTimePass = false;
      this._dragDistancePass = false;
      this._wasEnabled = false;
      this._tempPoint = new b.Point();
      this._pointerData = [];
      this._pointerData.push({
        id: 0,
        x: 0,
        y: 0,
        camX: 0,
        camY: 0,
        isDown: false,
        isUp: false,
        isOver: false,
        isOut: false,
        timeOver: 0,
        timeOut: 0,
        timeDown: 0,
        timeUp: 0,
        downDuration: 0,
        isDragged: false
      });
    };
    b.InputHandler.prototype = {
      start: function (a, c) {
        a = a || 0;
        if (undefined === c) {
          c = false;
        }
        if (false === this.enabled) {
          this.game.input.interactiveItems.add(this);
          this.useHandCursor = c;
          this.priorityID = a;
          for (var d = 0; d < 10; d++) {
            this._pointerData[d] = {
              id: d,
              x: 0,
              y: 0,
              isDown: false,
              isUp: false,
              isOver: false,
              isOut: false,
              timeOver: 0,
              timeOut: 0,
              timeDown: 0,
              timeUp: 0,
              downDuration: 0,
              isDragged: false
            };
          }
          this.snapOffset = new b.Point();
          this.enabled = true;
          this._wasEnabled = true;
        }
        this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);
        this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);
        return this.sprite;
      },
      addedToGroup: function () {
        if (!this._dragPhase) {
          if (this._wasEnabled && !this.enabled) {
            this.start();
          }
        }
      },
      removedFromGroup: function () {
        if (!this._dragPhase) {
          if (this.enabled) {
            this._wasEnabled = true;
            this.stop();
          } else {
            this._wasEnabled = false;
          }
        }
      },
      reset: function () {
        this.enabled = false;
        for (var a = 0; a < 10; a++) {
          this._pointerData[a] = {
            id: a,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
          };
        }
      },
      stop: function () {
        if (false !== this.enabled) {
          this.enabled = false;
          this.game.input.interactiveItems.remove(this);
        }
      },
      destroy: function () {
        if (this.sprite) {
          if (this._setHandCursor) {
            this.game.canvas.style.cursor = "default";
            this._setHandCursor = false;
          }
          this.enabled = false;
          this.game.input.interactiveItems.remove(this);
          this._pointerData.length = 0;
          this.boundsRect = null;
          this.boundsSprite = null;
          this.sprite = null;
        }
      },
      validForInput: function (a, b, c) {
        if (undefined === c) {
          c = true;
        }
        return !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && !(!c && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > a || this.priorityID === a && this.sprite.renderOrderID > b);
      },
      isPixelPerfect: function () {
        return this.pixelPerfectClick || this.pixelPerfectOver;
      },
      pointerX: function (a) {
        a = a || 0;
        return this._pointerData[a].x;
      },
      pointerY: function (a) {
        a = a || 0;
        return this._pointerData[a].y;
      },
      pointerDown: function (a) {
        a = a || 0;
        return this._pointerData[a].isDown;
      },
      pointerUp: function (a) {
        a = a || 0;
        return this._pointerData[a].isUp;
      },
      pointerTimeDown: function (a) {
        a = a || 0;
        return this._pointerData[a].timeDown;
      },
      pointerTimeUp: function (a) {
        a = a || 0;
        return this._pointerData[a].timeUp;
      },
      pointerOver: function (a) {
        if (!this.enabled) {
          return false;
        }
        if (undefined === a) {
          for (var b = 0; b < 10; b++) {
            if (this._pointerData[b].isOver) {
              return true;
            }
          }
          return false;
        }
        return this._pointerData[a].isOver;
      },
      pointerOut: function (a) {
        if (!this.enabled) {
          return false;
        }
        if (undefined !== a) {
          return this._pointerData[a].isOut;
        }
        for (var b = 0; b < 10; b++) {
          if (this._pointerData[b].isOut) {
            return true;
          }
        }
      },
      pointerTimeOver: function (a) {
        a = a || 0;
        return this._pointerData[a].timeOver;
      },
      pointerTimeOut: function (a) {
        a = a || 0;
        return this._pointerData[a].timeOut;
      },
      pointerDragged: function (a) {
        a = a || 0;
        return this._pointerData[a].isDragged;
      },
      checkPointerDown: function (a, b) {
        return !!(a.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (undefined === b && (b = false), !(!b && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y));
      },
      checkPointerOver: function (a, b) {
        return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, a, this._tempPoint) && (undefined === b && (b = false), !(!b && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y));
      },
      checkPixel: function (a, b, c) {
        if (this.sprite.texture.baseTexture.source) {
          if (null === a && null === b) {
            this.game.input.getLocalPosition(this.sprite, c, this._tempPoint);
            var a = this._tempPoint.x;
            var b = this._tempPoint.y;
          }
          if (0 !== this.sprite.anchor.x) {
            a -= -this.sprite.texture.frame.width * this.sprite.anchor.x;
          }
          if (0 !== this.sprite.anchor.y) {
            b -= -this.sprite.texture.frame.height * this.sprite.anchor.y;
          }
          a += this.sprite.texture.frame.x;
          b += this.sprite.texture.frame.y;
          if (this.sprite.texture.trim && (a -= this.sprite.texture.trim.x, b -= this.sprite.texture.trim.y, a < this.sprite.texture.crop.x || a > this.sprite.texture.crop.right || b < this.sprite.texture.crop.y || b > this.sprite.texture.crop.bottom)) {
            this._dx = a;
            this._dy = b;
            return false;
          }
          this._dx = a;
          this._dy = b;
          this.game.input.hitContext.clearRect(0, 0, 1, 1);
          this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, a, b, 1, 1, 0, 0, 1, 1);
          if (this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) {
            return true;
          }
        }
        return false;
      },
      update: function (a) {
        if (null !== this.sprite && undefined !== this.sprite.parent) {
          return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = b.Math.distance(a.x, a.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(a), true) : this.draggable && this._draggedPointerID === a.id ? this.updateDrag(a, false) : this._pointerData[a.id].isOver ? this.checkPointerOver(a) ? (this._pointerData[a.id].x = a.x - this.sprite.x, this._pointerData[a.id].y = a.y - this.sprite.y, true) : (this._pointerOutHandler(a), false) : undefined : (this._pointerOutHandler(a), false);
        }
      },
      _pointerOverHandler: function (a, c) {
        if (null !== this.sprite) {
          var d = this._pointerData[a.id];
          if (false === d.isOver || a.dirty) {
            var e = false === d.isOver;
            d.isOver = true;
            d.isOut = false;
            d.timeOver = this.game.time.time;
            d.x = a.x - this.sprite.x;
            d.y = a.y - this.sprite.y;
            if (this.useHandCursor && false === d.isDragged) {
              this.game.canvas.style.cursor = "pointer";
              this._setHandCursor = true;
            }
            if (!c && e && this.sprite && this.sprite.events) {
              this.sprite.events.onInputOver$dispatch(this.sprite, a);
            }
            if (this.sprite.parent && this.sprite.parent.type === b.GROUP) {
              this.sprite.parent.onChildInputOver.dispatch(this.sprite, a);
            }
          }
        }
      },
      _pointerOutHandler: function (a, c) {
        if (null !== this.sprite) {
          var d = this._pointerData[a.id];
          d.isOver = false;
          d.isOut = true;
          d.timeOut = this.game.time.time;
          if (this.useHandCursor && false === d.isDragged) {
            this.game.canvas.style.cursor = "default";
            this._setHandCursor = false;
          }
          if (!c && this.sprite && this.sprite.events) {
            this.sprite.events.onInputOut$dispatch(this.sprite, a);
            if (this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP) {
              this.sprite.parent.onChildInputOut.dispatch(this.sprite, a);
            }
          }
        }
      },
      _touchedHandler: function (a) {
        if (null !== this.sprite) {
          var c = this._pointerData[a.id];
          if (!c.isDown && c.isOver) {
            if (this.pixelPerfectClick && !this.checkPixel(null, null, a)) {
              return;
            }
            c.isDown = true;
            c.isUp = false;
            c.timeDown = this.game.time.time;
            this.downPoint.set(a.x, a.y);
            a.dirty = true;
            if (this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, a), this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, a), null === this.sprite)) {
              return;
            }
            if (this.draggable && false === this.isDragged) {
              if (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold) {
                this.startDrag(a);
              } else {
                this._pendingDrag = true;
                this._dragDistancePass = 0 === this.dragDistanceThreshold;
                if (this.dragTimeThreshold > 0) {
                  this._dragTimePass = false;
                  this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, a);
                } else {
                  this._dragTimePass = true;
                }
              }
            }
            if (this.bringToTop) {
              this.sprite.bringToTop();
            }
          }
        }
      },
      dragTimeElapsed: function (a) {
        this._dragTimePass = true;
        if (this._pendingDrag && this.sprite && this._dragDistancePass) {
          this.startDrag(a);
        }
      },
      _releasedHandler: function (a) {
        if (null !== this.sprite) {
          var c = this._pointerData[a.id];
          if (c.isDown && a.isUp) {
            c.isDown = false;
            c.isUp = true;
            c.timeUp = this.game.time.time;
            c.downDuration = c.timeUp - c.timeDown;
            var d = this.checkPointerOver(a);
            if (this.sprite && this.sprite.events) {
              if (!(this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === a.id))) {
                this.sprite.events.onInputUp$dispatch(this.sprite, a, d);
              }
              if (this.sprite && this.sprite.parent && this.sprite.parent.type === b.GROUP) {
                this.sprite.parent.onChildInputUp.dispatch(this.sprite, a, d);
              }
              if (d) {
                d = this.checkPointerOver(a);
              }
            }
            c.isOver = d;
            if (!d && this.useHandCursor) {
              this.game.canvas.style.cursor = "default";
              this._setHandCursor = false;
            }
            a.dirty = true;
            this._pendingDrag = false;
            if (this.draggable && this.isDragged && this._draggedPointerID === a.id) {
              this.stopDrag(a);
            }
          }
        }
      },
      updateDrag: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (a.isUp) {
          this.stopDrag(a);
          return false;
        }
        var c = this.globalToLocalX(a.x) + this._dragPoint.x + this.dragOffset.x;
        var d = this.globalToLocalY(a.y) + this._dragPoint.y + this.dragOffset.y;
        if (this.sprite.fixedToCamera) {
          if (this.allowHorizontalDrag) {
            this.sprite.cameraOffset.x = c;
          }
          if (this.allowVerticalDrag) {
            this.sprite.cameraOffset.y = d;
          }
          if (this.boundsRect) {
            this.checkBoundsRect();
          }
          if (this.boundsSprite) {
            this.checkBoundsSprite();
          }
          if (this.snapOnDrag) {
            this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
            this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y);
          }
        } else {
          var e = this.game.camera.x - this._pointerData[a.id].camX;
          var f = this.game.camera.y - this._pointerData[a.id].camY;
          if (this.allowHorizontalDrag) {
            this.sprite.x = c + e;
          }
          if (this.allowVerticalDrag) {
            this.sprite.y = d + f;
          }
          if (this.boundsRect) {
            this.checkBoundsRect();
          }
          if (this.boundsSprite) {
            this.checkBoundsSprite();
          }
          if (this.snapOnDrag) {
            this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
            this.snapPoint.set(this.sprite.x, this.sprite.y);
          }
        }
        this.sprite.events.onDragUpdate.dispatch(this.sprite, a, c, d, this.snapPoint, b);
        return true;
      },
      justOver: function (a, b) {
        a = a || 0;
        b = b || 500;
        return this._pointerData[a].isOver && this.overDuration(a) < b;
      },
      justOut: function (a, b) {
        a = a || 0;
        b = b || 500;
        return this._pointerData[a].isOut && this.game.time.time - this._pointerData[a].timeOut < b;
      },
      justPressed: function (a, b) {
        a = a || 0;
        b = b || 500;
        return this._pointerData[a].isDown && this.downDuration(a) < b;
      },
      justReleased: function (a, b) {
        a = a || 0;
        b = b || 500;
        return this._pointerData[a].isUp && this.game.time.time - this._pointerData[a].timeUp < b;
      },
      overDuration: function (a) {
        a = a || 0;
        return this._pointerData[a].isOver ? this.game.time.time - this._pointerData[a].timeOver : -1;
      },
      downDuration: function (a) {
        a = a || 0;
        return this._pointerData[a].isDown ? this.game.time.time - this._pointerData[a].timeDown : -1;
      },
      enableDrag: function (a, c, d, e, f, g) {
        if (undefined === a) {
          a = false;
        }
        if (undefined === c) {
          c = false;
        }
        if (undefined === d) {
          d = false;
        }
        if (undefined === e) {
          e = 255;
        }
        if (undefined === f) {
          f = null;
        }
        if (undefined === g) {
          g = null;
        }
        this._dragPoint = new b.Point();
        this.draggable = true;
        this.bringToTop = c;
        this.dragOffset = new b.Point();
        this.dragFromCenter = a;
        this.pixelPerfectClick = d;
        this.pixelPerfectAlpha = e;
        if (f) {
          this.boundsRect = f;
        }
        if (g) {
          this.boundsSprite = g;
        }
      },
      disableDrag: function () {
        if (this._pointerData) {
          for (var a = 0; a < 10; a++) {
            this._pointerData[a].isDragged = false;
          }
        }
        this.draggable = false;
        this.isDragged = false;
        this._draggedPointerID = -1;
        this._pendingDrag = false;
      },
      startDrag: function (a) {
        var b = this.sprite.x;
        var c = this.sprite.y;
        this.isDragged = true;
        this._draggedPointerID = a.id;
        this._pointerData[a.id].camX = this.game.camera.x;
        this._pointerData[a.id].camY = this.game.camera.y;
        this._pointerData[a.id].isDragged = true;
        if (this.sprite.fixedToCamera) {
          if (this.dragFromCenter) {
            var d = this.sprite.getBounds();
            this.sprite.cameraOffset.x = this.globalToLocalX(a.x) + (this.sprite.cameraOffset.x - d.centerX);
            this.sprite.cameraOffset.y = this.globalToLocalY(a.y) + (this.sprite.cameraOffset.y - d.centerY);
          }
          this._dragPoint.setTo(this.sprite.cameraOffset.x - a.x, this.sprite.cameraOffset.y - a.y);
        } else {
          if (this.dragFromCenter) {
            var d = this.sprite.getBounds();
            this.sprite.x = this.globalToLocalX(a.x) + (this.sprite.x - d.centerX);
            this.sprite.y = this.globalToLocalY(a.y) + (this.sprite.y - d.centerY);
          }
          this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(a.x), this.sprite.y - this.globalToLocalY(a.y));
        }
        this.updateDrag(a, true);
        if (this.bringToTop) {
          this._dragPhase = true;
          this.sprite.bringToTop();
        }
        this.dragStartPoint.set(b, c);
        this.sprite.events.onDragStart$dispatch(this.sprite, a, b, c);
        this._pendingDrag = false;
      },
      globalToLocalX: function (a) {
        if (this.scaleLayer) {
          a -= this.game.scale.grid.boundsFluid.x;
          a *= this.game.scale.grid.scaleFluidInversed.x;
        }
        return a;
      },
      globalToLocalY: function (a) {
        if (this.scaleLayer) {
          a -= this.game.scale.grid.boundsFluid.y;
          a *= this.game.scale.grid.scaleFluidInversed.y;
        }
        return a;
      },
      stopDrag: function (a) {
        this.isDragged = false;
        this._draggedPointerID = -1;
        this._pointerData[a.id].isDragged = false;
        this._dragPhase = false;
        this._pendingDrag = false;
        if (this.snapOnRelease) {
          if (this.sprite.fixedToCamera) {
            this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
            this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
          } else {
            this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;
            this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
          }
        }
        this.sprite.events.onDragStop$dispatch(this.sprite, a);
        if (false === this.checkPointerOver(a)) {
          this._pointerOutHandler(a);
        }
      },
      setDragLock: function (a, b) {
        if (undefined === a) {
          a = true;
        }
        if (undefined === b) {
          b = true;
        }
        this.allowHorizontalDrag = a;
        this.allowVerticalDrag = b;
      },
      enableSnap: function (a, b, c, d, e, f) {
        if (undefined === c) {
          c = true;
        }
        if (undefined === d) {
          d = false;
        }
        if (undefined === e) {
          e = 0;
        }
        if (undefined === f) {
          f = 0;
        }
        this.snapX = a;
        this.snapY = b;
        this.snapOffsetX = e;
        this.snapOffsetY = f;
        this.snapOnDrag = c;
        this.snapOnRelease = d;
      },
      disableSnap: function () {
        this.snapOnDrag = false;
        this.snapOnRelease = false;
      },
      checkBoundsRect: function () {
        if (this.sprite.fixedToCamera) {
          if (this.sprite.cameraOffset.x < this.boundsRect.left) {
            this.sprite.cameraOffset.x = this.boundsRect.left;
          } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {
            this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;
          }
          if (this.sprite.cameraOffset.y < this.boundsRect.top) {
            this.sprite.cameraOffset.y = this.boundsRect.top;
          } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {
            this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;
          }
        } else {
          if (this.sprite.left < this.boundsRect.left) {
            this.sprite.x = this.boundsRect.x + this.sprite.offsetX;
          } else if (this.sprite.right > this.boundsRect.right) {
            this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX);
          }
          if (this.sprite.top < this.boundsRect.top) {
            this.sprite.y = this.boundsRect.top + this.sprite.offsetY;
          } else if (this.sprite.bottom > this.boundsRect.bottom) {
            this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY);
          }
        }
      },
      checkBoundsSprite: function () {
        if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
          if (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x) {
            this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x;
          } else if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width) {
            this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width;
          }
          if (this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y) {
            this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y;
          } else if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height) {
            this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height;
          }
        } else {
          if (this.sprite.left < this.boundsSprite.left) {
            this.sprite.x = this.boundsSprite.left + this.sprite.offsetX;
          } else if (this.sprite.right > this.boundsSprite.right) {
            this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX);
          }
          if (this.sprite.top < this.boundsSprite.top) {
            this.sprite.y = this.boundsSprite.top + this.sprite.offsetY;
          } else if (this.sprite.bottom > this.boundsSprite.bottom) {
            this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY);
          }
        }
      }
    };
    b.InputHandler.prototype.constructor = b.InputHandler;
    b.Gamepad = function (a) {
      this.game = a;
      this._gamepadIndexMap = {};
      this._rawPads = [];
      this._active = false;
      this.enabled = true;
      this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads;
      this._prevRawGamepadTypes = [];
      this._prevTimestamps = [];
      this.callbackContext = this;
      this.onConnectCallback = null;
      this.onDisconnectCallback = null;
      this.onDownCallback = null;
      this.onUpCallback = null;
      this.onAxisCallback = null;
      this.onFloatCallback = null;
      this._ongamepadconnected = null;
      this._gamepaddisconnected = null;
      this._gamepads = [new b.SinglePad(a, this), new b.SinglePad(a, this), new b.SinglePad(a, this), new b.SinglePad(a, this)];
    };
    b.Gamepad.prototype = {
      addCallbacks: function (a, b) {
        if (undefined !== b) {
          this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback;
          this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback;
          this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback;
          this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback;
          this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback;
          this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback;
          this.callbackContext = a;
        }
      },
      start: function () {
        if (!this._active) {
          this._active = true;
          var a = this;
          this._onGamepadConnected = function (b) {
            return a.onGamepadConnected(b);
          };
          this._onGamepadDisconnected = function (b) {
            return a.onGamepadDisconnected(b);
          };
          window.addEventListener("gamepadconnected", this._onGamepadConnected, false);
          window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, false);
        }
      },
      onGamepadConnected: function (a) {
        var b = a.gamepad;
        this._rawPads.push(b);
        this._gamepads[b.index].connect(b);
      },
      onGamepadDisconnected: function (a) {
        var b = a.gamepad;
        for (var c in this._rawPads) if (this._rawPads[c].index === b.index) {
          this._rawPads.splice(c, 1);
        }
        this._gamepads[b.index].disconnect();
      },
      update: function () {
        this._pollGamepads();
        this.pad1.pollStatus();
        this.pad2.pollStatus();
        this.pad3.pollStatus();
        this.pad4.pollStatus();
      },
      _pollGamepads: function () {
        if (this._active) {
          if (navigator.getGamepads) {
            var a = navigator.getGamepads();
          } else if (navigator.webkitGetGamepads) {
            var a = navigator.webkitGetGamepads();
          } else if (navigator.webkitGamepads) {
            var a = navigator.webkitGamepads();
          }
          if (a) {
            this._rawPads = [];
            var b = false;
            for (var c = 0; c < a.length && (typeof a[c] !== this._prevRawGamepadTypes[c] && (b = true, this._prevRawGamepadTypes[c] = typeof a[c]), a[c] && this._rawPads.push(a[c]), 3 !== c); c++) {
              ;
            }
            for (var d = 0; d < this._gamepads.length; d++) {
              this._gamepads[d]._rawPad = this._rawPads[d];
            }
            if (b) {
              var f;
              var e = {
                rawIndices: {},
                padIndices: {}
              };
              for (var g = 0; g < this._gamepads.length; g++) {
                f = this._gamepads[g];
                if (f.connected) {
                  for (var h = 0; h < this._rawPads.length; h++) {
                    if (this._rawPads[h].index === f.index) {
                      e.rawIndices[f.index] = true;
                      e.padIndices[g] = true;
                    }
                  }
                }
              }
              for (var i = 0; i < this._gamepads.length; i++) {
                f = this._gamepads[i];
                if (!e.padIndices[i]) {
                  if (this._rawPads.length < 1) {
                    f.disconnect();
                  }
                  for (var j = 0; j < this._rawPads.length && !e.padIndices[i]; j++) {
                    var k = this._rawPads[j];
                    if (k) {
                      if (e.rawIndices[k.index]) {
                        f.disconnect();
                        continue;
                      }
                      f.connect(k);
                      e.rawIndices[k.index] = true;
                      e.padIndices[i] = true;
                    } else {
                      f.disconnect();
                    }
                  }
                }
              }
            }
          }
        }
      },
      setDeadZones: function (a) {
        for (var b = 0; b < this._gamepads.length; b++) {
          this._gamepads[b].deadZone = a;
        }
      },
      stop: function () {
        this._active = false;
        window.removeEventListener("gamepadconnected", this._onGamepadConnected);
        window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected);
      },
      reset: function () {
        this.update();
        for (var a = 0; a < this._gamepads.length; a++) {
          this._gamepads[a].reset();
        }
      },
      justPressed: function (a, b) {
        for (var c = 0; c < this._gamepads.length; c++) {
          if (true === this._gamepads[c].justPressed(a, b)) {
            return true;
          }
        }
        return false;
      },
      justReleased: function (a, b) {
        for (var c = 0; c < this._gamepads.length; c++) {
          if (true === this._gamepads[c].justReleased(a, b)) {
            return true;
          }
        }
        return false;
      },
      isDown: function (a) {
        for (var b = 0; b < this._gamepads.length; b++) {
          if (true === this._gamepads[b].isDown(a)) {
            return true;
          }
        }
        return false;
      },
      destroy: function () {
        this.stop();
        for (var a = 0; a < this._gamepads.length; a++) {
          this._gamepads[a].destroy();
        }
      }
    };
    b.Gamepad.prototype.constructor = b.Gamepad;
    Object.defineProperty(b.Gamepad.prototype, "active", {
      get: function () {
        return this._active;
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "supported", {
      get: function () {
        return this._gamepadSupportAvailable;
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "padsConnected", {
      get: function () {
        return this._rawPads.length;
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "pad1", {
      get: function () {
        return this._gamepads[0];
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "pad2", {
      get: function () {
        return this._gamepads[1];
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "pad3", {
      get: function () {
        return this._gamepads[2];
      }
    });
    Object.defineProperty(b.Gamepad.prototype, "pad4", {
      get: function () {
        return this._gamepads[3];
      }
    });
    b.Gamepad.BUTTON_0 = 0;
    b.Gamepad.BUTTON_1 = 1;
    b.Gamepad.BUTTON_2 = 2;
    b.Gamepad.BUTTON_3 = 3;
    b.Gamepad.BUTTON_4 = 4;
    b.Gamepad.BUTTON_5 = 5;
    b.Gamepad.BUTTON_6 = 6;
    b.Gamepad.BUTTON_7 = 7;
    b.Gamepad.BUTTON_8 = 8;
    b.Gamepad.BUTTON_9 = 9;
    b.Gamepad.BUTTON_10 = 10;
    b.Gamepad.BUTTON_11 = 11;
    b.Gamepad.BUTTON_12 = 12;
    b.Gamepad.BUTTON_13 = 13;
    b.Gamepad.BUTTON_14 = 14;
    b.Gamepad.BUTTON_15 = 15;
    b.Gamepad.AXIS_0 = 0;
    b.Gamepad.AXIS_1 = 1;
    b.Gamepad.AXIS_2 = 2;
    b.Gamepad.AXIS_3 = 3;
    b.Gamepad.AXIS_4 = 4;
    b.Gamepad.AXIS_5 = 5;
    b.Gamepad.AXIS_6 = 6;
    b.Gamepad.AXIS_7 = 7;
    b.Gamepad.AXIS_8 = 8;
    b.Gamepad.AXIS_9 = 9;
    b.Gamepad.XBOX360_A = 0;
    b.Gamepad.XBOX360_B = 1;
    b.Gamepad.XBOX360_X = 2;
    b.Gamepad.XBOX360_Y = 3;
    b.Gamepad.XBOX360_LEFT_BUMPER = 4;
    b.Gamepad.XBOX360_RIGHT_BUMPER = 5;
    b.Gamepad.XBOX360_LEFT_TRIGGER = 6;
    b.Gamepad.XBOX360_RIGHT_TRIGGER = 7;
    b.Gamepad.XBOX360_BACK = 8;
    b.Gamepad.XBOX360_START = 9;
    b.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;
    b.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;
    b.Gamepad.XBOX360_DPAD_LEFT = 14;
    b.Gamepad.XBOX360_DPAD_RIGHT = 15;
    b.Gamepad.XBOX360_DPAD_UP = 12;
    b.Gamepad.XBOX360_DPAD_DOWN = 13;
    b.Gamepad.XBOX360_STICK_LEFT_X = 0;
    b.Gamepad.XBOX360_STICK_LEFT_Y = 1;
    b.Gamepad.XBOX360_STICK_RIGHT_X = 2;
    b.Gamepad.XBOX360_STICK_RIGHT_Y = 3;
    b.Gamepad.PS3XC_X = 0;
    b.Gamepad.PS3XC_CIRCLE = 1;
    b.Gamepad.PS3XC_SQUARE = 2;
    b.Gamepad.PS3XC_TRIANGLE = 3;
    b.Gamepad.PS3XC_L1 = 4;
    b.Gamepad.PS3XC_R1 = 5;
    b.Gamepad.PS3XC_L2 = 6;
    b.Gamepad.PS3XC_R2 = 7;
    b.Gamepad.PS3XC_SELECT = 8;
    b.Gamepad.PS3XC_START = 9;
    b.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10;
    b.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11;
    b.Gamepad.PS3XC_DPAD_UP = 12;
    b.Gamepad.PS3XC_DPAD_DOWN = 13;
    b.Gamepad.PS3XC_DPAD_LEFT = 14;
    b.Gamepad.PS3XC_DPAD_RIGHT = 15;
    b.Gamepad.PS3XC_STICK_LEFT_X = 0;
    b.Gamepad.PS3XC_STICK_LEFT_Y = 1;
    b.Gamepad.PS3XC_STICK_RIGHT_X = 2;
    b.Gamepad.PS3XC_STICK_RIGHT_Y = 3;
    b.SinglePad = function (a, b) {
      this.game = a;
      this.index = null;
      this.connected = false;
      this.callbackContext = this;
      this.onConnectCallback = null;
      this.onDisconnectCallback = null;
      this.onDownCallback = null;
      this.onUpCallback = null;
      this.onAxisCallback = null;
      this.onFloatCallback = null;
      this.deadZone = .26;
      this._padParent = b;
      this._rawPad = null;
      this._prevTimestamp = null;
      this._buttons = [];
      this._buttonsLen = 0;
      this._axes = [];
      this._axesLen = 0;
    };
    b.SinglePad.prototype = {
      addCallbacks: function (a, b) {
        if (undefined !== b) {
          this.onConnectCallback = "function" == typeof b.onConnect ? b.onConnect : this.onConnectCallback;
          this.onDisconnectCallback = "function" == typeof b.onDisconnect ? b.onDisconnect : this.onDisconnectCallback;
          this.onDownCallback = "function" == typeof b.onDown ? b.onDown : this.onDownCallback;
          this.onUpCallback = "function" == typeof b.onUp ? b.onUp : this.onUpCallback;
          this.onAxisCallback = "function" == typeof b.onAxis ? b.onAxis : this.onAxisCallback;
          this.onFloatCallback = "function" == typeof b.onFloat ? b.onFloat : this.onFloatCallback;
          this.callbackContext = a;
        }
      },
      getButton: function (a) {
        return this._buttons[a] ? this._buttons[a] : null;
      },
      pollStatus: function () {
        if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
          for (var a = 0; a < this._buttonsLen; a++) {
            var b = isNaN(this._rawPad.buttons[a]) ? this._rawPad.buttons[a].value : this._rawPad.buttons[a];
            if (b !== this._buttons[a].value) {
              if (1 === b) {
                this.processButtonDown(a, b);
              } else if (0 === b) {
                this.processButtonUp(a, b);
              } else {
                this.processButtonFloat(a, b);
              }
            }
          }
          for (var c = 0; c < this._axesLen; c++) {
            var d = this._rawPad.axes[c];
            if (d > 0 && d > this.deadZone || d < 0 && d < -this.deadZone) {
              this.processAxisChange(c, d);
            } else {
              this.processAxisChange(c, 0);
            }
          }
          this._prevTimestamp = this._rawPad.timestamp;
        }
      },
      connect: function (a) {
        var c = !this.connected;
        this.connected = true;
        this.index = a.index;
        this._rawPad = a;
        this._buttons = [];
        this._buttonsLen = a.buttons.length;
        this._axes = [];
        this._axesLen = a.axes.length;
        for (var d = 0; d < this._axesLen; d++) {
          this._axes[d] = a.axes[d];
        }
        for (var e in a.buttons) {
          e = parseInt(e, 10);
          this._buttons[e] = new b.DeviceButton(this, e);
        }
        if (c && this._padParent.onConnectCallback) {
          this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index);
        }
        if (c && this.onConnectCallback) {
          this.onConnectCallback.call(this.callbackContext);
        }
      },
      disconnect: function () {
        var a = this.connected;
        var b = this.index;
        this.connected = false;
        this.index = null;
        this._rawPad = undefined;
        for (var c = 0; c < this._buttonsLen; c++) {
          this._buttons[c].destroy();
        }
        this._buttons = [];
        this._buttonsLen = 0;
        this._axes = [];
        this._axesLen = 0;
        if (a && this._padParent.onDisconnectCallback) {
          this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, b);
        }
        if (a && this.onDisconnectCallback) {
          this.onDisconnectCallback.call(this.callbackContext);
        }
      },
      destroy: function () {
        this._rawPad = undefined;
        for (var a = 0; a < this._buttonsLen; a++) {
          this._buttons[a].destroy();
        }
        this._buttons = [];
        this._buttonsLen = 0;
        this._axes = [];
        this._axesLen = 0;
        this.onConnectCallback = null;
        this.onDisconnectCallback = null;
        this.onDownCallback = null;
        this.onUpCallback = null;
        this.onAxisCallback = null;
        this.onFloatCallback = null;
      },
      processAxisChange: function (a, b) {
        if (this._axes[a] !== b) {
          this._axes[a] = b;
          if (this._padParent.onAxisCallback) {
            this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, a, b);
          }
          if (this.onAxisCallback) {
            this.onAxisCallback.call(this.callbackContext, this, a, b);
          }
        }
      },
      processButtonDown: function (a, b) {
        if (this._buttons[a]) {
          this._buttons[a].start(null, b);
        }
        if (this._padParent.onDownCallback) {
          this._padParent.onDownCallback.call(this._padParent.callbackContext, a, b, this.index);
        }
        if (this.onDownCallback) {
          this.onDownCallback.call(this.callbackContext, a, b);
        }
      },
      processButtonUp: function (a, b) {
        if (this._padParent.onUpCallback) {
          this._padParent.onUpCallback.call(this._padParent.callbackContext, a, b, this.index);
        }
        if (this.onUpCallback) {
          this.onUpCallback.call(this.callbackContext, a, b);
        }
        if (this._buttons[a]) {
          this._buttons[a].stop(null, b);
        }
      },
      processButtonFloat: function (a, b) {
        if (this._padParent.onFloatCallback) {
          this._padParent.onFloatCallback.call(this._padParent.callbackContext, a, b, this.index);
        }
        if (this.onFloatCallback) {
          this.onFloatCallback.call(this.callbackContext, a, b);
        }
        if (this._buttons[a]) {
          this._buttons[a].padFloat(b);
        }
      },
      axis: function (a) {
        return !!this._axes[a] && this._axes[a];
      },
      isDown: function (a) {
        return !!this._buttons[a] && this._buttons[a].isDown;
      },
      isUp: function (a) {
        return !!this._buttons[a] && this._buttons[a].isUp;
      },
      justReleased: function (a, b) {
        if (this._buttons[a]) {
          return this._buttons[a].justReleased(b);
        }
      },
      justPressed: function (a, b) {
        if (this._buttons[a]) {
          return this._buttons[a].justPressed(b);
        }
      },
      buttonValue: function (a) {
        return this._buttons[a] ? this._buttons[a].value : null;
      },
      reset: function () {
        for (var a = 0; a < this._axes.length; a++) {
          this._axes[a] = 0;
        }
      }
    };
    b.SinglePad.prototype.constructor = b.SinglePad;
    b.Key = function (a, c) {
      this.game = a;
      this._enabled = true;
      this.event = null;
      this.isDown = false;
      this.isUp = true;
      this.altKey = false;
      this.ctrlKey = false;
      this.shiftKey = false;
      this.timeDown = 0;
      this.duration = 0;
      this.timeUp = -2500;
      this.repeats = 0;
      this.keyCode = c;
      this.onDown = new b.Signal();
      this.onHoldCallback = null;
      this.onHoldContext = null;
      this.onUp = new b.Signal();
      this._justDown = false;
      this._justUp = false;
    };
    b.Key.prototype = {
      update: function () {
        if (this._enabled && this.isDown) {
          this.duration = this.game.time.time - this.timeDown;
          this.repeats++;
          if (this.onHoldCallback) {
            this.onHoldCallback.call(this.onHoldContext, this);
          }
        }
      },
      processKeyDown: function (a) {
        if (this._enabled) {
          this.event = a;
          if (!this.isDown) {
            this.altKey = a.altKey;
            this.ctrlKey = a.ctrlKey;
            this.shiftKey = a.shiftKey;
            this.isDown = true;
            this.isUp = false;
            this.timeDown = this.game.time.time;
            this.duration = 0;
            this.repeats = 0;
            this._justDown = true;
            this.onDown.dispatch(this);
          }
        }
      },
      processKeyUp: function (a) {
        if (this._enabled) {
          this.event = a;
          if (!this.isUp) {
            this.isDown = false;
            this.isUp = true;
            this.timeUp = this.game.time.time;
            this.duration = this.game.time.time - this.timeDown;
            this._justUp = true;
            this.onUp.dispatch(this);
          }
        }
      },
      reset: function (a) {
        if (undefined === a) {
          a = true;
        }
        this.isDown = false;
        this.isUp = true;
        this.timeUp = this.game.time.time;
        this.duration = 0;
        this._enabled = true;
        this._justDown = false;
        this._justUp = false;
        if (a) {
          this.onDown.removeAll();
          this.onUp.removeAll();
          this.onHoldCallback = null;
          this.onHoldContext = null;
        }
      },
      downDuration: function (a) {
        if (undefined === a) {
          a = 50;
        }
        return this.isDown && this.duration < a;
      },
      upDuration: function (a) {
        if (undefined === a) {
          a = 50;
        }
        return !this.isDown && this.game.time.time - this.timeUp < a;
      }
    };
    Object.defineProperty(b.Key.prototype, "justDown", {
      get: function () {
        var a = this._justDown;
        this._justDown = false;
        return a;
      }
    });
    Object.defineProperty(b.Key.prototype, "justUp", {
      get: function () {
        var a = this._justUp;
        this._justUp = false;
        return a;
      }
    });
    Object.defineProperty(b.Key.prototype, "enabled", {
      get: function () {
        return this._enabled;
      },
      set: function (a) {
        if ((a = !!a) !== this._enabled) {
          if (!a) {
            this.reset(false);
          }
          this._enabled = a;
        }
      }
    });
    b.Key.prototype.constructor = b.Key;
    b.Keyboard = function (a) {
      this.game = a;
      this.enabled = true;
      this.event = null;
      this.pressEvent = null;
      this.callbackContext = this;
      this.onDownCallback = null;
      this.onPressCallback = null;
      this.onUpCallback = null;
      this._keys = [];
      this._capture = [];
      this._onKeyDown = null;
      this._onKeyPress = null;
      this._onKeyUp = null;
      this._i = 0;
      this._k = 0;
    };
    b.Keyboard.prototype = {
      addCallbacks: function (a, b, c, d) {
        this.callbackContext = a;
        if (undefined !== b && null !== b) {
          this.onDownCallback = b;
        }
        if (undefined !== c && null !== c) {
          this.onUpCallback = c;
        }
        if (undefined !== d && null !== d) {
          this.onPressCallback = d;
        }
      },
      addKey: function (a) {
        if (!this._keys[a]) {
          this._keys[a] = new b.Key(this.game, a);
          this.addKeyCapture(a);
        }
        return this._keys[a];
      },
      addKeys: function (a) {
        var b = {};
        for (var c in a) b[c] = this.addKey(a[c]);
        return b;
      },
      removeKey: function (a) {
        if (this._keys[a]) {
          this._keys[a] = null;
          this.removeKeyCapture(a);
        }
      },
      createCursorKeys: function () {
        return this.addKeys({
          up: b.KeyCode.UP,
          down: b.KeyCode.DOWN,
          left: b.KeyCode.LEFT,
          right: b.KeyCode.RIGHT
        });
      },
      start: function () {
        if (!this.game.device.cocoonJS && null === this._onKeyDown) {
          var a = this;
          this._onKeyDown = function (b) {
            return a.processKeyDown(b);
          };
          this._onKeyUp = function (b) {
            return a.processKeyUp(b);
          };
          this._onKeyPress = function (b) {
            return a.processKeyPress(b);
          };
          window.addEventListener("keydown", this._onKeyDown, false);
          window.addEventListener("keyup", this._onKeyUp, false);
          window.addEventListener("keypress", this._onKeyPress, false);
        }
      },
      stop: function () {
        window.removeEventListener("keydown", this._onKeyDown);
        window.removeEventListener("keyup", this._onKeyUp);
        window.removeEventListener("keypress", this._onKeyPress);
        this._onKeyDown = null;
        this._onKeyUp = null;
        this._onKeyPress = null;
      },
      destroy: function () {
        this.stop();
        this.clearCaptures();
        this._keys.length = 0;
        this._i = 0;
      },
      addKeyCapture: function (a) {
        if ("object" == typeof a) {
          for (var b in a) this._capture[a[b]] = true;
        } else {
          this._capture[a] = true;
        }
      },
      removeKeyCapture: function (a) {
        delete this._capture[a];
      },
      clearCaptures: function () {
        this._capture = {};
      },
      update: function () {
        for (this._i = this._keys.length; this._i--;) {
          if (this._keys[this._i]) {
            this._keys[this._i].update();
          }
        }
      },
      processKeyDown: function (a) {
        this.event = a;
        if (this.game.input.enabled && this.enabled) {
          var c = a.keyCode;
          if (this._capture[c]) {
            a.preventDefault();
          }
          if (!this._keys[c]) {
            this._keys[c] = new b.Key(this.game, c);
          }
          this._keys[c].processKeyDown(a);
          this._k = c;
          if (this.onDownCallback) {
            this.onDownCallback.call(this.callbackContext, a);
          }
        }
      },
      processKeyPress: function (a) {
        this.pressEvent = a;
        if (this.game.input.enabled && this.enabled && this.onPressCallback) {
          this.onPressCallback.call(this.callbackContext, String.fromCharCode(a.charCode), a);
        }
      },
      processKeyUp: function (a) {
        this.event = a;
        if (this.game.input.enabled && this.enabled) {
          var c = a.keyCode;
          if (this._capture[c]) {
            a.preventDefault();
          }
          if (!this._keys[c]) {
            this._keys[c] = new b.Key(this.game, c);
          }
          this._keys[c].processKeyUp(a);
          if (this.onUpCallback) {
            this.onUpCallback.call(this.callbackContext, a);
          }
        }
      },
      reset: function (a) {
        if (undefined === a) {
          a = true;
        }
        this.event = null;
        for (var b = this._keys.length; b--;) {
          if (this._keys[b]) {
            this._keys[b].reset(a);
          }
        }
      },
      downDuration: function (a, b) {
        return this._keys[a] ? this._keys[a].downDuration(b) : null;
      },
      upDuration: function (a, b) {
        return this._keys[a] ? this._keys[a].upDuration(b) : null;
      },
      isDown: function (a) {
        return this._keys[a] ? this._keys[a].isDown : null;
      }
    };
    Object.defineProperty(b.Keyboard.prototype, "lastChar", {
      get: function () {
        return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode);
      }
    });
    Object.defineProperty(b.Keyboard.prototype, "lastKey", {
      get: function () {
        return this._keys[this._k];
      }
    });
    b.Keyboard.prototype.constructor = b.Keyboard;
    b.KeyCode = {
      A: "A".charCodeAt(0),
      B: "B".charCodeAt(0),
      C: "C".charCodeAt(0),
      D: "D".charCodeAt(0),
      E: "E".charCodeAt(0),
      F: "F".charCodeAt(0),
      G: "G".charCodeAt(0),
      H: "H".charCodeAt(0),
      I: "I".charCodeAt(0),
      J: "J".charCodeAt(0),
      K: "K".charCodeAt(0),
      L: "L".charCodeAt(0),
      M: "M".charCodeAt(0),
      N: "N".charCodeAt(0),
      O: "O".charCodeAt(0),
      P: "P".charCodeAt(0),
      Q: "Q".charCodeAt(0),
      R: "R".charCodeAt(0),
      S: "S".charCodeAt(0),
      T: "T".charCodeAt(0),
      U: "U".charCodeAt(0),
      V: "V".charCodeAt(0),
      W: "W".charCodeAt(0),
      X: "X".charCodeAt(0),
      Y: "Y".charCodeAt(0),
      Z: "Z".charCodeAt(0),
      ZERO: "0".charCodeAt(0),
      ONE: "1".charCodeAt(0),
      TWO: "2".charCodeAt(0),
      THREE: "3".charCodeAt(0),
      FOUR: "4".charCodeAt(0),
      FIVE: "5".charCodeAt(0),
      SIX: "6".charCodeAt(0),
      SEVEN: "7".charCodeAt(0),
      EIGHT: "8".charCodeAt(0),
      NINE: "9".charCodeAt(0),
      NUMPAD_0: 96,
      NUMPAD_1: 97,
      NUMPAD_2: 98,
      NUMPAD_3: 99,
      NUMPAD_4: 100,
      NUMPAD_5: 101,
      NUMPAD_6: 102,
      NUMPAD_7: 103,
      NUMPAD_8: 104,
      NUMPAD_9: 105,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_ADD: 107,
      NUMPAD_ENTER: 108,
      NUMPAD_SUBTRACT: 109,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      F13: 124,
      F14: 125,
      F15: 126,
      COLON: 186,
      EQUALS: 187,
      COMMA: 188,
      UNDERSCORE: 189,
      PERIOD: 190,
      QUESTION_MARK: 191,
      TILDE: 192,
      OPEN_BRACKET: 219,
      BACKWARD_SLASH: 220,
      CLOSED_BRACKET: 221,
      QUOTES: 222,
      BACKSPACE: 8,
      TAB: 9,
      CLEAR: 12,
      ENTER: 13,
      SHIFT: 16,
      CONTROL: 17,
      ALT: 18,
      CAPS_LOCK: 20,
      ESC: 27,
      SPACEBAR: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      PLUS: 43,
      MINUS: 44,
      INSERT: 45,
      DELETE: 46,
      HELP: 47,
      NUM_LOCK: 144
    };
    for (var e in b.KeyCode) if (b.KeyCode.hasOwnProperty(e) && !e.match(/[a-z]/)) {
      b.Keyboard[e] = b.KeyCode[e];
    }
    b.Component = function () {};
    b.Component.Angle = function () {};
    b.Component.Angle.prototype = {
      angle: {
        get: function () {
          return b.Math.wrapAngle(b.Math.radToDeg(this.rotation));
        },
        set: function (a) {
          this.rotation = b.Math.degToRad(b.Math.wrapAngle(a));
        }
      }
    };
    b.Component.Animation = function () {};
    b.Component.Animation.prototype = {
      play: function (a, b, c, d) {
        if (this.animations) {
          return this.animations.play(a, b, c, d);
        }
      }
    };
    b.Component.AutoCull = function () {};
    b.Component.AutoCull.prototype = {
      autoCull: false,
      inCamera: {
        get: function () {
          if (!(this.autoCull || this.checkWorldBounds)) {
            this._bounds.copyFrom(this.getBounds());
            this._bounds.x += this.game.camera.view.x;
            this._bounds.y += this.game.camera.view.y;
          }
          return this.game.world.camera.view.intersects(this._bounds);
        }
      }
    };
    b.Component.Bounds = function () {};
    b.Component.Bounds.prototype = {
      offsetX: {
        get: function () {
          return this.anchor.x * this.width;
        }
      },
      offsetY: {
        get: function () {
          return this.anchor.y * this.height;
        }
      },
      centerX: {
        get: function () {
          return this.x - this.offsetX + .5 * this.width;
        },
        set: function (a) {
          this.x = a + this.offsetX - .5 * this.width;
        }
      },
      centerY: {
        get: function () {
          return this.y - this.offsetY + .5 * this.height;
        },
        set: function (a) {
          this.y = a + this.offsetY - .5 * this.height;
        }
      },
      left: {
        get: function () {
          return this.x - this.offsetX;
        },
        set: function (a) {
          this.x = a + this.offsetX;
        }
      },
      right: {
        get: function () {
          return this.x + this.width - this.offsetX;
        },
        set: function (a) {
          this.x = a - this.width + this.offsetX;
        }
      },
      top: {
        get: function () {
          return this.y - this.offsetY;
        },
        set: function (a) {
          this.y = a + this.offsetY;
        }
      },
      bottom: {
        get: function () {
          return this.y + this.height - this.offsetY;
        },
        set: function (a) {
          this.y = a - this.height + this.offsetY;
        }
      },
      alignIn: function (a, c, d, e) {
        if (undefined === d) {
          d = 0;
        }
        if (undefined === e) {
          e = 0;
        }
        switch (c) {
          default:
          case b.TOP_LEFT:
            this.left = a.left - d;
            this.top = a.top - e;
            break;
          case b.TOP_CENTER:
            this.centerX = a.centerX + d;
            this.top = a.top - e;
            break;
          case b.TOP_RIGHT:
            this.right = a.right + d;
            this.top = a.top - e;
            break;
          case b.LEFT_CENTER:
            this.left = a.left - d;
            this.centerY = a.centerY + e;
            break;
          case b.CENTER:
            this.centerX = a.centerX + d;
            this.centerY = a.centerY + e;
            break;
          case b.RIGHT_CENTER:
            this.right = a.right + d;
            this.centerY = a.centerY + e;
            break;
          case b.BOTTOM_LEFT:
            this.left = a.left - d;
            this.bottom = a.bottom + e;
            break;
          case b.BOTTOM_CENTER:
            this.centerX = a.centerX + d;
            this.bottom = a.bottom + e;
            break;
          case b.BOTTOM_RIGHT:
            this.right = a.right + d;
            this.bottom = a.bottom + e;
        }
        return this;
      },
      alignTo: function (a, c, d, e) {
        if (undefined === d) {
          d = 0;
        }
        if (undefined === e) {
          e = 0;
        }
        switch (c) {
          default:
          case b.TOP_LEFT:
            this.left = a.left - d;
            this.bottom = a.top - e;
            break;
          case b.TOP_CENTER:
            this.centerX = a.centerX + d;
            this.bottom = a.top - e;
            break;
          case b.TOP_RIGHT:
            this.right = a.right + d;
            this.bottom = a.top - e;
            break;
          case b.LEFT_TOP:
            this.right = a.left - d;
            this.top = a.top - e;
            break;
          case b.LEFT_CENTER:
            this.right = a.left - d;
            this.centerY = a.centerY + e;
            break;
          case b.LEFT_BOTTOM:
            this.right = a.left - d;
            this.bottom = a.bottom + e;
            break;
          case b.RIGHT_TOP:
            this.left = a.right + d;
            this.top = a.top - e;
            break;
          case b.RIGHT_CENTER:
            this.left = a.right + d;
            this.centerY = a.centerY + e;
            break;
          case b.RIGHT_BOTTOM:
            this.left = a.right + d;
            this.bottom = a.bottom + e;
            break;
          case b.BOTTOM_LEFT:
            this.left = a.left - d;
            this.top = a.bottom + e;
            break;
          case b.BOTTOM_CENTER:
            this.centerX = a.centerX + d;
            this.top = a.bottom + e;
            break;
          case b.BOTTOM_RIGHT:
            this.right = a.right + d;
            this.top = a.bottom + e;
        }
        return this;
      }
    };
    b.Group.prototype.alignIn = b.Component.Bounds.prototype.alignIn;
    b.Group.prototype.alignTo = b.Component.Bounds.prototype.alignTo;
    b.Component.BringToTop = function () {};
    b.Component.BringToTop.prototype.bringToTop = function () {
      if (this.parent) {
        this.parent.bringToTop(this);
      }
      return this;
    };
    b.Component.BringToTop.prototype.sendToBack = function () {
      if (this.parent) {
        this.parent.sendToBack(this);
      }
      return this;
    };
    b.Component.BringToTop.prototype.moveUp = function () {
      if (this.parent) {
        this.parent.moveUp(this);
      }
      return this;
    };
    b.Component.BringToTop.prototype.moveDown = function () {
      if (this.parent) {
        this.parent.moveDown(this);
      }
      return this;
    };
    b.Component.Core = function () {};
    b.Component.Core.install = function (a) {
      b.Utils.mixinPrototype(this, b.Component.Core.prototype);
      this.components = {};
      for (var c = 0; c < a.length; c++) {
        var d = a[c];
        var e = false;
        if ("Destroy" === d) {
          e = true;
        }
        b.Utils.mixinPrototype(this, b.Component[d].prototype, e);
        this.components[d] = true;
      }
    };
    b.Component.Core.init = function (a, c, d, e, f) {
      this.game = a;
      this.key = e;
      this.data = {};
      this.position.set(c, d);
      this.world = new b.Point(c, d);
      this.previousPosition = new b.Point(c, d);
      this.events = new b.Events(this);
      this._bounds = new b.Rectangle();
      if (this.components.PhysicsBody) {
        this.body = this.body;
      }
      if (this.components.Animation) {
        this.animations = new b.AnimationManager(this);
      }
      if (this.components.LoadTexture && null !== e) {
        this.loadTexture(e, f);
      }
      if (this.components.FixedToCamera) {
        this.cameraOffset = new b.Point(c, d);
      }
    };
    b.Component.Core.preUpdate = function () {
      if (this.pendingDestroy) {
        return void this.destroy();
      }
      this.previousPosition.set(this.world.x, this.world.y);
      this.previousRotation = this.rotation;
      if (!this.exists || !this.parent.exists) {
        this.renderOrderID = -1;
        return false;
      }
      this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);
      if (this.visible) {
        this.renderOrderID = this.game.stage.currentRenderOrderID++;
      }
      if (this.animations) {
        this.animations.update();
      }
      if (this.body) {
        this.body.preUpdate();
      }
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].preUpdate();
      }
      return true;
    };
    b.Component.Core.prototype = {
      game: null,
      name: "",
      data: {},
      components: {},
      z: 0,
      events: undefined,
      animations: undefined,
      key: "",
      world: null,
      debug: false,
      previousPosition: null,
      previousRotation: 0,
      renderOrderID: 0,
      fresh: true,
      pendingDestroy: false,
      _bounds: null,
      _exists: true,
      exists: {
        get: function () {
          return this._exists;
        },
        set: function (a) {
          if (a) {
            this._exists = true;
            if (this.body && this.body.type === b.Physics.P2JS) {
              this.body.addToWorld();
            }
            this.visible = true;
          } else {
            this._exists = false;
            if (this.body && this.body.type === b.Physics.P2JS) {
              this.body.removeFromWorld();
            }
            this.visible = false;
          }
        }
      },
      update: function () {},
      postUpdate: function () {
        if (this.customRender) {
          this.key.render();
        }
        if (this.components.PhysicsBody) {
          b.Component.PhysicsBody.postUpdate.call(this);
        }
        if (this.components.FixedToCamera) {
          b.Component.FixedToCamera.postUpdate.call(this);
        }
        for (var a = 0; a < this.children.length; a++) {
          this.children[a].postUpdate();
        }
      }
    };
    b.Component.Crop = function () {};
    b.Component.Crop.prototype = {
      cropRect: null,
      _crop: null,
      crop: function (a, c) {
        if (undefined === c) {
          c = false;
        }
        if (a) {
          if (c && null !== this.cropRect) {
            this.cropRect.setTo(a.x, a.y, a.width, a.height);
          } else if (c && null === this.cropRect) {
            this.cropRect = new b.Rectangle(a.x, a.y, a.width, a.height);
          } else {
            this.cropRect = a;
          }
          this.updateCrop();
        } else {
          this._crop = null;
          this.cropRect = null;
          this.resetFrame();
        }
      },
      updateCrop: function () {
        if (this.cropRect) {
          var a = this.texture.crop.x;
          var c = this.texture.crop.y;
          var d = this.texture.crop.width;
          var e = this.texture.crop.height;
          this._crop = b.Rectangle.clone(this.cropRect, this._crop);
          this._crop.x += this._frame.x;
          this._crop.y += this._frame.y;
          var f = Math.max(this._frame.x, this._crop.x);
          var g = Math.max(this._frame.y, this._crop.y);
          var h = Math.min(this._frame.right, this._crop.right) - f;
          var i = Math.min(this._frame.bottom, this._crop.bottom) - g;
          this.texture.crop.x = f;
          this.texture.crop.y = g;
          this.texture.crop.width = h;
          this.texture.crop.height = i;
          this.texture.frame.width = Math.min(h, this.cropRect.width);
          this.texture.frame.height = Math.min(i, this.cropRect.height);
          this.texture.width = this.texture.frame.width;
          this.texture.height = this.texture.frame.height;
          this.texture._updateUvs();
          if (!(16777215 === this.tint || a === f && c === g && d === h && e === i)) {
            this.texture.requiresReTint = true;
          }
        }
      }
    };
    b.Component.Delta = function () {};
    b.Component.Delta.prototype = {
      deltaX: {
        get: function () {
          return this.world.x - this.previousPosition.x;
        }
      },
      deltaY: {
        get: function () {
          return this.world.y - this.previousPosition.y;
        }
      },
      deltaZ: {
        get: function () {
          return this.rotation - this.previousRotation;
        }
      }
    };
    b.Component.Destroy = function () {};
    b.Component.Destroy.prototype = {
      destroyPhase: false,
      destroy: function (a, c) {
        if (null !== this.game && !this.destroyPhase) {
          if (undefined === a) {
            a = true;
          }
          if (undefined === c) {
            c = false;
          }
          this.destroyPhase = true;
          if (this.events) {
            this.events.onDestroy$dispatch(this);
          }
          if (this.parent) {
            if (this.parent instanceof b.Group) {
              this.parent.remove(this);
            } else {
              this.parent.removeChild(this);
            }
          }
          if (this.input) {
            this.input.destroy();
          }
          if (this.animations) {
            this.animations.destroy();
          }
          if (this.body) {
            this.body.destroy();
          }
          if (this.events) {
            this.events.destroy();
          }
          this.game.tweens.removeFrom(this);
          var d = this.children.length;
          if (a) {
            for (; d--;) {
              this.children[d].destroy(a);
            }
          } else {
            for (; d--;) {
              this.removeChild(this.children[d]);
            }
          }
          if (this._crop) {
            this._crop = null;
            this.cropRect = null;
          }
          if (this._frame) {
            this._frame = null;
          }
          if (b.Video && this.key instanceof b.Video) {
            this.key.onChangeSource.remove(this.resizeFrame, this);
          }
          if (b.BitmapText && this._glyphs) {
            this._glyphs = [];
          }
          this.alive = false;
          this.exists = false;
          this.visible = false;
          this.filters = null;
          this.mask = null;
          this.game = null;
          this.data = {};
          this.renderable = false;
          if (this.transformCallback) {
            this.transformCallback = null;
            this.transformCallbackContext = null;
          }
          this.hitArea = null;
          this.parent = null;
          this.stage = null;
          this.worldTransform = null;
          this.filterArea = null;
          this._bounds = null;
          this._currentBounds = null;
          this._mask = null;
          this._destroyCachedSprite();
          if (c) {
            this.texture.destroy(true);
          }
          this.destroyPhase = false;
          this.pendingDestroy = false;
        }
      }
    };
    b.Events = function (a) {
      this.parent = a;
    };
    b.Events.prototype = {
      destroy: function () {
        this._parent = null;
        if (this._onDestroy) {
          this._onDestroy.dispose();
        }
        if (this._onAddedToGroup) {
          this._onAddedToGroup.dispose();
        }
        if (this._onRemovedFromGroup) {
          this._onRemovedFromGroup.dispose();
        }
        if (this._onRemovedFromWorld) {
          this._onRemovedFromWorld.dispose();
        }
        if (this._onKilled) {
          this._onKilled.dispose();
        }
        if (this._onRevived) {
          this._onRevived.dispose();
        }
        if (this._onEnterBounds) {
          this._onEnterBounds.dispose();
        }
        if (this._onOutOfBounds) {
          this._onOutOfBounds.dispose();
        }
        if (this._onInputOver) {
          this._onInputOver.dispose();
        }
        if (this._onInputOut) {
          this._onInputOut.dispose();
        }
        if (this._onInputDown) {
          this._onInputDown.dispose();
        }
        if (this._onInputUp) {
          this._onInputUp.dispose();
        }
        if (this._onDragStart) {
          this._onDragStart.dispose();
        }
        if (this._onDragUpdate) {
          this._onDragUpdate.dispose();
        }
        if (this._onDragStop) {
          this._onDragStop.dispose();
        }
        if (this._onAnimationStart) {
          this._onAnimationStart.dispose();
        }
        if (this._onAnimationComplete) {
          this._onAnimationComplete.dispose();
        }
        if (this._onAnimationLoop) {
          this._onAnimationLoop.dispose();
        }
      },
      onAddedToGroup: null,
      onRemovedFromGroup: null,
      onRemovedFromWorld: null,
      onDestroy: null,
      onKilled: null,
      onRevived: null,
      onOutOfBounds: null,
      onEnterBounds: null,
      onInputOver: null,
      onInputOut: null,
      onInputDown: null,
      onInputUp: null,
      onDragStart: null,
      onDragUpdate: null,
      onDragStop: null,
      onAnimationStart: null,
      onAnimationComplete: null,
      onAnimationLoop: null
    };
    b.Events.prototype.constructor = b.Events;
    for (var f in b.Events.prototype) if (b.Events.prototype.hasOwnProperty(f) && 0 === f.indexOf("on") && null === b.Events.prototype[f]) {
      (function (a, c) {
        "use strict";
  
        Object.defineProperty(b.Events.prototype, a, {
          get: function () {
            return this[c] || (this[c] = new b.Signal());
          }
        });
        b.Events.prototype[a + "$dispatch"] = function () {
          return this[c] ? this[c].dispatch.apply(this[c], arguments) : null;
        };
      })(f, "_" + f);
    }
    b.Component.FixedToCamera = function () {};
    b.Component.FixedToCamera.postUpdate = function () {
      if (this.fixedToCamera) {
        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
      }
    };
    b.Component.FixedToCamera.prototype = {
      _fixedToCamera: false,
      fixedToCamera: {
        get: function () {
          return this._fixedToCamera;
        },
        set: function (a) {
          if (a) {
            this._fixedToCamera = true;
            this.cameraOffset.set(this.x, this.y);
          } else {
            this._fixedToCamera = false;
          }
        }
      },
      cameraOffset: new b.Point()
    };
    b.Component.Health = function () {};
    b.Component.Health.prototype = {
      health: 1,
      maxHealth: 100,
      damage: function (a) {
        if (this.alive) {
          this.health -= a;
          if (this.health <= 0) {
            this.kill();
          }
        }
        return this;
      },
      setHealth: function (a) {
        this.health = a;
        if (this.health > this.maxHealth) {
          this.health = this.maxHealth;
        }
        return this;
      },
      heal: function (a) {
        if (this.alive) {
          this.health += a;
          if (this.health > this.maxHealth) {
            this.health = this.maxHealth;
          }
        }
        return this;
      }
    };
    b.Component.InCamera = function () {};
    b.Component.InCamera.prototype = {
      inCamera: {
        get: function () {
          return this.game.world.camera.view.intersects(this._bounds);
        }
      }
    };
    b.Component.InputEnabled = function () {};
    b.Component.InputEnabled.prototype = {
      input: null,
      inputEnabled: {
        get: function () {
          return this.input && this.input.enabled;
        },
        set: function (a) {
          if (a) {
            if (null === this.input) {
              this.input = new b.InputHandler(this);
              this.input.start();
            } else if (this.input && !this.input.enabled) {
              this.input.start();
            }
          } else if (this.input && this.input.enabled) {
            this.input.stop();
          }
        }
      }
    };
    b.Component.InWorld = function () {};
    b.Component.InWorld.preUpdate = function () {
      if (this.autoCull || this.checkWorldBounds) {
        this._bounds.copyFrom(this.getBounds());
        this._bounds.x += this.game.camera.view.x;
        this._bounds.y += this.game.camera.view.y;
        if (this.autoCull) {
          if (this.game.world.camera.view.intersects(this._bounds)) {
            this.renderable = true;
            this.game.world.camera.totalInView++;
          } else {
            this.renderable = false;
            if (this.outOfCameraBoundsKill) {
              this.kill();
              return false;
            }
          }
        }
        if (this.checkWorldBounds) {
          if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) {
            this._outOfBoundsFired = false;
            this.events.onEnterBounds$dispatch(this);
          } else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = true, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) {
            this.kill();
            return false;
          }
        }
      }
      return true;
    };
    b.Component.InWorld.prototype = {
      checkWorldBounds: false,
      outOfBoundsKill: false,
      outOfCameraBoundsKill: false,
      _outOfBoundsFired: false,
      inWorld: {
        get: function () {
          return this.game.world.bounds.intersects(this.getBounds());
        }
      }
    };
    b.Component.LifeSpan = function () {};
    b.Component.LifeSpan.preUpdate = function () {
      return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), false);
    };
    b.Component.LifeSpan.prototype = {
      alive: true,
      lifespan: 0,
      revive: function (a) {
        if (undefined === a) {
          a = 100;
        }
        this.alive = true;
        this.exists = true;
        this.visible = true;
        if ("function" == typeof this.setHealth) {
          this.setHealth(a);
        }
        if (this.events) {
          this.events.onRevived$dispatch(this);
        }
        return this;
      },
      kill: function () {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
          this.events.onKilled$dispatch(this);
        }
        return this;
      }
    };
    b.Component.LoadTexture = function () {};
    b.Component.LoadTexture.prototype = {
      customRender: false,
      _frame: null,
      loadTexture: function (a, c, d) {
        if (c === b.PENDING_ATLAS) {
          a = c;
          c = 0;
        } else {
          c = c || 0;
        }
        if ((d || undefined === d) && this.animations) {
          this.animations.stop();
        }
        this.key = c;
        this.customRender = false;
        var e = this.game.cache;
        var f = true;
        var g = !this.texture.baseTexture.scaleMode;
        if (b.RenderTexture && c instanceof b.RenderTexture) {
          this.key = c.key;
          this.setTexture(c);
        } else if (b.BitmapData && c instanceof b.BitmapData) {
          this.customRender = true;
          this.setTexture(c.texture);
          f = e.hasFrameData(c.key, b.Cache.BITMAPDATA) ? !this.animations.loadFrameData(e.getFrameData(c.key, b.Cache.BITMAPDATA), c) : !this.animations.loadFrameData(c.frameData, 0);
        } else if (b.Video && c instanceof b.Video) {
          this.customRender = true;
          var h = c.texture.valid;
          this.setTexture(c.texture);
          this.setFrame(c.texture.frame.clone());
          c.onChangeSource.add(this.resizeFrame, this);
          this.texture.valid = h;
        } else if (b.Tilemap && c instanceof b.TilemapLayer) {
          this.setTexture(PIXI.Texture.fromCanvas(c.canvas));
        } else if (c instanceof PIXI.Texture) {
          this.setTexture(c);
        } else {
          var i = e.getImage(c, true);
          this.key = i.key;
          this.setTexture(new PIXI.Texture(i.base));
          this.texture.baseTexture.skipRender = "__default" === c;
          f = !this.animations.loadFrameData(i.frameData, c);
        }
        if (f) {
          this._frame = b.Rectangle.clone(this.texture.frame);
        }
        if (!g) {
          this.texture.baseTexture.scaleMode = 1;
        }
      },
      setFrame: function (a) {
        this._frame = a;
        this.texture.frame.x = a.x;
        this.texture.frame.y = a.y;
        this.texture.frame.width = a.width;
        this.texture.frame.height = a.height;
        this.texture.crop.x = a.x;
        this.texture.crop.y = a.y;
        this.texture.crop.width = a.width;
        this.texture.crop.height = a.height;
        if (a.trimmed) {
          if (this.texture.trim) {
            this.texture.trim.x = a.spriteSourceSizeX;
            this.texture.trim.y = a.spriteSourceSizeY;
            this.texture.trim.width = a.sourceSizeW;
            this.texture.trim.height = a.sourceSizeH;
          } else {
            this.texture.trim = {
              x: a.spriteSourceSizeX,
              y: a.spriteSourceSizeY,
              width: a.sourceSizeW,
              height: a.sourceSizeH
            };
          }
          this.texture.width = a.sourceSizeW;
          this.texture.height = a.sourceSizeH;
          this.texture.frame.width = a.sourceSizeW;
          this.texture.frame.height = a.sourceSizeH;
        } else if (!a.trimmed && this.texture.trim) {
          this.texture.trim = null;
        }
        if (this.cropRect) {
          this.updateCrop();
        }
        this.texture.requiresReTint = true;
        this.texture._updateUvs();
        if (this.tilingTexture) {
          this.refreshTexture = true;
        }
      },
      resizeFrame: function (a, b, c) {
        this.texture.frame.resize(b, c);
        this.texture.setFrame(this.texture.frame);
      },
      resetFrame: function () {
        if (this._frame) {
          this.setFrame(this._frame);
        }
      },
      frame: {
        get: function () {
          return this.animations.frame;
        },
        set: function (a) {
          this.animations.frame = a;
        }
      },
      frameName: {
        get: function () {
          return this.animations.frameName;
        },
        set: function (a) {
          this.animations.frameName = a;
        }
      }
    };
    b.Component.Overlap = function () {};
    b.Component.Overlap.prototype = {
      overlap: function (a) {
        return b.Rectangle.intersects(this.getBounds(), a.getBounds());
      }
    };
    b.Component.PhysicsBody = function () {};
    b.Component.PhysicsBody.preUpdate = function () {
      return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = false, false) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, false));
    };
    b.Component.PhysicsBody.postUpdate = function () {
      if (this.exists && this.body) {
        this.body.postUpdate();
      }
    };
    b.Component.PhysicsBody.prototype = {
      body: null,
      x: {
        get: function () {
          return this.position.x;
        },
        set: function (a) {
          this.position.x = a;
          if (this.body && !this.body.dirty) {
            this.body._reset = true;
          }
        }
      },
      y: {
        get: function () {
          return this.position.y;
        },
        set: function (a) {
          this.position.y = a;
          if (this.body && !this.body.dirty) {
            this.body._reset = true;
          }
        }
      }
    };
    b.Component.Reset = function () {};
    b.Component.Reset.prototype.reset = function (a, b, c) {
      if (undefined === c) {
        c = 1;
      }
      this.world.set(a, b);
      this.position.set(a, b);
      this.fresh = true;
      this.exists = true;
      this.visible = true;
      this.renderable = true;
      if (this.components.InWorld) {
        this._outOfBoundsFired = false;
      }
      if (this.components.LifeSpan) {
        this.alive = true;
        this.health = c;
      }
      if (this.components.PhysicsBody && this.body) {
        this.body.reset(a, b, false, false);
      }
      return this;
    };
    b.Component.ScaleMinMax = function () {};
    b.Component.ScaleMinMax.prototype = {
      transformCallback: null,
      transformCallbackContext: this,
      scaleMin: null,
      scaleMax: null,
      checkTransform: function (a) {
        if (this.scaleMin) {
          if (a.a < this.scaleMin.x) {
            a.a = this.scaleMin.x;
          }
          if (a.d < this.scaleMin.y) {
            a.d = this.scaleMin.y;
          }
        }
        if (this.scaleMax) {
          if (a.a > this.scaleMax.x) {
            a.a = this.scaleMax.x;
          }
          if (a.d > this.scaleMax.y) {
            a.d = this.scaleMax.y;
          }
        }
      },
      setScaleMinMax: function (a, c, d, e) {
        if (undefined === c) {
          c = d = e = a;
        } else if (undefined === d) {
          d = e = c;
          c = a;
        }
        if (null === a) {
          this.scaleMin = null;
        } else if (this.scaleMin) {
          this.scaleMin.set(a, c);
        } else {
          this.scaleMin = new b.Point(a, c);
        }
        if (null === d) {
          this.scaleMax = null;
        } else if (this.scaleMax) {
          this.scaleMax.set(d, e);
        } else {
          this.scaleMax = new b.Point(d, e);
        }
        if (null === this.scaleMin) {
          this.transformCallback = null;
        } else {
          this.transformCallback = this.checkTransform;
          this.transformCallbackContext = this;
        }
      }
    };
    b.Component.Smoothed = function () {};
    b.Component.Smoothed.prototype = {
      smoothed: {
        get: function () {
          return !this.texture.baseTexture.scaleMode;
        },
        set: function (a) {
          if (a) {
            if (this.texture) {
              this.texture.baseTexture.scaleMode = 0;
            }
          } else if (this.texture) {
            this.texture.baseTexture.scaleMode = 1;
          }
        }
      }
    };
    b.GameObjectFactory = function (a) {
      this.game = a;
      this.world = this.game.world;
    };
    b.GameObjectFactory.prototype = {
      existing: function (a) {
        return this.world.add(a);
      },
      weapon: function (a, c, d, e) {
        var f = this.game.plugins.add(b.Weapon);
        f.createBullets(a, c, d, e);
        return f;
      },
      image: function (a, c, d, e, f) {
        if (undefined === f) {
          f = this.world;
        }
        return f.add(new b.Image(this.game, a, c, d, e));
      },
      sprite: function (a, b, c, d, e) {
        if (undefined === e) {
          e = this.world;
        }
        return e.create(a, b, c, d);
      },
      creature: function (a, c, d, e, f) {
        if (undefined === f) {
          f = this.world;
        }
        var g = new b.Creature(this.game, a, c, d, e);
        f.add(g);
        return g;
      },
      tween: function (a) {
        return this.game.tweens.create(a);
      },
      group: function (a, c, d, e, f) {
        return new b.Group(this.game, a, c, d, e, f);
      },
      physicsGroup: function (a, c, d, e) {
        return new b.Group(this.game, c, d, e, true, a);
      },
      spriteBatch: function (a, c, d) {
        if (undefined === a) {
          a = null;
        }
        if (undefined === c) {
          c = "group";
        }
        if (undefined === d) {
          d = false;
        }
        return new b.SpriteBatch(this.game, a, c, d);
      },
      audio: function (a, b, c, d) {
        return this.game.sound.add(a, b, c, d);
      },
      sound: function (a, b, c, d) {
        return this.game.sound.add(a, b, c, d);
      },
      audioSprite: function (a) {
        return this.game.sound.addSprite(a);
      },
      tileSprite: function (a, c, d, e, f, g, h) {
        if (undefined === h) {
          h = this.world;
        }
        return h.add(new b.TileSprite(this.game, a, c, d, e, f, g));
      },
      rope: function (a, c, d, e, f, g) {
        if (undefined === g) {
          g = this.world;
        }
        return g.add(new b.Rope(this.game, a, c, d, e, f));
      },
      text: function (a, c, d, e, f) {
        if (undefined === f) {
          f = this.world;
        }
        return f.add(new b.Text(this.game, a, c, d, e));
      },
      button: function (a, c, d, e, f, g, h, i, j, k) {
        if (undefined === k) {
          k = this.world;
        }
        return k.add(new b.Button(this.game, a, c, d, e, f, g, h, i, j));
      },
      graphics: function (a, c, d) {
        if (undefined === d) {
          d = this.world;
        }
        return d.add(new b.Graphics(this.game, a, c));
      },
      emitter: function (a, c, d) {
        return this.game.particles.add(new b.Particles.Arcade.Emitter(this.game, a, c, d));
      },
      retroFont: function (a, c, d, e, f, g, h, i, j) {
        return new b.RetroFont(this.game, a, c, d, e, f, g, h, i, j);
      },
      bitmapText: function (a, c, d, e, f, g) {
        if (undefined === g) {
          g = this.world;
        }
        return g.add(new b.BitmapText(this.game, a, c, d, e, f));
      },
      tilemap: function (a, c, d, e, f) {
        return new b.Tilemap(this.game, a, c, d, e, f);
      },
      renderTexture: function (a, c, d, e) {
        if (!(undefined !== d && "" !== d)) {
          d = this.game.rnd.uuid();
        }
        if (undefined === e) {
          e = false;
        }
        var f = new b.RenderTexture(this.game, a, c, d);
        if (e) {
          this.game.cache.addRenderTexture(d, f);
        }
        return f;
      },
      video: function (a, c) {
        return new b.Video(this.game, a, c);
      },
      bitmapData: function (a, c, d, e) {
        if (undefined === e) {
          e = false;
        }
        if (!(undefined !== d && "" !== d)) {
          d = this.game.rnd.uuid();
        }
        var f = new b.BitmapData(this.game, d, a, c);
        if (e) {
          this.game.cache.addBitmapData(d, f);
        }
        return f;
      },
      filter: function (a) {
        var c = Array.prototype.slice.call(arguments, 1);
        var a = new b.Filter[a](this.game);
        a.init.apply(a, c);
        return a;
      },
      plugin: function (a) {
        return this.game.plugins.add(a);
      }
    };
    b.GameObjectFactory.prototype.constructor = b.GameObjectFactory;
    b.GameObjectCreator = function (a) {
      this.game = a;
      this.world = this.game.world;
    };
    b.GameObjectCreator.prototype = {
      image: function (a, c, d, e) {
        return new b.Image(this.game, a, c, d, e);
      },
      sprite: function (a, c, d, e) {
        return new b.Sprite(this.game, a, c, d, e);
      },
      tween: function (a) {
        return new b.Tween(a, this.game, this.game.tweens);
      },
      group: function (a, c, d, e, f) {
        return new b.Group(this.game, a, c, d, e, f);
      },
      spriteBatch: function (a, c, d) {
        if (undefined === c) {
          c = "group";
        }
        if (undefined === d) {
          d = false;
        }
        return new b.SpriteBatch(this.game, a, c, d);
      },
      audio: function (a, b, c, d) {
        return this.game.sound.add(a, b, c, d);
      },
      audioSprite: function (a) {
        return this.game.sound.addSprite(a);
      },
      sound: function (a, b, c, d) {
        return this.game.sound.add(a, b, c, d);
      },
      tileSprite: function (a, c, d, e, f, g) {
        return new b.TileSprite(this.game, a, c, d, e, f, g);
      },
      rope: function (a, c, d, e, f) {
        return new b.Rope(this.game, a, c, d, e, f);
      },
      text: function (a, c, d, e) {
        return new b.Text(this.game, a, c, d, e);
      },
      button: function (a, c, d, e, f, g, h, i, j) {
        return new b.Button(this.game, a, c, d, e, f, g, h, i, j);
      },
      graphics: function (a, c) {
        return new b.Graphics(this.game, a, c);
      },
      emitter: function (a, c, d) {
        return new b.Particles.Arcade.Emitter(this.game, a, c, d);
      },
      retroFont: function (a, c, d, e, f, g, h, i, j) {
        return new b.RetroFont(this.game, a, c, d, e, f, g, h, i, j);
      },
      bitmapText: function (a, c, d, e, f, g) {
        return new b.BitmapText(this.game, a, c, d, e, f, g);
      },
      tilemap: function (a, c, d, e, f) {
        return new b.Tilemap(this.game, a, c, d, e, f);
      },
      renderTexture: function (a, c, d, e) {
        if (!(undefined !== d && "" !== d)) {
          d = this.game.rnd.uuid();
        }
        if (undefined === e) {
          e = false;
        }
        var f = new b.RenderTexture(this.game, a, c, d);
        if (e) {
          this.game.cache.addRenderTexture(d, f);
        }
        return f;
      },
      bitmapData: function (a, c, d, e) {
        if (undefined === e) {
          e = false;
        }
        if (!(undefined !== d && "" !== d)) {
          d = this.game.rnd.uuid();
        }
        var f = new b.BitmapData(this.game, d, a, c);
        if (e) {
          this.game.cache.addBitmapData(d, f);
        }
        return f;
      },
      filter: function (a) {
        var c = Array.prototype.slice.call(arguments, 1);
        var a = new b.Filter[a](this.game);
        a.init.apply(a, c);
        return a;
      }
    };
    b.GameObjectCreator.prototype.constructor = b.GameObjectCreator;
    b.Sprite = function (a, c, d, e, f) {
      c = c || 0;
      d = d || 0;
      e = e || null;
      f = f || null;
      this.type = b.SPRITE;
      this.physicsType = b.SPRITE;
      PIXI.Sprite.call(this, b.Cache.DEFAULT);
      b.Component.Core.init.call(this, a, c, d, e, f);
    };
    b.Sprite.prototype = Object.create(PIXI.Sprite.prototype);
    b.Sprite.prototype.constructor = b.Sprite;
    b.Component.Core.install.call(b.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]);
    b.Sprite.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate;
    b.Sprite.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate;
    b.Sprite.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.Sprite.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.Sprite.prototype.preUpdate = function () {
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.Image = function (a, c, d, e, f) {
      c = c || 0;
      d = d || 0;
      e = e || null;
      f = f || null;
      this.type = b.IMAGE;
      PIXI.Sprite.call(this, b.Cache.DEFAULT);
      b.Component.Core.init.call(this, a, c, d, e, f);
    };
    b.Image.prototype = Object.create(PIXI.Sprite.prototype);
    b.Image.prototype.constructor = b.Image;
    b.Component.Core.install.call(b.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]);
    b.Image.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.Image.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.Image.prototype.preUpdate = function () {
      return !!this.preUpdateInWorld() && this.preUpdateCore();
    };
    b.Button = function (a, c, d, e, f, g, h, i, j, k) {
      c = c || 0;
      d = d || 0;
      e = e || null;
      f = f || null;
      g = g || this;
      b.Image.call(this, a, c, d, e, i);
      this.type = b.BUTTON;
      this.physicsType = b.SPRITE;
      this._onOverFrame = null;
      this._onOutFrame = null;
      this._onDownFrame = null;
      this._onUpFrame = null;
      this.onOverSound = null;
      this.onOutSound = null;
      this.onDownSound = null;
      this.onUpSound = null;
      this.onOverSoundMarker = "";
      this.onOutSoundMarker = "";
      this.onDownSoundMarker = "";
      this.onUpSoundMarker = "";
      this.onInputOver = new b.Signal();
      this.onInputOut = new b.Signal();
      this.onInputDown = new b.Signal();
      this.onInputUp = new b.Signal();
      this.onOverMouseOnly = true;
      this.justReleasedPreventsOver = b.PointerMode.TOUCH;
      this.freezeFrames = false;
      this.forceOut = false;
      this.inputEnabled = true;
      this.input.start(0, true);
      this.input.useHandCursor = true;
      this.setFrames(h, i, j, k);
      if (null !== f) {
        this.onInputUp.add(f, g);
      }
      this.events.onInputOver.add(this.onInputOverHandler, this);
      this.events.onInputOut.add(this.onInputOutHandler, this);
      this.events.onInputDown.add(this.onInputDownHandler, this);
      this.events.onInputUp.add(this.onInputUpHandler, this);
      this.events.onRemovedFromWorld.add(this.removedFromWorld, this);
    };
    b.Button.prototype = Object.create(b.Image.prototype);
    b.Button.prototype.constructor = b.Button;
    b.Button.prototype.clearFrames = function () {
      this.setFrames(null, null, null, null);
    };
    b.Button.prototype.removedFromWorld = function () {
      this.inputEnabled = false;
    };
    b.Button.prototype.setStateFrame = function (a, b, c) {
      var d = "_on" + a + "Frame";
      if (null !== b) {
        this[d] = b;
        if (c) {
          this.changeStateFrame(a);
        }
      } else {
        this[d] = null;
      }
    };
    b.Button.prototype.changeStateFrame = function (a) {
      if (this.freezeFrames) {
        return false;
      }
      var b = "_on" + a + "Frame";
      var c = this[b];
      return "string" == typeof c ? (this.frameName = c, true) : "number" == typeof c && (this.frame = c, true);
    };
    b.Button.prototype.setFrames = function (a, b, c, d) {
      this.setStateFrame("Over", a, this.input.pointerOver());
      this.setStateFrame("Out", b, !this.input.pointerOver());
      this.setStateFrame("Down", c, this.input.pointerDown());
      this.setStateFrame("Up", d, this.input.pointerUp());
    };
    b.Button.prototype.setStateSound = function (a, c, d) {
      var e = "on" + a + "Sound";
      var f = "on" + a + "SoundMarker";
      if (c instanceof b.Sound || c instanceof b.AudioSprite) {
        this[e] = c;
        this[f] = "string" == typeof d ? d : "";
      } else {
        this[e] = null;
        this[f] = "";
      }
    };
    b.Button.prototype.playStateSound = function (a) {
      var b = "on" + a + "Sound";
      var c = this[b];
      if (c) {
        var d = "on" + a + "SoundMarker";
        var e = this[d];
        c.play(e);
        return true;
      }
      return false;
    };
    b.Button.prototype.setSounds = function (a, b, c, d, e, f, k, l) {
      this.setStateSound("Over", a, b);
      this.setStateSound("Out", e, f);
      this.setStateSound("Down", c, d);
      this.setStateSound("Up", k, l);
    };
    b.Button.prototype.setOverSound = function (a, b) {
      this.setStateSound("Over", a, b);
    };
    b.Button.prototype.setOutSound = function (a, b) {
      this.setStateSound("Out", a, b);
    };
    b.Button.prototype.setDownSound = function (a, b) {
      this.setStateSound("Down", a, b);
    };
    b.Button.prototype.setUpSound = function (a, b) {
      this.setStateSound("Up", a, b);
    };
    b.Button.prototype.onInputOverHandler = function (a, b) {
      if (!(b.justReleased() && (this.justReleasedPreventsOver & b.pointerMode) === b.pointerMode)) {
        this.changeStateFrame("Over");
        if (!(this.onOverMouseOnly && !b.isMouse)) {
          this.playStateSound("Over");
          if (this.onInputOver) {
            this.onInputOver.dispatch(this, b);
          }
        }
      }
    };
    b.Button.prototype.onInputOutHandler = function (a, b) {
      this.changeStateFrame("Out");
      this.playStateSound("Out");
      if (this.onInputOut) {
        this.onInputOut.dispatch(this, b);
      }
    };
    b.Button.prototype.onInputDownHandler = function (a, b) {
      this.changeStateFrame("Down");
      this.playStateSound("Down");
      if (this.onInputDown) {
        this.onInputDown.dispatch(this, b);
      }
    };
    b.Button.prototype.onInputUpHandler = function (a, b, c) {
      this.playStateSound("Up");
      if (this.onInputUp) {
        this.onInputUp.dispatch(this, b, c);
      }
      if (!this.freezeFrames) {
        if (true === this.forceOut || (this.forceOut & b.pointerMode) === b.pointerMode) {
          this.changeStateFrame("Out");
        } else {
          var d = this.changeStateFrame("Up");
          if (!d) {
            if (c) {
              this.changeStateFrame("Over");
            } else {
              this.changeStateFrame("Out");
            }
          }
        }
      }
    };
    b.SpriteBatch = function (a, c, d, e) {
      if (!(undefined !== c && null !== c)) {
        c = a.world;
      }
      PIXI.SpriteBatch.call(this);
      b.Group.call(this, a, c, d, e);
      this.type = b.SPRITEBATCH;
    };
    b.SpriteBatch.prototype = b.Utils.extend(true, b.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, b.Group.prototype);
    b.SpriteBatch.prototype.constructor = b.SpriteBatch;
    b.BitmapData = function (a, c, d, e, f) {
      if (!(undefined !== d && 0 !== d)) {
        d = 256;
      }
      if (!(undefined !== e && 0 !== e)) {
        e = 256;
      }
      if (undefined === f) {
        f = false;
      }
      this.game = a;
      this.key = c;
      this.width = d;
      this.height = e;
      this.canvas = b.Canvas.create(this, d, e, null, f);
      this.context = this.canvas.getContext("2d", {
        alpha: true
      });
      this.ctx = this.context;
      this.smoothProperty = a.renderType === b.CANVAS ? a.renderer.renderSession.smoothProperty : b.Canvas.getSmoothingPrefix(this.context);
      this.imageData = this.context.getImageData(0, 0, d, e);
      this.data = null;
      if (this.imageData) {
        this.data = this.imageData.data;
      }
      this.pixels = null;
      if (this.data) {
        if (this.imageData.data.buffer) {
          this.buffer = this.imageData.data.buffer;
          this.pixels = new Uint32Array(this.buffer);
        } else if (window.ArrayBuffer) {
          this.buffer = new ArrayBuffer(this.imageData.data.length);
          this.pixels = new Uint32Array(this.buffer);
        } else {
          this.pixels = this.imageData.data;
        }
      }
      this.baseTexture = new PIXI.BaseTexture(this.canvas);
      this.texture = new PIXI.Texture(this.baseTexture);
      this.frameData = new b.FrameData();
      this.textureFrame = this.frameData.addFrame(new b.Frame(0, 0, 0, d, e, "bitmapData"));
      this.texture.frame = this.textureFrame;
      this.type = b.BITMAPDATA;
      this.disableTextureUpload = false;
      this.dirty = false;
      this.cls = this.clear;
      this._image = null;
      this._pos = new b.Point();
      this._size = new b.Point();
      this._scale = new b.Point();
      this._rotate = 0;
      this._alpha = {
        prev: 1,
        current: 1
      };
      this._anchor = new b.Point();
      this._tempR = 0;
      this._tempG = 0;
      this._tempB = 0;
      this._circle = new b.Circle();
      this._swapCanvas = undefined;
    };
    b.BitmapData.prototype = {
      move: function (a, b, c) {
        if (0 !== a) {
          this.moveH(a, c);
        }
        if (0 !== b) {
          this.moveV(b, c);
        }
        return this;
      },
      moveH: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === this._swapCanvas) {
          this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height);
        }
        var c = this._swapCanvas;
        var d = c.getContext("2d");
        var e = this.height;
        var f = this.canvas;
        d.clearRect(0, 0, this.width, this.height);
        if (a < 0) {
          a = Math.abs(a);
          var g = this.width - a;
          if (b) {
            d.drawImage(f, 0, 0, a, e, g, 0, a, e);
          }
          d.drawImage(f, a, 0, g, e, 0, 0, g, e);
        } else {
          var g = this.width - a;
          if (b) {
            d.drawImage(f, g, 0, a, e, 0, 0, a, e);
          }
          d.drawImage(f, 0, 0, g, e, a, 0, g, e);
        }
        this.clear();
        return this.copy(this._swapCanvas);
      },
      moveV: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === this._swapCanvas) {
          this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height);
        }
        var c = this._swapCanvas;
        var d = c.getContext("2d");
        var e = this.width;
        var f = this.canvas;
        d.clearRect(0, 0, this.width, this.height);
        if (a < 0) {
          a = Math.abs(a);
          var g = this.height - a;
          if (b) {
            d.drawImage(f, 0, 0, e, a, 0, g, e, a);
          }
          d.drawImage(f, 0, a, e, g, 0, 0, e, g);
        } else {
          var g = this.height - a;
          if (b) {
            d.drawImage(f, 0, g, e, a, 0, 0, e, a);
          }
          d.drawImage(f, 0, 0, e, g, 0, a, e, g);
        }
        this.clear();
        return this.copy(this._swapCanvas);
      },
      add: function (a) {
        if (Array.isArray(a)) {
          for (var b = 0; b < a.length; b++) {
            if (a[b].loadTexture) {
              a[b].loadTexture(this);
            }
          }
        } else {
          a.loadTexture(this);
        }
        return this;
      },
      load: function (a) {
        if ("string" == typeof a) {
          a = this.game.cache.getImage(a);
        }
        if (a) {
          this.resize(a.width, a.height);
          this.cls();
          this.draw(a);
          this.update();
          return this;
        }
      },
      clear: function (a, b, c, d) {
        if (undefined === a) {
          a = 0;
        }
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = this.width;
        }
        if (undefined === d) {
          d = this.height;
        }
        this.context.clearRect(a, b, c, d);
        this.dirty = true;
        return this;
      },
      fill: function (a, b, c, d) {
        if (undefined === d) {
          d = 1;
        }
        this.context.fillStyle = "rgba(" + a + "," + b + "," + c + "," + d + ")";
        this.context.fillRect(0, 0, this.width, this.height);
        this.dirty = true;
        return this;
      },
      generateTexture: function (a) {
        var b = new Image();
        b.src = this.canvas.toDataURL("image/png");
        var c = this.game.cache.addImage(a, "", b);
        return new PIXI.Texture(c.base);
      },
      resize: function (a, b) {
        if (!(a === this.width && b === this.height)) {
          this.width = a;
          this.height = b;
          this.canvas.width = a;
          this.canvas.height = b;
          if (undefined !== this._swapCanvas) {
            this._swapCanvas.width = a;
            this._swapCanvas.height = b;
          }
          this.baseTexture.width = a;
          this.baseTexture.height = b;
          this.textureFrame.width = a;
          this.textureFrame.height = b;
          this.texture.width = a;
          this.texture.height = b;
          this.texture.crop.width = a;
          this.texture.crop.height = b;
          this.update();
          this.dirty = true;
        }
        return this;
      },
      update: function (a, b, c, d) {
        if (undefined === a) {
          a = 0;
        }
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = Math.max(1, this.width);
        }
        if (undefined === d) {
          d = Math.max(1, this.height);
        }
        this.imageData = this.context.getImageData(a, b, c, d);
        this.data = this.imageData.data;
        if (this.imageData.data.buffer) {
          this.buffer = this.imageData.data.buffer;
          this.pixels = new Uint32Array(this.buffer);
        } else if (window.ArrayBuffer) {
          this.buffer = new ArrayBuffer(this.imageData.data.length);
          this.pixels = new Uint32Array(this.buffer);
        } else {
          this.pixels = this.imageData.data;
        }
        return this;
      },
      processPixelRGB: function (a, c, d, e, f, g) {
        if (undefined === d) {
          d = 0;
        }
        if (undefined === e) {
          e = 0;
        }
        if (undefined === f) {
          f = this.width;
        }
        if (undefined === g) {
          g = this.height;
        }
        var h = d + f;
        var i = e + g;
        var j = b.Color.createColor();
        var k = {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        };
        var l = false;
        for (var m = e; m < i; m++) {
          for (var n = d; n < h; n++) {
            b.Color.unpackPixel(this.getPixel32(n, m), j);
            if (false !== (k = a.call(c, j, n, m)) && null !== k && undefined !== k) {
              this.setPixel32(n, m, k.r, k.g, k.b, k.a, false);
              l = true;
            }
          }
        }
        if (l) {
          this.context.putImageData(this.imageData, 0, 0);
          this.dirty = true;
        }
        return this;
      },
      processPixel: function (a, b, c, d, e, f) {
        if (undefined === c) {
          c = 0;
        }
        if (undefined === d) {
          d = 0;
        }
        if (undefined === e) {
          e = this.width;
        }
        if (undefined === f) {
          f = this.height;
        }
        var g = c + e;
        var h = d + f;
        var i = 0;
        var j = 0;
        var k = false;
        for (var l = d; l < h; l++) {
          for (var m = c; m < g; m++) {
            i = this.getPixel32(m, l);
            if ((j = a.call(b, i, m, l)) !== i) {
              this.pixels[l * this.width + m] = j;
              k = true;
            }
          }
        }
        if (k) {
          this.context.putImageData(this.imageData, 0, 0);
          this.dirty = true;
        }
        return this;
      },
      replaceRGB: function (a, c, d, e, f, g, h, i, j) {
        var k = 0;
        var l = 0;
        var m = this.width;
        var n = this.height;
        var o = b.Color.packPixel(a, c, d, e);
        if (undefined !== j && j instanceof b.Rectangle) {
          k = j.x;
          l = j.y;
          m = j.width;
          n = j.height;
        }
        for (var p = 0; p < n; p++) {
          for (var q = 0; q < m; q++) {
            if (this.getPixel32(k + q, l + p) === o) {
              this.setPixel32(k + q, l + p, f, g, h, i, false);
            }
          }
        }
        this.context.putImageData(this.imageData, 0, 0);
        this.dirty = true;
        return this;
      },
      setHSL: function (a, c, d, e) {
        var f = a || 0 === a;
        var g = c || 0 === c;
        var h = d || 0 === d;
        if (f || g || h) {
          if (undefined === e) {
            e = new b.Rectangle(0, 0, this.width, this.height);
          }
          var i = b.Color.createColor();
          for (var j = e.y; j < e.bottom; j++) {
            for (var k = e.x; k < e.right; k++) {
              b.Color.unpackPixel(this.getPixel32(k, j), i, true);
              if (f) {
                i.h = a;
              }
              if (g) {
                i.s = c;
              }
              if (h) {
                i.l = d;
              }
              b.Color.HSLtoRGB(i.h, i.s, i.l, i);
              this.setPixel32(k, j, i.r, i.g, i.b, i.a, false);
            }
          }
          this.context.putImageData(this.imageData, 0, 0);
          this.dirty = true;
          return this;
        }
      },
      shiftHSL: function (a, c, d, e) {
        if (!(undefined !== a && null !== a)) {
          a = false;
        }
        if (!(undefined !== c && null !== c)) {
          c = false;
        }
        if (!(undefined !== d && null !== d)) {
          d = false;
        }
        if (a || c || d) {
          if (undefined === e) {
            e = new b.Rectangle(0, 0, this.width, this.height);
          }
          var f = b.Color.createColor();
          for (var g = e.y; g < e.bottom; g++) {
            for (var h = e.x; h < e.right; h++) {
              b.Color.unpackPixel(this.getPixel32(h, g), f, true);
              if (a) {
                f.h = this.game.math.wrap(f.h + a, 0, 1);
              }
              if (c) {
                f.s = this.game.math.clamp(f.s + c, 0, 1);
              }
              if (d) {
                f.l = this.game.math.clamp(f.l + d, 0, 1);
              }
              b.Color.HSLtoRGB(f.h, f.s, f.l, f);
              this.setPixel32(h, g, f.r, f.g, f.b, f.a, false);
            }
          }
          this.context.putImageData(this.imageData, 0, 0);
          this.dirty = true;
          return this;
        }
      },
      setPixel32: function (a, c, d, e, f, g, h) {
        if (undefined === h) {
          h = true;
        }
        if (a >= 0 && a <= this.width && c >= 0 && c <= this.height) {
          if (b.Device.LITTLE_ENDIAN) {
            this.pixels[c * this.width + a] = g << 24 | f << 16 | e << 8 | d;
          } else {
            this.pixels[c * this.width + a] = d << 24 | e << 16 | f << 8 | g;
          }
          if (h) {
            this.context.putImageData(this.imageData, 0, 0);
            this.dirty = true;
          }
        }
        return this;
      },
      setPixel: function (a, b, c, d, e, f) {
        return this.setPixel32(a, b, c, d, e, 255, f);
      },
      getPixel: function (a, c, d) {
        if (!d) {
          d = b.Color.createColor();
        }
        var e = ~~(a + c * this.width);
        e *= 4;
        d.r = this.data[e];
        d.g = this.data[++e];
        d.b = this.data[++e];
        d.a = this.data[++e];
        return d;
      },
      getPixel32: function (a, b) {
        if (a >= 0 && a <= this.width && b >= 0 && b <= this.height) {
          return this.pixels[b * this.width + a];
        }
      },
      getPixelRGB: function (a, c, d, e, f) {
        return b.Color.unpackPixel(this.getPixel32(a, c), d, e, f);
      },
      getPixels: function (a) {
        return this.context.getImageData(a.x, a.y, a.width, a.height);
      },
      getFirstPixel: function (a) {
        if (undefined === a) {
          a = 0;
        }
        var c = b.Color.createColor();
        var d = 0;
        var e = 0;
        var f = 1;
        var g = false;
        if (1 === a) {
          f = -1;
          e = this.height;
        } else if (3 === a) {
          f = -1;
          d = this.width;
        }
        do {
          b.Color.unpackPixel(this.getPixel32(d, e), c);
          if (0 === a || 1 === a) {
            if (++d === this.width) {
              d = 0;
              if ((e += f) >= this.height || e <= 0) {
                g = true;
              }
            }
          } else if (!(2 !== a && 3 !== a)) {
            if (++e === this.height) {
              e = 0;
              if ((d += f) >= this.width || d <= 0) {
                g = true;
              }
            }
          }
        } while (0 === c.a && !g);
        c.x = d;
        c.y = e;
        return c;
      },
      getBounds: function (a) {
        if (undefined === a) {
          a = new b.Rectangle();
        }
        a.x = this.getFirstPixel(2).x;
        return a.x === this.width ? a.setTo(0, 0, 0, 0) : (a.y = this.getFirstPixel(0).y, a.width = this.getFirstPixel(3).x - a.x + 1, a.height = this.getFirstPixel(1).y - a.y + 1, a);
      },
      addToWorld: function (a, b, c, d, e, f) {
        e = e || 1;
        f = f || 1;
        var g = this.game.add.image(a, b, this);
        g.anchor.set(c, d);
        g.scale.set(e, f);
        return g;
      },
      copy: function (a, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
        if (!(undefined !== a && null !== a)) {
          a = this;
        }
        if (a instanceof b.RenderTexture || a instanceof PIXI.RenderTexture) {
          a = a.getCanvas();
        }
        this._image = a;
        if (a instanceof b.Sprite || a instanceof b.Image || a instanceof b.Text || a instanceof PIXI.Sprite) {
          this._pos.set(a.texture.crop.x, a.texture.crop.y);
          this._size.set(a.texture.crop.width, a.texture.crop.height);
          this._scale.set(a.scale.x, a.scale.y);
          this._anchor.set(a.anchor.x, a.anchor.y);
          this._rotate = a.rotation;
          this._alpha.current = a.alpha;
          if (a.texture instanceof b.RenderTexture || a.texture instanceof PIXI.RenderTexture) {
            this._image = a.texture.getCanvas();
          } else {
            this._image = a.texture.baseTexture.source;
          }
          if (!(undefined !== g && null !== g)) {
            g = a.x;
          }
          if (!(undefined !== h && null !== h)) {
            h = a.y;
          }
          if (a.texture.trim) {
            g += a.texture.trim.x - a.anchor.x * a.texture.trim.width;
            h += a.texture.trim.y - a.anchor.y * a.texture.trim.height;
          }
          if (16777215 !== a.tint) {
            if (a.cachedTint !== a.tint) {
              a.cachedTint = a.tint;
              a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint);
            }
            this._image = a.tintedTexture;
            this._pos.set(0);
          }
        } else {
          this._pos.set(0);
          this._scale.set(1);
          this._anchor.set(0);
          this._rotate = 0;
          this._alpha.current = 1;
          if (a instanceof b.BitmapData) {
            this._image = a.canvas;
          } else if ("string" == typeof a) {
            if (null === (a = this.game.cache.getImage(a))) {
              return;
            }
            this._image = a;
          }
          this._size.set(this._image.width, this._image.height);
        }
        if (!(undefined !== c && null !== c)) {
          c = 0;
        }
        if (!(undefined !== d && null !== d)) {
          d = 0;
        }
        if (e) {
          this._size.x = e;
        }
        if (f) {
          this._size.y = f;
        }
        if (!(undefined !== g && null !== g)) {
          g = c;
        }
        if (!(undefined !== h && null !== h)) {
          h = d;
        }
        if (!(undefined !== i && null !== i)) {
          i = this._size.x;
        }
        if (!(undefined !== j && null !== j)) {
          j = this._size.y;
        }
        if ("number" == typeof k) {
          this._rotate = k;
        }
        if ("number" == typeof l) {
          this._anchor.x = l;
        }
        if ("number" == typeof m) {
          this._anchor.y = m;
        }
        if ("number" == typeof n) {
          this._scale.x = n;
        }
        if ("number" == typeof o) {
          this._scale.y = o;
        }
        if ("number" == typeof p) {
          this._alpha.current = p;
        }
        if (undefined === q) {
          q = null;
        }
        if (undefined === r) {
          r = false;
        }
        if (!(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
          var s = this.context;
          this._alpha.prev = s.globalAlpha;
          s.save();
          s.globalAlpha = this._alpha.current;
          if (q) {
            this.op = q;
          }
          if (r) {
            g |= 0;
            h |= 0;
          }
          s.translate(g, h);
          s.scale(this._scale.x, this._scale.y);
          s.rotate(this._rotate);
          s.drawImage(this._image, this._pos.x + c, this._pos.y + d, this._size.x, this._size.y, -i * this._anchor.x, -j * this._anchor.y, i, j);
          s.restore();
          s.globalAlpha = this._alpha.prev;
          this.dirty = true;
          return this;
        }
      },
      copyTransform: function (a, c, d) {
        if (undefined === c) {
          c = null;
        }
        if (undefined === d) {
          d = false;
        }
        if (!a.hasOwnProperty("worldTransform") || !a.worldVisible || 0 === a.worldAlpha) {
          return this;
        }
        var e = a.worldTransform;
        this._pos.set(a.texture.crop.x, a.texture.crop.y);
        this._size.set(a.texture.crop.width, a.texture.crop.height);
        if (0 === e.a || 0 === e.d || 0 === this._size.x || 0 === this._size.y) {
          return this;
        }
        if (a.texture instanceof b.RenderTexture || a.texture instanceof PIXI.RenderTexture) {
          this._image = a.texture.getCanvas();
        } else {
          this._image = a.texture.baseTexture.source;
        }
        var f = e.tx;
        var g = e.ty;
        if (a.texture.trim) {
          f += a.texture.trim.x - a.anchor.x * a.texture.trim.width;
          g += a.texture.trim.y - a.anchor.y * a.texture.trim.height;
        }
        if (16777215 !== a.tint) {
          if (a.cachedTint !== a.tint) {
            a.cachedTint = a.tint;
            a.tintedTexture = PIXI.CanvasTinter.getTintedTexture(a, a.tint);
          }
          this._image = a.tintedTexture;
          this._pos.set(0);
        }
        if (d) {
          f |= 0;
          g |= 0;
        }
        var h = this.context;
        this._alpha.prev = h.globalAlpha;
        h.save();
        h.globalAlpha = this._alpha.current;
        if (c) {
          this.op = c;
        }
        h[this.smoothProperty] = a.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR;
        h.setTransform(e.a, e.b, e.c, e.d, f, g);
        h.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * a.anchor.x, -this._size.y * a.anchor.y, this._size.x, this._size.y);
        h.restore();
        h.globalAlpha = this._alpha.prev;
        this.dirty = true;
        return this;
      },
      copyRect: function (a, b, c, d, e, f, g) {
        return this.copy(a, b.x, b.y, b.width, b.height, c, d, b.width, b.height, 0, 0, 0, 1, 1, e, f, g);
      },
      draw: function (a, b, c, d, e, f, g) {
        return this.copy(a, null, null, null, null, b, c, d, e, null, null, null, null, null, null, f, g);
      },
      drawGroup: function (a, b, c) {
        if (a.total > 0) {
          a.forEachExists(this.drawGroupProxy, this, b, c);
        }
        return this;
      },
      drawGroupProxy: function (a, c, d) {
        if (a.hasOwnProperty("texture")) {
          this.copyTransform(a, c, d);
        }
        if (a.type === b.GROUP && a.exists) {
          this.drawGroup(a, c, d);
        } else if (a.hasOwnProperty("children") && a.children.length > 0) {
          for (var e = 0; e < a.children.length; e++) {
            if (a.children[e].exists) {
              this.copyTransform(a.children[e], c, d);
            }
          }
        }
      },
      drawFull: function (a, c, d) {
        if (false === a.worldVisible || 0 === a.worldAlpha || a.hasOwnProperty("exists") && false === a.exists) {
          return this;
        }
        if (a.type !== b.GROUP && a.type !== b.EMITTER && a.type !== b.BITMAPTEXT) {
          if (a.type === b.GRAPHICS) {
            var e = a.getBounds();
            this.ctx.save();
            this.ctx.translate(e.x, e.y);
            PIXI.CanvasGraphics.renderGraphics(a, this.ctx);
            this.ctx.restore();
          } else {
            this.copy(a, null, null, null, null, a.worldPosition.x, a.worldPosition.y, null, null, a.worldRotation, null, null, a.worldScale.x, a.worldScale.y, a.worldAlpha, c, d);
          }
        }
        if (a.children) {
          for (var f = 0; f < a.children.length; f++) {
            this.drawFull(a.children[f], c, d);
          }
        }
        return this;
      },
      shadow: function (a, b, c, d) {
        var e = this.context;
        if (undefined === a || null === a) {
          e.shadowColor = "rgba(0,0,0,0)";
        } else {
          e.shadowColor = a;
          e.shadowBlur = b || 5;
          e.shadowOffsetX = c || 10;
          e.shadowOffsetY = d || 10;
        }
        return this;
      },
      alphaMask: function (a, b, c, d) {
        if (undefined === d || null === d) {
          this.draw(b).blendSourceAtop();
        } else {
          this.draw(b, d.x, d.y, d.width, d.height).blendSourceAtop();
        }
        if (undefined === c || null === c) {
          this.draw(a).blendReset();
        } else {
          this.draw(a, c.x, c.y, c.width, c.height).blendReset();
        }
        return this;
      },
      extract: function (a, b, c, d, e, f, g, h, i) {
        if (undefined === e) {
          e = 255;
        }
        if (undefined === f) {
          f = false;
        }
        if (undefined === b) {
          g = b;
        }
        if (undefined === c) {
          h = c;
        }
        if (undefined === d) {
          i = d;
        }
        if (f) {
          a.resize(this.width, this.height);
        }
        this.processPixelRGB(function (f, j, k) {
          if (f.r === b && f.g === c && f.b === d) {
            a.setPixel32(j, k, b, c, d, e, false);
          }
          return false;
        }, this);
        a.context.putImageData(a.imageData, 0, 0);
        a.dirty = true;
        return a;
      },
      rect: function (a, b, c, d, e) {
        if (undefined !== e) {
          this.context.fillStyle = e;
        }
        this.context.fillRect(a, b, c, d);
        return this;
      },
      text: function (a, b, c, d, e, f) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = 0;
        }
        if (undefined === d) {
          d = "14px Courier";
        }
        if (undefined === e) {
          e = "rgb(255,255,255)";
        }
        if (undefined === f) {
          f = true;
        }
        var g = this.context;
        var h = g.font;
        g.font = d;
        if (f) {
          g.fillStyle = "rgb(0,0,0)";
          g.fillText(a, b + 1, c + 1);
        }
        g.fillStyle = e;
        g.fillText(a, b, c);
        g.font = h;
        return this;
      },
      circle: function (a, b, c, d) {
        var e = this.context;
        if (undefined !== d) {
          e.fillStyle = d;
        }
        e.beginPath();
        e.arc(a, b, c, 0, 2 * Math.PI, false);
        e.closePath();
        e.fill();
        return this;
      },
      line: function (a, b, c, d, e, f) {
        if (undefined === e) {
          e = "#fff";
        }
        if (undefined === f) {
          f = 1;
        }
        var g = this.context;
        g.beginPath();
        g.moveTo(a, b);
        g.lineTo(c, d);
        g.lineWidth = f;
        g.strokeStyle = e;
        g.stroke();
        g.closePath();
        return this;
      },
      textureLine: function (a, c, d) {
        if (undefined === d) {
          d = "repeat-x";
        }
        if ("string" != typeof c || (c = this.game.cache.getImage(c))) {
          var e = a.length;
          if ("no-repeat" === d && e > c.width) {
            e = c.width;
          }
          var f = this.context;
          f.fillStyle = f.createPattern(c, d);
          this._circle = new b.Circle(a.start.x, a.start.y, c.height);
          this._circle.circumferencePoint(a.angle - 1.5707963267948966, false, this._pos);
          f.save();
          f.translate(this._pos.x, this._pos.y);
          f.rotate(a.angle);
          f.fillRect(0, 0, e, c.height);
          f.restore();
          this.dirty = true;
          return this;
        }
      },
      render: function () {
        if (!this.disableTextureUpload && this.dirty) {
          this.baseTexture.dirty();
          this.dirty = false;
        }
        return this;
      },
      destroy: function () {
        this.frameData.destroy();
        this.texture.destroy(true);
        PIXI.CanvasPool.remove(this);
      },
      blendReset: function () {
        this.op = "source-over";
        return this;
      },
      blendSourceOver: function () {
        this.op = "source-over";
        return this;
      },
      blendSourceIn: function () {
        this.op = "source-in";
        return this;
      },
      blendSourceOut: function () {
        this.op = "source-out";
        return this;
      },
      blendSourceAtop: function () {
        this.op = "source-atop";
        return this;
      },
      blendDestinationOver: function () {
        this.op = "destination-over";
        return this;
      },
      blendDestinationIn: function () {
        this.op = "destination-in";
        return this;
      },
      blendDestinationOut: function () {
        this.op = "destination-out";
        return this;
      },
      blendDestinationAtop: function () {
        this.op = "destination-atop";
        return this;
      },
      blendXor: function () {
        this.op = "xor";
        return this;
      },
      blendAdd: function () {
        this.op = "lighter";
        return this;
      },
      blendMultiply: function () {
        this.op = "multiply";
        return this;
      },
      blendScreen: function () {
        this.op = "screen";
        return this;
      },
      blendOverlay: function () {
        this.op = "overlay";
        return this;
      },
      blendDarken: function () {
        this.op = "darken";
        return this;
      },
      blendLighten: function () {
        this.op = "lighten";
        return this;
      },
      blendColorDodge: function () {
        this.op = "color-dodge";
        return this;
      },
      blendColorBurn: function () {
        this.op = "color-burn";
        return this;
      },
      blendHardLight: function () {
        this.op = "hard-light";
        return this;
      },
      blendSoftLight: function () {
        this.op = "soft-light";
        return this;
      },
      blendDifference: function () {
        this.op = "difference";
        return this;
      },
      blendExclusion: function () {
        this.op = "exclusion";
        return this;
      },
      blendHue: function () {
        this.op = "hue";
        return this;
      },
      blendSaturation: function () {
        this.op = "saturation";
        return this;
      },
      blendColor: function () {
        this.op = "color";
        return this;
      },
      blendLuminosity: function () {
        this.op = "luminosity";
        return this;
      }
    };
    Object.defineProperty(b.BitmapData.prototype, "smoothed", {
      get: function () {
        b.Canvas.getSmoothingEnabled(this.context);
      },
      set: function (a) {
        b.Canvas.setSmoothingEnabled(this.context, a);
      }
    });
    Object.defineProperty(b.BitmapData.prototype, "op", {
      get: function () {
        return this.context.globalCompositeOperation;
      },
      set: function (a) {
        this.context.globalCompositeOperation = a;
      }
    });
    b.BitmapData.getTransform = function (a, b, c, d, e, f) {
      if ("number" != typeof a) {
        a = 0;
      }
      if ("number" != typeof b) {
        b = 0;
      }
      if ("number" != typeof c) {
        c = 1;
      }
      if ("number" != typeof d) {
        d = 1;
      }
      if ("number" != typeof e) {
        e = 0;
      }
      if ("number" != typeof f) {
        f = 0;
      }
      return {
        sx: c,
        sy: d,
        scaleX: c,
        scaleY: d,
        skewX: e,
        skewY: f,
        translateX: a,
        translateY: b,
        tx: a,
        ty: b
      };
    };
    b.BitmapData.prototype.constructor = b.BitmapData;
    PIXI.Graphics = function () {
      PIXI.DisplayObjectContainer.call(this);
      this.renderable = true;
      this.fillAlpha = 1;
      this.lineWidth = 0;
      this.lineColor = 0;
      this.graphicsData = [];
      this.tint = 16777215;
      this.blendMode = PIXI.blendModes.NORMAL;
      this.currentPath = null;
      this._webGL = [];
      this.isMask = false;
      this.boundsPadding = 0;
      this._localBounds = new PIXI.Rectangle(0, 0, 1, 1);
      this.dirty = true;
      this._boundsDirty = false;
      this.webGLDirty = false;
      this.cachedSpriteDirty = false;
    };
    PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    PIXI.Graphics.prototype.constructor = PIXI.Graphics;
    PIXI.Graphics.prototype.lineStyle = function (a, b, c) {
      this.lineWidth = a || 0;
      this.lineColor = b || 0;
      this.lineAlpha = undefined === c ? 1 : c;
      if (this.currentPath) {
        if (this.currentPath.shape.points.length) {
          this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2)));
        } else {
          this.currentPath.lineWidth = this.lineWidth;
          this.currentPath.lineColor = this.lineColor;
          this.currentPath.lineAlpha = this.lineAlpha;
        }
      }
      return this;
    };
    PIXI.Graphics.prototype.moveTo = function (a, b) {
      this.drawShape(new PIXI.Polygon([a, b]));
      return this;
    };
    PIXI.Graphics.prototype.lineTo = function (a, b) {
      if (!this.currentPath) {
        this.moveTo(0, 0);
      }
      this.currentPath.shape.points.push(a, b);
      this.dirty = true;
      this._boundsDirty = true;
      return this;
    };
    PIXI.Graphics.prototype.quadraticCurveTo = function (a, b, c, d) {
      if (this.currentPath) {
        if (0 === this.currentPath.shape.points.length) {
          this.currentPath.shape.points = [0, 0];
        }
      } else {
        this.moveTo(0, 0);
      }
      var e;
      var f;
      var h = this.currentPath.shape.points;
      if (0 === h.length) {
        this.moveTo(0, 0);
      }
      var i = h[h.length - 2];
      var j = h[h.length - 1];
      var k = 0;
      for (var l = 1; l <= 20; ++l) {
        k = l / 20;
        e = i + (a - i) * k;
        f = j + (b - j) * k;
        h.push(e + (a + (c - a) * k - e) * k, f + (b + (d - b) * k - f) * k);
      }
      this.dirty = true;
      this._boundsDirty = true;
      return this;
    };
    PIXI.Graphics.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
      if (this.currentPath) {
        if (0 === this.currentPath.shape.points.length) {
          this.currentPath.shape.points = [0, 0];
        }
      } else {
        this.moveTo(0, 0);
      }
      var h;
      var i;
      var j;
      var k;
      var l;
      var m = this.currentPath.shape.points;
      var n = m[m.length - 2];
      var o = m[m.length - 1];
      var p = 0;
      for (var q = 1; q <= 20; ++q) {
        p = q / 20;
        h = 1 - p;
        i = h * h;
        j = i * h;
        k = p * p;
        l = k * p;
        m.push(j * n + 3 * i * p * a + 3 * h * k * c + l * e, j * o + 3 * i * p * b + 3 * h * k * d + l * f);
      }
      this.dirty = true;
      this._boundsDirty = true;
      return this;
    };
    PIXI.Graphics.prototype.arcTo = function (a, b, c, d, e) {
      if (this.currentPath) {
        if (0 === this.currentPath.shape.points.length) {
          this.currentPath.shape.points.push(a, b);
        }
      } else {
        this.moveTo(a, b);
      }
      var f = this.currentPath.shape.points;
      var g = f[f.length - 2];
      var h = f[f.length - 1];
      var i = h - b;
      var j = g - a;
      var k = d - b;
      var l = c - a;
      var m = Math.abs(i * l - j * k);
      if (m < 1e-8 || 0 === e) {
        if (!(f[f.length - 2] === a && f[f.length - 1] === b)) {
          f.push(a, b);
        }
      } else {
        var n = i * i + j * j;
        var o = k * k + l * l;
        var p = i * k + j * l;
        var q = e * Math.sqrt(n) / m;
        var r = e * Math.sqrt(o) / m;
        var s = q * p / n;
        var t = r * p / o;
        var u = q * l + r * j;
        var v = q * k + r * i;
        var w = j * (r + s);
        var x = i * (r + s);
        var y = l * (q + t);
        var z = k * (q + t);
        var A = Math.atan2(x - v, w - u);
        var B = Math.atan2(z - v, y - u);
        this.arc(u + a, v + b, e, A, B, j * k > l * i);
      }
      this.dirty = true;
      this._boundsDirty = true;
      return this;
    };
    PIXI.Graphics.prototype.arc = function (a, b, c, d, e, f, g) {
      if (d === e) {
        return this;
      }
      if (undefined === f) {
        f = false;
      }
      if (undefined === g) {
        g = 40;
      }
      if (!f && e <= d) {
        e += 2 * Math.PI;
      } else if (f && d <= e) {
        d += 2 * Math.PI;
      }
      var h = f ? -1 * (d - e) : e - d;
      var i = Math.ceil(Math.abs(h) / (2 * Math.PI)) * g;
      if (0 === h) {
        return this;
      }
      var j = a + Math.cos(d) * c;
      var k = b + Math.sin(d) * c;
      if (f && this.filling) {
        this.moveTo(a, b);
      } else {
        this.moveTo(j, k);
      }
      var l = this.currentPath.shape.points;
      var m = h / (2 * i);
      var n = 2 * m;
      var o = Math.cos(m);
      var p = Math.sin(m);
      var q = i - 1;
      var r = q % 1 / q;
      for (var s = 0; s <= q; s++) {
        var t = s + r * s;
        var u = m + d + n * t;
        var v = Math.cos(u);
        var w = -Math.sin(u);
        l.push((o * v + p * w) * c + a, (o * -w + p * v) * c + b);
      }
      this.dirty = true;
      this._boundsDirty = true;
      return this;
    };
    PIXI.Graphics.prototype.beginFill = function (a, b) {
      this.filling = true;
      this.fillColor = a || 0;
      this.fillAlpha = undefined === b ? 1 : b;
      if (this.currentPath && this.currentPath.shape.points.length <= 2) {
        this.currentPath.fill = this.filling;
        this.currentPath.fillColor = this.fillColor;
        this.currentPath.fillAlpha = this.fillAlpha;
      }
      return this;
    };
    PIXI.Graphics.prototype.endFill = function () {
      this.filling = false;
      this.fillColor = null;
      this.fillAlpha = 1;
      return this;
    };
    PIXI.Graphics.prototype.drawRect = function (a, b, c, d) {
      this.drawShape(new PIXI.Rectangle(a, b, c, d));
      return this;
    };
    PIXI.Graphics.prototype.drawRoundedRect = function (a, b, c, d, e) {
      this.drawShape(new PIXI.RoundedRectangle(a, b, c, d, e));
      return this;
    };
    PIXI.Graphics.prototype.drawCircle = function (a, b, c) {
      this.drawShape(new PIXI.Circle(a, b, c));
      return this;
    };
    PIXI.Graphics.prototype.drawEllipse = function (a, b, c, d) {
      this.drawShape(new PIXI.Ellipse(a, b, c, d));
      return this;
    };
    PIXI.Graphics.prototype.drawPolygon = function (a) {
      if (a instanceof b.Polygon || a instanceof PIXI.Polygon) {
        a = a.points;
      }
      var c = a;
      if (!Array.isArray(c)) {
        c = new Array(arguments.length);
        for (var d = 0; d < c.length; ++d) {
          c[d] = arguments[d];
        }
      }
      this.drawShape(new b.Polygon(c));
      return this;
    };
    PIXI.Graphics.prototype.clear = function () {
      this.lineWidth = 0;
      this.filling = false;
      this.dirty = true;
      this._boundsDirty = true;
      this.clearDirty = true;
      this.graphicsData = [];
      this.updateLocalBounds();
      return this;
    };
    PIXI.Graphics.prototype.generateTexture = function (a, b, c) {
      if (undefined === a) {
        a = 1;
      }
      if (undefined === b) {
        b = PIXI.scaleModes.DEFAULT;
      }
      if (undefined === c) {
        c = 0;
      }
      var d = this.getBounds();
      d.width += c;
      d.height += c;
      var e = new PIXI.CanvasBuffer(d.width * a, d.height * a);
      var f = PIXI.Texture.fromCanvas(e.canvas, b);
      f.baseTexture.resolution = a;
      e.context.scale(a, a);
      e.context.translate(-d.x, -d.y);
      PIXI.CanvasGraphics.renderGraphics(this, e.context);
      return f;
    };
    PIXI.Graphics.prototype._renderWebGL = function (a) {
      if (false !== this.visible && 0 !== this.alpha && true !== this.isMask) {
        if (this._cacheAsBitmap) {
          if (this.dirty || this.cachedSpriteDirty) {
            this._generateCachedSprite();
            this.updateCachedSpriteTexture();
            this.cachedSpriteDirty = false;
            this.dirty = false;
          }
          this._cachedSprite.worldAlpha = this.worldAlpha;
          return void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, a);
        }
        a.spriteBatch.stop();
        a.blendModeManager.setBlendMode(this.blendMode);
        if (this._mask) {
          a.maskManager.pushMask(this._mask, a);
        }
        if (this._filters) {
          a.filterManager.pushFilter(this._filterBlock);
        }
        if (this.blendMode !== a.spriteBatch.currentBlendMode) {
          a.spriteBatch.currentBlendMode = this.blendMode;
          var b = PIXI.blendModesWebGL[a.spriteBatch.currentBlendMode];
          a.spriteBatch.gl.blendFunc(b[0], b[1]);
        }
        if (this.webGLDirty) {
          this.dirty = true;
          this.webGLDirty = false;
        }
        PIXI.WebGLGraphics.renderGraphics(this, a);
        if (this.children.length) {
          a.spriteBatch.start();
          for (var c = 0; c < this.children.length; c++) {
            this.children[c]._renderWebGL(a);
          }
          a.spriteBatch.stop();
        }
        if (this._filters) {
          a.filterManager.popFilter();
        }
        if (this._mask) {
          a.maskManager.popMask(this.mask, a);
        }
        a.drawCount++;
        a.spriteBatch.start();
      }
    };
    PIXI.Graphics.prototype._renderCanvas = function (a) {
      if (false !== this.visible && 0 !== this.alpha && true !== this.isMask) {
        if (this._prevTint !== this.tint) {
          this.dirty = true;
          this._prevTint = this.tint;
        }
        if (this._cacheAsBitmap) {
          if (this.dirty || this.cachedSpriteDirty) {
            this._generateCachedSprite();
            this.updateCachedSpriteTexture();
            this.cachedSpriteDirty = false;
            this.dirty = false;
          }
          this._cachedSprite.alpha = this.alpha;
          return void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, a);
        }
        var b = a.context;
        var c = this.worldTransform;
        if (this.blendMode !== a.currentBlendMode) {
          a.currentBlendMode = this.blendMode;
          b.globalCompositeOperation = PIXI.blendModesCanvas[a.currentBlendMode];
        }
        if (this._mask) {
          a.maskManager.pushMask(this._mask, a);
        }
        var d = a.resolution;
        var e = c.tx * a.resolution + a.shakeX;
        var f = c.ty * a.resolution + a.shakeY;
        b.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, e, f);
        PIXI.CanvasGraphics.renderGraphics(this, b);
        for (var g = 0; g < this.children.length; g++) {
          this.children[g]._renderCanvas(a);
        }
        if (this._mask) {
          a.maskManager.popMask(a);
        }
      }
    };
    PIXI.Graphics.prototype.getBounds = function (a) {
      if (!this._currentBounds) {
        if (!this.renderable) {
          return PIXI.EmptyRectangle;
        }
        if (this.dirty) {
          this.updateLocalBounds();
          this.webGLDirty = true;
          this.cachedSpriteDirty = true;
          this.dirty = false;
        }
        var b = this._localBounds;
        var c = b.x;
        var d = b.width + b.x;
        var e = b.y;
        var f = b.height + b.y;
        var g = a || this.worldTransform;
        var h = g.a;
        var i = g.b;
        var j = g.c;
        var k = g.d;
        var l = g.tx;
        var m = g.ty;
        var n = h * d + j * f + l;
        var o = k * f + i * d + m;
        var p = h * c + j * f + l;
        var q = k * f + i * c + m;
        var r = h * c + j * e + l;
        var s = k * e + i * c + m;
        var t = h * d + j * e + l;
        var u = k * e + i * d + m;
        var v = n;
        var w = o;
        var x = n;
        var y = o;
        x = p < x ? p : x;
        x = r < x ? r : x;
        x = t < x ? t : x;
        y = q < y ? q : y;
        y = s < y ? s : y;
        y = u < y ? u : y;
        v = p > v ? p : v;
        v = r > v ? r : v;
        v = t > v ? t : v;
        w = q > w ? q : w;
        w = s > w ? s : w;
        w = u > w ? u : w;
        this._bounds.x = x;
        this._bounds.width = v - x;
        this._bounds.y = y;
        this._bounds.height = w - y;
        this._currentBounds = this._bounds;
      }
      return this._currentBounds;
    };
    PIXI.Graphics.prototype.getLocalBounds = function () {
      var a = this.worldTransform;
      this.worldTransform = PIXI.identityMatrix;
      for (var b = 0; b < this.children.length; b++) {
        this.children[b].updateTransform();
      }
      var c = this.getBounds();
      this.worldTransform = a;
      for (b = 0; b < this.children.length; b++) {
        this.children[b].updateTransform();
      }
      return c;
    };
    PIXI.Graphics.prototype.containsPoint = function (a) {
      this.worldTransform.applyInverse(a, tempPoint);
      var b = this.graphicsData;
      for (var c = 0; c < b.length; c++) {
        var d = b[c];
        if (d.fill && d.shape && d.shape.contains(tempPoint.x, tempPoint.y)) {
          return true;
        }
      }
      return false;
    };
    PIXI.Graphics.prototype.updateLocalBounds = function () {
      var a = Infinity;
      var c = -Infinity;
      var d = Infinity;
      var e = -Infinity;
      if (this.graphicsData.length) {
        var f;
        var g;
        var h;
        var i;
        var j;
        var k;
        for (var l = 0; l < this.graphicsData.length; l++) {
          var m = this.graphicsData[l];
          var n = m.type;
          var o = m.lineWidth;
          f = m.shape;
          if (n === PIXI.Graphics.RECT || n === PIXI.Graphics.RREC) {
            h = f.x - o / 2;
            i = f.y - o / 2;
            j = f.width + o;
            k = f.height + o;
            a = h < a ? h : a;
            c = h + j > c ? h + j : c;
            d = i < d ? i : d;
            e = i + k > e ? i + k : e;
          } else if (n === PIXI.Graphics.CIRC) {
            h = f.x;
            i = f.y;
            j = f.radius + o / 2;
            k = f.radius + o / 2;
            a = h - j < a ? h - j : a;
            c = h + j > c ? h + j : c;
            d = i - k < d ? i - k : d;
            e = i + k > e ? i + k : e;
          } else if (n === PIXI.Graphics.ELIP) {
            h = f.x;
            i = f.y;
            j = f.width + o / 2;
            k = f.height + o / 2;
            a = h - j < a ? h - j : a;
            c = h + j > c ? h + j : c;
            d = i - k < d ? i - k : d;
            e = i + k > e ? i + k : e;
          } else {
            g = f.points;
            for (var p = 0; p < g.length; p++) {
              if (g[p] instanceof b.Point) {
                h = g[p].x;
                i = g[p].y;
              } else {
                h = g[p];
                i = g[p + 1];
                if (p < g.length - 1) {
                  p++;
                }
              }
              a = h - o < a ? h - o : a;
              c = h + o > c ? h + o : c;
              d = i - o < d ? i - o : d;
              e = i + o > e ? i + o : e;
            }
          }
        }
      } else {
        a = 0;
        c = 0;
        d = 0;
        e = 0;
      }
      var q = this.boundsPadding;
      this._localBounds.x = a - q;
      this._localBounds.width = c - a + 2 * q;
      this._localBounds.y = d - q;
      this._localBounds.height = e - d + 2 * q;
    };
    PIXI.Graphics.prototype._generateCachedSprite = function () {
      var a = this.getLocalBounds();
      if (this._cachedSprite) {
        this._cachedSprite.buffer.resize(a.width, a.height);
      } else {
        var b = new PIXI.CanvasBuffer(a.width, a.height);
        var c = PIXI.Texture.fromCanvas(b.canvas);
        this._cachedSprite = new PIXI.Sprite(c);
        this._cachedSprite.buffer = b;
        this._cachedSprite.worldTransform = this.worldTransform;
      }
      this._cachedSprite.anchor.x = -a.x / a.width;
      this._cachedSprite.anchor.y = -a.y / a.height;
      this._cachedSprite.buffer.context.translate(-a.x, -a.y);
      this.worldAlpha = 1;
      PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
      this._cachedSprite.alpha = this.alpha;
    };
    PIXI.Graphics.prototype.updateCachedSpriteTexture = function () {
      var a = this._cachedSprite;
      var b = a.texture;
      var c = a.buffer.canvas;
      b.baseTexture.width = c.width;
      b.baseTexture.height = c.height;
      b.crop.width = b.frame.width = c.width;
      b.crop.height = b.frame.height = c.height;
      a._width = c.width;
      a._height = c.height;
      b.baseTexture.dirty();
    };
    PIXI.Graphics.prototype.destroyCachedSprite = function () {
      this._cachedSprite.texture.destroy(true);
      this._cachedSprite = null;
    };
    PIXI.Graphics.prototype.drawShape = function (a) {
      if (this.currentPath && this.currentPath.shape.points.length <= 2) {
        this.graphicsData.pop();
      }
      this.currentPath = null;
      if (a instanceof b.Polygon) {
        a = a.clone();
        a.flatten();
      }
      var c = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, a);
      this.graphicsData.push(c);
      if (c.type === PIXI.Graphics.POLY) {
        c.shape.closed = this.filling;
        this.currentPath = c;
      }
      this.dirty = true;
      this._boundsDirty = true;
      return c;
    };
    Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
      get: function () {
        return this._cacheAsBitmap;
      },
      set: function (a) {
        this._cacheAsBitmap = a;
        if (this._cacheAsBitmap) {
          this._generateCachedSprite();
        } else {
          this.destroyCachedSprite();
        }
        this.dirty = true;
        this.webGLDirty = true;
      }
    });
    PIXI.GraphicsData = function (a, b, c, d, e, f, g) {
      this.lineWidth = a;
      this.lineColor = b;
      this.lineAlpha = c;
      this._lineTint = b;
      this.fillColor = d;
      this.fillAlpha = e;
      this._fillTint = d;
      this.fill = f;
      this.shape = g;
      this.type = g.type;
    };
    PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData;
    PIXI.GraphicsData.prototype.clone = function () {
      return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
    };
    PIXI.EarCut = {};
    PIXI.EarCut.Triangulate = function (a, b, c) {
      c = c || 2;
      var d = b && b.length;
      var e = d ? b[0] * c : a.length;
      var f = PIXI.EarCut.linkedList(a, 0, e, c, true);
      var g = [];
      if (!f) {
        return g;
      }
      var h;
      var i;
      var j;
      var k;
      var l;
      var m;
      var n;
      if (d) {
        f = PIXI.EarCut.eliminateHoles(a, b, f, c);
      }
      if (a.length > 80 * c) {
        h = j = a[0];
        i = k = a[1];
        for (var o = c; o < e; o += c) {
          l = a[o];
          m = a[o + 1];
          if (l < h) {
            h = l;
          }
          if (m < i) {
            i = m;
          }
          if (l > j) {
            j = l;
          }
          if (m > k) {
            k = m;
          }
        }
        n = Math.max(j - h, k - i);
      }
      PIXI.EarCut.earcutLinked(f, g, c, h, i, n);
      return g;
    };
    PIXI.EarCut.linkedList = function (a, b, c, d, e) {
      var g;
      var h;
      var i;
      var f = 0;
      g = b;
      for (h = c - d; g < c; g += d) {
        f += (a[h] - a[g]) * (a[g + 1] + a[h + 1]);
        h = g;
      }
      if (e === f > 0) {
        for (g = b; g < c; g += d) {
          i = PIXI.EarCut.insertNode(g, a[g], a[g + 1], i);
        }
      } else {
        for (g = c - d; g >= b; g -= d) {
          i = PIXI.EarCut.insertNode(g, a[g], a[g + 1], i);
        }
      }
      return i;
    };
    PIXI.EarCut.filterPoints = function (a, b) {
      if (!a) {
        return a;
      }
      if (!b) {
        b = a;
      }
      var d;
      var c = a;
      do {
        d = false;
        if (c.steiner || !PIXI.EarCut.equals(c, c.next) && 0 !== PIXI.EarCut.area(c.prev, c, c.next)) {
          c = c.next;
        } else {
          PIXI.EarCut.removeNode(c);
          if ((c = b = c.prev) === c.next) {
            return null;
          }
          d = true;
        }
      } while (d || c !== b);
      return b;
    };
    PIXI.EarCut.earcutLinked = function (a, b, c, d, e, f, g) {
      if (a) {
        if (!g && f) {
          PIXI.EarCut.indexCurve(a, d, e, f);
        }
        var i;
        var j;
        for (var h = a; a.prev !== a.next;) {
          i = a.prev;
          j = a.next;
          if (f ? PIXI.EarCut.isEarHashed(a, d, e, f) : PIXI.EarCut.isEar(a)) {
            b.push(i.i / c);
            b.push(a.i / c);
            b.push(j.i / c);
            PIXI.EarCut.removeNode(a);
            a = j.next;
            h = j.next;
          } else if ((a = j) === h) {
            if (g) {
              if (1 === g) {
                a = PIXI.EarCut.cureLocalIntersections(a, b, c);
                PIXI.EarCut.earcutLinked(a, b, c, d, e, f, 2);
              } else if (2 === g) {
                PIXI.EarCut.splitEarcut(a, b, c, d, e, f);
              }
            } else {
              PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(a), b, c, d, e, f, 1);
            }
            break;
          }
        }
      }
    };
    PIXI.EarCut.isEar = function (a) {
      var b = a.prev;
      var d = a.next;
      if (PIXI.EarCut.area(b, a, d) >= 0) {
        return false;
      }
      for (var e = a.next.next; e !== a.prev;) {
        if (PIXI.EarCut.pointInTriangle(b.x, b.y, a.x, a.y, d.x, d.y, e.x, e.y) && PIXI.EarCut.area(e.prev, e, e.next) >= 0) {
          return false;
        }
        e = e.next;
      }
      return true;
    };
    PIXI.EarCut.isEarHashed = function (a, b, c, d) {
      var e = a.prev;
      var g = a.next;
      if (PIXI.EarCut.area(e, a, g) >= 0) {
        return false;
      }
      var h = e.x < a.x ? e.x < g.x ? e.x : g.x : a.x < g.x ? a.x : g.x;
      var i = e.y < a.y ? e.y < g.y ? e.y : g.y : a.y < g.y ? a.y : g.y;
      var j = e.x > a.x ? e.x > g.x ? e.x : g.x : a.x > g.x ? a.x : g.x;
      var k = e.y > a.y ? e.y > g.y ? e.y : g.y : a.y > g.y ? a.y : g.y;
      var l = PIXI.EarCut.zOrder(h, i, b, c, d);
      var m = PIXI.EarCut.zOrder(j, k, b, c, d);
      for (var n = a.nextZ; n && n.z <= m;) {
        if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, a.x, a.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) {
          return false;
        }
        n = n.nextZ;
      }
      for (n = a.prevZ; n && n.z >= l;) {
        if (n !== a.prev && n !== a.next && PIXI.EarCut.pointInTriangle(e.x, e.y, a.x, a.y, g.x, g.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) {
          return false;
        }
        n = n.prevZ;
      }
      return true;
    };
    PIXI.EarCut.cureLocalIntersections = function (a, b, c) {
      var d = f;
      do {
        var e = d.prev;
        var f = d.next.next;
        if (PIXI.EarCut.intersects(e, d, d.next, f) && PIXI.EarCut.locallyInside(e, f) && PIXI.EarCut.locallyInside(f, e)) {
          b.push(e.i / c);
          b.push(d.i / c);
          b.push(f.i / c);
          PIXI.EarCut.removeNode(d);
          PIXI.EarCut.removeNode(d.next);
          d = a = f;
        }
        d = d.next;
      } while (d !== f);
      return d;
    };
    PIXI.EarCut.splitEarcut = function (a, b, c, d, e, f) {
      var g = a;
      do {
        for (var h = g.next.next; h !== g.prev;) {
          if (g.i !== h.i && PIXI.EarCut.isValidDiagonal(g, h)) {
            var i = PIXI.EarCut.splitPolygon(g, h);
            g = PIXI.EarCut.filterPoints(g, g.next);
            i = PIXI.EarCut.filterPoints(i, i.next);
            PIXI.EarCut.earcutLinked(g, b, c, d, e, f);
            return void PIXI.EarCut.earcutLinked(i, b, c, d, e, f);
          }
          h = h.next;
        }
        g = g.next;
      } while (g !== a);
    };
    PIXI.EarCut.eliminateHoles = function (a, b, c, d) {
      var f;
      var g;
      var h;
      var i;
      var j;
      var e = [];
      f = 0;
      for (g = b.length; f < g; f++) {
        h = b[f] * d;
        i = f < g - 1 ? b[f + 1] * d : a.length;
        j = PIXI.EarCut.linkedList(a, h, i, d, false);
        if (j === j.next) {
          j.steiner = true;
        }
        e.push(PIXI.EarCut.getLeftmost(j));
      }
      e.sort(compareX);
      for (f = 0; f < e.length; f++) {
        PIXI.EarCut.eliminateHole(e[f], c);
        c = PIXI.EarCut.filterPoints(c, c.next);
      }
      return c;
    };
    PIXI.EarCut.compareX = function (a, b) {
      return a.x - b.x;
    };
    PIXI.EarCut.eliminateHole = function (a, b) {
      if (b = PIXI.EarCut.findHoleBridge(a, b)) {
        var c = PIXI.EarCut.splitPolygon(b, a);
        PIXI.EarCut.filterPoints(c, c.next);
      }
    };
    PIXI.EarCut.findHoleBridge = function (a, b) {
      var g;
      var c = b;
      var d = a.x;
      var e = a.y;
      var f = -Infinity;
      do {
        if (e <= c.y && e >= c.next.y) {
          var h = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
          if (h <= d && h > f) {
            f = h;
            g = c.x < c.next.x ? c : c.next;
          }
        }
        c = c.next;
      } while (c !== b);
      if (!g) {
        return null;
      }
      if (a.x === g.x) {
        return g.prev;
      }
      var k;
      var j = Infinity;
      for (c = g.next; c !== g;) {
        if (d >= c.x && c.x >= g.x && PIXI.EarCut.pointInTriangle(e < g.y ? d : f, e, g.x, g.y, e < g.y ? f : d, e, c.x, c.y) && ((k = Math.abs(e - c.y) / (d - c.x)) < j || k === j && c.x > g.x) && PIXI.EarCut.locallyInside(c, a)) {
          g = c;
          j = k;
        }
        c = c.next;
      }
      return g;
    };
    PIXI.EarCut.indexCurve = function (a, b, c, d) {
      var e = a;
      do {
        if (null === e.z) {
          e.z = PIXI.EarCut.zOrder(e.x, e.y, b, c, d);
        }
        e.prevZ = e.prev;
        e.nextZ = e.next;
        e = e.next;
      } while (e !== a);
      e.prevZ.nextZ = null;
      e.prevZ = null;
      PIXI.EarCut.sortLinked(e);
    };
    PIXI.EarCut.sortLinked = function (a) {
      var b;
      var c;
      var d;
      var e;
      var f;
      var g;
      var h;
      var i;
      var j = 1;
      do {
        c = a;
        a = null;
        f = null;
        for (g = 0; c;) {
          g++;
          d = c;
          h = 0;
          for (b = 0; b < j && (h++, d = d.nextZ); b++) {
            ;
          }
          for (i = j; h > 0 || i > 0 && d;) {
            if (0 === h) {
              e = d;
              d = d.nextZ;
              i--;
            } else if (0 !== i && d) {
              if (c.z <= d.z) {
                e = c;
                c = c.nextZ;
                h--;
              } else {
                e = d;
                d = d.nextZ;
                i--;
              }
            } else {
              e = c;
              c = c.nextZ;
              h--;
            }
            if (f) {
              f.nextZ = e;
            } else {
              a = e;
            }
            e.prevZ = f;
            f = e;
          }
          c = d;
        }
        f.nextZ = null;
        j *= 2;
      } while (g > 1);
      return a;
    };
    PIXI.EarCut.zOrder = function (a, b, c, d, e) {
      a = 32767 * (a - c) / e;
      b = 32767 * (b - d) / e;
      a = 16711935 & (a | a << 8);
      a = 252645135 & (a | a << 4);
      a = 858993459 & (a | a << 2);
      a = 1431655765 & (a | a << 1);
      b = 16711935 & (b | b << 8);
      b = 252645135 & (b | b << 4);
      b = 858993459 & (b | b << 2);
      b = 1431655765 & (b | b << 1);
      return a | b << 1;
    };
    PIXI.EarCut.getLeftmost = function (a) {
      var b = a;
      var c = a;
      do {
        if (b.x < c.x) {
          c = b;
        }
        b = b.next;
      } while (b !== a);
      return c;
    };
    PIXI.EarCut.pointInTriangle = function (a, b, c, d, e, f, g, h) {
      return (e - g) * (b - h) - (a - g) * (f - h) >= 0 && (a - g) * (d - h) - (c - g) * (b - h) >= 0 && (c - g) * (f - h) - (e - g) * (d - h) >= 0;
    };
    PIXI.EarCut.isValidDiagonal = function (a, b) {
      return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b);
    };
    PIXI.EarCut.area = function (a, b, c) {
      return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
    };
    PIXI.EarCut.equals = function (a, b) {
      return a.x === b.x && a.y === b.y;
    };
    PIXI.EarCut.intersects = function (a, b, c, d) {
      return PIXI.EarCut.area(a, b, c) > 0 != PIXI.EarCut.area(a, b, d) > 0 && PIXI.EarCut.area(c, d, a) > 0 != PIXI.EarCut.area(c, d, b) > 0;
    };
    PIXI.EarCut.intersectsPolygon = function (a, b) {
      var c = a;
      do {
        if (c.i !== a.i && c.next.i !== a.i && c.i !== b.i && c.next.i !== b.i && PIXI.EarCut.intersects(c, c.next, a, b)) {
          return true;
        }
        c = c.next;
      } while (c !== a);
      return false;
    };
    PIXI.EarCut.locallyInside = function (a, b) {
      return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0;
    };
    PIXI.EarCut.middleInside = function (a, b) {
      var c = a;
      var d = false;
      var e = (a.x + b.x) / 2;
      var f = (a.y + b.y) / 2;
      do {
        if (c.y > f != c.next.y > f && e < (c.next.x - c.x) * (f - c.y) / (c.next.y - c.y) + c.x) {
          d = !d;
        }
        c = c.next;
      } while (c !== a);
      return d;
    };
    PIXI.EarCut.splitPolygon = function (a, b) {
      var c = new PIXI.EarCut.Node(a.i, a.x, a.y);
      var d = new PIXI.EarCut.Node(b.i, b.x, b.y);
      var e = a.next;
      var f = b.prev;
      a.next = b;
      b.prev = a;
      c.next = e;
      e.prev = c;
      d.next = c;
      c.prev = d;
      f.next = d;
      d.prev = f;
      return d;
    };
    PIXI.EarCut.insertNode = function (a, b, c, d) {
      var e = new PIXI.EarCut.Node(a, b, c);
      if (d) {
        e.next = d.next;
        e.prev = d;
        d.next.prev = e;
        d.next = e;
      } else {
        e.prev = e;
        e.next = e;
      }
      return e;
    };
    PIXI.EarCut.removeNode = function (a) {
      a.next.prev = a.prev;
      a.prev.next = a.next;
      if (a.prevZ) {
        a.prevZ.nextZ = a.nextZ;
      }
      if (a.nextZ) {
        a.nextZ.prevZ = a.prevZ;
      }
    };
    PIXI.EarCut.Node = function (a, b, c) {
      this.i = a;
      this.x = b;
      this.y = c;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    };
    PIXI.WebGLGraphics = function () {};
    PIXI.WebGLGraphics.stencilBufferLimit = 6;
    PIXI.WebGLGraphics.renderGraphics = function (a, b) {
      var g;
      var c = b.gl;
      var d = b.projection;
      var e = b.offset;
      var f = b.shaderManager.primitiveShader;
      if (a.dirty) {
        PIXI.WebGLGraphics.updateGraphics(a, c);
      }
      var h = a._webGL[c.id];
      for (var i = 0; i < h.data.length; i++) {
        if (1 === h.data[i].mode) {
          g = h.data[i];
          b.stencilManager.pushStencil(a, g, b);
          c.drawElements(c.TRIANGLE_FAN, 4, c.UNSIGNED_SHORT, 2 * (g.indices.length - 4));
          b.stencilManager.popStencil(a, g, b);
        } else {
          g = h.data[i];
          b.shaderManager.setShader(f);
          f = b.shaderManager.primitiveShader;
          c.uniformMatrix3fv(f.translationMatrix, false, a.worldTransform.toArray(true));
          c.uniform1f(f.flipY, 1);
          c.uniform2f(f.projectionVector, d.x, -d.y);
          c.uniform2f(f.offsetVector, -e.x, -e.y);
          c.uniform3fv(f.tintColor, PIXI.hex2rgb(a.tint));
          c.uniform1f(f.alpha, a.worldAlpha);
          c.bindBuffer(c.ARRAY_BUFFER, g.buffer);
          c.vertexAttribPointer(f.aVertexPosition, 2, c.FLOAT, false, 24, 0);
          c.vertexAttribPointer(f.colorAttribute, 4, c.FLOAT, false, 24, 8);
          c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, g.indexBuffer);
          c.drawElements(c.TRIANGLE_STRIP, g.indices.length, c.UNSIGNED_SHORT, 0);
        }
      }
    };
    PIXI.WebGLGraphics.updateGraphics = function (a, b) {
      var c = a._webGL[b.id];
      if (!c) {
        c = a._webGL[b.id] = {
          lastIndex: 0,
          data: [],
          gl: b
        };
      }
      a.dirty = false;
      var d;
      if (a.clearDirty) {
        a.clearDirty = false;
        for (d = 0; d < c.data.length; d++) {
          var e = c.data[d];
          e.reset();
          PIXI.WebGLGraphics.graphicsDataPool.push(e);
        }
        c.data = [];
        c.lastIndex = 0;
      }
      var f;
      for (d = c.lastIndex; d < a.graphicsData.length; d++) {
        var g = a.graphicsData[d];
        if (g.type === PIXI.Graphics.POLY) {
          g.points = g.shape.points.slice();
          if (g.shape.closed) {
            if (!(g.points[0] === g.points[g.points.length - 2] && g.points[1] === g.points[g.points.length - 1])) {
              g.points.push(g.points[0], g.points[1]);
            }
          }
          if (g.fill && g.points.length >= PIXI.WebGLGraphics.stencilBufferLimit) {
            if (g.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
              f = PIXI.WebGLGraphics.switchMode(c, 0);
              var h = PIXI.WebGLGraphics.buildPoly(g, f);
              if (!h) {
                f = PIXI.WebGLGraphics.switchMode(c, 1);
                PIXI.WebGLGraphics.buildComplexPoly(g, f);
              }
            } else {
              f = PIXI.WebGLGraphics.switchMode(c, 1);
              PIXI.WebGLGraphics.buildComplexPoly(g, f);
            }
          }
          if (g.lineWidth > 0) {
            f = PIXI.WebGLGraphics.switchMode(c, 0);
            PIXI.WebGLGraphics.buildLine(g, f);
          }
        } else {
          f = PIXI.WebGLGraphics.switchMode(c, 0);
          if (g.type === PIXI.Graphics.RECT) {
            PIXI.WebGLGraphics.buildRectangle(g, f);
          } else if (g.type === PIXI.Graphics.CIRC || g.type === PIXI.Graphics.ELIP) {
            PIXI.WebGLGraphics.buildCircle(g, f);
          } else if (g.type === PIXI.Graphics.RREC) {
            PIXI.WebGLGraphics.buildRoundedRectangle(g, f);
          }
        }
        c.lastIndex++;
      }
      for (d = 0; d < c.data.length; d++) {
        f = c.data[d];
        if (f.dirty) {
          f.upload();
        }
      }
    };
    PIXI.WebGLGraphics.switchMode = function (a, b) {
      var c;
      if (a.data.length) {
        c = a.data[a.data.length - 1];
        if (!(c.mode === b && 1 !== b)) {
          c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl);
          c.mode = b;
          a.data.push(c);
        }
      } else {
        c = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(a.gl);
        c.mode = b;
        a.data.push(c);
      }
      c.dirty = true;
      return c;
    };
    PIXI.WebGLGraphics.buildRectangle = function (a, b) {
      var c = a.shape;
      var d = c.x;
      var e = c.y;
      var f = c.width;
      var g = c.height;
      if (a.fill) {
        var h = PIXI.hex2rgb(a.fillColor);
        var i = a.fillAlpha;
        var j = h[0] * i;
        var k = h[1] * i;
        var l = h[2] * i;
        var m = b.points;
        var n = b.indices;
        var o = m.length / 6;
        m.push(d, e);
        m.push(j, k, l, i);
        m.push(d + f, e);
        m.push(j, k, l, i);
        m.push(d, e + g);
        m.push(j, k, l, i);
        m.push(d + f, e + g);
        m.push(j, k, l, i);
        n.push(o, o, o + 1, o + 2, o + 3, o + 3);
      }
      if (a.lineWidth) {
        var p = a.points;
        a.points = [d, e, d + f, e, d + f, e + g, d, e + g, d, e];
        PIXI.WebGLGraphics.buildLine(a, b);
        a.points = p;
      }
    };
    PIXI.WebGLGraphics.buildRoundedRectangle = function (a, b) {
      var c = a.shape;
      var d = c.x;
      var e = c.y;
      var f = c.width;
      var g = c.height;
      var h = c.radius;
      var i = [];
      i.push(d, e + h);
      i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d, e + g - h, d, e + g, d + h, e + g));
      i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f - h, e + g, d + f, e + g, d + f, e + g - h));
      i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + f, e + h, d + f, e, d + f - h, e));
      i = i.concat(PIXI.WebGLGraphics.quadraticBezierCurve(d + h, e, d, e, d, e + h));
      if (a.fill) {
        var j = PIXI.hex2rgb(a.fillColor);
        var k = a.fillAlpha;
        var l = j[0] * k;
        var m = j[1] * k;
        var n = j[2] * k;
        var o = b.points;
        var p = b.indices;
        var q = o.length / 6;
        var r = PIXI.EarCut.Triangulate(i, null, 2);
        var s = 0;
        for (s = 0; s < r.length; s += 3) {
          p.push(r[s] + q);
          p.push(r[s] + q);
          p.push(r[s + 1] + q);
          p.push(r[s + 2] + q);
          p.push(r[s + 2] + q);
        }
        for (s = 0; s < i.length; s++) {
          o.push(i[s], i[++s], l, m, n, k);
        }
      }
      if (a.lineWidth) {
        var t = a.points;
        a.points = i;
        PIXI.WebGLGraphics.buildLine(a, b);
        a.points = t;
      }
    };
    PIXI.WebGLGraphics.quadraticBezierCurve = function (a, b, c, d, e, f) {
      var g;
      var h;
      var i;
      var j;
      var k;
      var l;
      var n = [];
      var p = 0;
      for (var q = 0; q <= 20; q++) {
        p = q / 20;
        g = a + (c - a) * p;
        h = b + (d - b) * p;
        i = c + (e - c) * p;
        j = d + (f - d) * p;
        k = g + (i - g) * p;
        l = h + (j - h) * p;
        n.push(k, l);
      }
      return n;
    };
    PIXI.WebGLGraphics.buildCircle = function (a, b) {
      var f;
      var g;
      var c = a.shape;
      var d = c.x;
      var e = c.y;
      if (a.type === PIXI.Graphics.CIRC) {
        f = c.radius;
        g = c.radius;
      } else {
        f = c.width;
        g = c.height;
      }
      var i = 2 * Math.PI / 40;
      var j = 0;
      if (a.fill) {
        var k = PIXI.hex2rgb(a.fillColor);
        var l = a.fillAlpha;
        var m = k[0] * l;
        var n = k[1] * l;
        var o = k[2] * l;
        var p = b.points;
        var q = b.indices;
        var r = p.length / 6;
        q.push(r);
        for (j = 0; j < 41; j++) {
          p.push(d, e, m, n, o, l);
          p.push(d + Math.sin(i * j) * f, e + Math.cos(i * j) * g, m, n, o, l);
          q.push(r++, r++);
        }
        q.push(r - 1);
      }
      if (a.lineWidth) {
        var s = a.points;
        a.points = [];
        for (j = 0; j < 41; j++) {
          a.points.push(d + Math.sin(i * j) * f, e + Math.cos(i * j) * g);
        }
        PIXI.WebGLGraphics.buildLine(a, b);
        a.points = s;
      }
    };
    PIXI.WebGLGraphics.buildLine = function (a, b) {
      var c = 0;
      var d = a.points;
      if (0 !== d.length) {
        if (a.lineWidth % 2) {
          for (c = 0; c < d.length; c++) {
            d[c] += .5;
          }
        }
        var e = new PIXI.Point(d[0], d[1]);
        var f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
        if (e.x === f.x && e.y === f.y) {
          d = d.slice();
          d.pop();
          d.pop();
          f = new PIXI.Point(d[d.length - 2], d[d.length - 1]);
          var g = f.x + .5 * (e.x - f.x);
          var h = f.y + .5 * (e.y - f.y);
          d.unshift(g, h);
          d.push(g, h);
        }
        var t;
        var u;
        var v;
        var w;
        var x;
        var y;
        var z;
        var A;
        var B;
        var C;
        var D;
        var E;
        var F;
        var G;
        var H;
        var I;
        var J;
        var K;
        var L;
        var M;
        var N;
        var O;
        var P;
        var i = b.points;
        var j = b.indices;
        var k = d.length / 2;
        var l = d.length;
        var m = i.length / 6;
        var n = a.lineWidth / 2;
        var o = PIXI.hex2rgb(a.lineColor);
        var p = a.lineAlpha;
        var q = o[0] * p;
        var r = o[1] * p;
        var s = o[2] * p;
        v = d[0];
        w = d[1];
        x = d[2];
        y = d[3];
        B = -(w - y);
        C = v - x;
        P = Math.sqrt(B * B + C * C);
        B /= P;
        C /= P;
        B *= n;
        C *= n;
        i.push(v - B, w - C, q, r, s, p);
        i.push(v + B, w + C, q, r, s, p);
        for (c = 1; c < k - 1; c++) {
          v = d[2 * (c - 1)];
          w = d[2 * (c - 1) + 1];
          x = d[2 * c];
          y = d[2 * c + 1];
          z = d[2 * (c + 1)];
          A = d[2 * (c + 1) + 1];
          B = -(w - y);
          C = v - x;
          P = Math.sqrt(B * B + C * C);
          B /= P;
          C /= P;
          B *= n;
          C *= n;
          D = -(y - A);
          E = x - z;
          P = Math.sqrt(D * D + E * E);
          D /= P;
          E /= P;
          D *= n;
          E *= n;
          H = -C + w - (-C + y);
          I = -B + x - (-B + v);
          J = (-B + v) * (-C + y) - (-B + x) * (-C + w);
          K = -E + A - (-E + y);
          L = -D + x - (-D + z);
          M = (-D + z) * (-E + y) - (-D + x) * (-E + A);
          N = H * L - K * I;
          if (Math.abs(N) < .1) {
            N += 10.1;
            i.push(x - B, y - C, q, r, s, p);
            i.push(x + B, y + C, q, r, s, p);
          } else {
            t = (I * M - L * J) / N;
            u = (K * J - H * M) / N;
            O = (t - x) * (t - x) + (u - y) + (u - y);
            if (O > 19600) {
              F = B - D;
              G = C - E;
              P = Math.sqrt(F * F + G * G);
              F /= P;
              G /= P;
              F *= n;
              G *= n;
              i.push(x - F, y - G);
              i.push(q, r, s, p);
              i.push(x + F, y + G);
              i.push(q, r, s, p);
              i.push(x - F, y - G);
              i.push(q, r, s, p);
              l++;
            } else {
              i.push(t, u);
              i.push(q, r, s, p);
              i.push(x - (t - x), y - (u - y));
              i.push(q, r, s, p);
            }
          }
        }
        v = d[2 * (k - 2)];
        w = d[2 * (k - 2) + 1];
        x = d[2 * (k - 1)];
        y = d[2 * (k - 1) + 1];
        B = -(w - y);
        C = v - x;
        P = Math.sqrt(B * B + C * C);
        B /= P;
        C /= P;
        B *= n;
        C *= n;
        i.push(x - B, y - C);
        i.push(q, r, s, p);
        i.push(x + B, y + C);
        i.push(q, r, s, p);
        j.push(m);
        for (c = 0; c < l; c++) {
          j.push(m++);
        }
        j.push(m - 1);
      }
    };
    PIXI.WebGLGraphics.buildComplexPoly = function (a, b) {
      var c = a.points.slice();
      if (!(c.length < 6)) {
        var d = b.indices;
        b.points = c;
        b.alpha = a.fillAlpha;
        b.color = PIXI.hex2rgb(a.fillColor);
        var i;
        var j;
        var e = Infinity;
        var f = -Infinity;
        var g = Infinity;
        var h = -Infinity;
        for (var k = 0; k < c.length; k += 2) {
          i = c[k];
          j = c[k + 1];
          e = i < e ? i : e;
          f = i > f ? i : f;
          g = j < g ? j : g;
          h = j > h ? j : h;
        }
        c.push(e, g, f, g, f, h, e, h);
        var l = c.length / 2;
        for (k = 0; k < l; k++) {
          d.push(k);
        }
      }
    };
    PIXI.WebGLGraphics.buildPoly = function (a, b) {
      var c = a.points;
      if (!(c.length < 6)) {
        var d = b.points;
        var e = b.indices;
        var f = c.length / 2;
        var g = PIXI.hex2rgb(a.fillColor);
        var h = a.fillAlpha;
        var i = g[0] * h;
        var j = g[1] * h;
        var k = g[2] * h;
        var l = PIXI.EarCut.Triangulate(c, null, 2);
        if (!l) {
          return false;
        }
        var m = d.length / 6;
        var n = 0;
        for (n = 0; n < l.length; n += 3) {
          e.push(l[n] + m);
          e.push(l[n] + m);
          e.push(l[n + 1] + m);
          e.push(l[n + 2] + m);
          e.push(l[n + 2] + m);
        }
        for (n = 0; n < f; n++) {
          d.push(c[2 * n], c[2 * n + 1], i, j, k, h);
        }
        return true;
      }
    };
    PIXI.WebGLGraphics.graphicsDataPool = [];
    PIXI.WebGLGraphicsData = function (a) {
      this.gl = a;
      this.color = [0, 0, 0];
      this.points = [];
      this.indices = [];
      this.buffer = a.createBuffer();
      this.indexBuffer = a.createBuffer();
      this.mode = 1;
      this.alpha = 1;
      this.dirty = true;
    };
    PIXI.WebGLGraphicsData.prototype.reset = function () {
      this.points = [];
      this.indices = [];
    };
    PIXI.WebGLGraphicsData.prototype.upload = function () {
      var a = this.gl;
      this.glPoints = new PIXI.Float32Array(this.points);
      a.bindBuffer(a.ARRAY_BUFFER, this.buffer);
      a.bufferData(a.ARRAY_BUFFER, this.glPoints, a.STATIC_DRAW);
      this.glIndicies = new PIXI.Uint16Array(this.indices);
      a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.glIndicies, a.STATIC_DRAW);
      this.dirty = false;
    };
    PIXI.CanvasGraphics = function () {};
    PIXI.CanvasGraphics.renderGraphics = function (a, b) {
      var c = a.worldAlpha;
      if (a.dirty) {
        this.updateGraphicsTint(a);
        a.dirty = false;
      }
      for (var d = 0; d < a.graphicsData.length; d++) {
        var e = a.graphicsData[d];
        var f = e.shape;
        var g = e._fillTint;
        var h = e._lineTint;
        b.lineWidth = e.lineWidth;
        if (e.type === PIXI.Graphics.POLY) {
          b.beginPath();
          var i = f.points;
          b.moveTo(i[0], i[1]);
          for (var j = 1; j < i.length / 2; j++) {
            b.lineTo(i[2 * j], i[2 * j + 1]);
          }
          if (f.closed) {
            b.lineTo(i[0], i[1]);
          }
          if (i[0] === i[i.length - 2] && i[1] === i[i.length - 1]) {
            b.closePath();
          }
          if (e.fill) {
            b.globalAlpha = e.fillAlpha * c;
            b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6);
            b.fill();
          }
          if (e.lineWidth) {
            b.globalAlpha = e.lineAlpha * c;
            b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6);
            b.stroke();
          }
        } else if (e.type === PIXI.Graphics.RECT) {
          if (e.fillColor || 0 === e.fillColor) {
            b.globalAlpha = e.fillAlpha * c;
            b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6);
            b.fillRect(f.x, f.y, f.width, f.height);
          }
          if (e.lineWidth) {
            b.globalAlpha = e.lineAlpha * c;
            b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6);
            b.strokeRect(f.x, f.y, f.width, f.height);
          }
        } else if (e.type === PIXI.Graphics.CIRC) {
          b.beginPath();
          b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI);
          b.closePath();
          if (e.fill) {
            b.globalAlpha = e.fillAlpha * c;
            b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6);
            b.fill();
          }
          if (e.lineWidth) {
            b.globalAlpha = e.lineAlpha * c;
            b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6);
            b.stroke();
          }
        } else if (e.type === PIXI.Graphics.ELIP) {
          var k = 2 * f.width;
          var l = 2 * f.height;
          var m = f.x - k / 2;
          var n = f.y - l / 2;
          b.beginPath();
          var o = .5522848;
          var p = k / 2 * .5522848;
          var q = l / 2 * .5522848;
          var r = m + k;
          var s = n + l;
          var t = m + k / 2;
          var u = n + l / 2;
          b.moveTo(m, u);
          b.bezierCurveTo(m, u - q, t - p, n, t, n);
          b.bezierCurveTo(t + p, n, r, u - q, r, u);
          b.bezierCurveTo(r, u + q, t + p, s, t, s);
          b.bezierCurveTo(t - p, s, m, u + q, m, u);
          b.closePath();
          if (e.fill) {
            b.globalAlpha = e.fillAlpha * c;
            b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6);
            b.fill();
          }
          if (e.lineWidth) {
            b.globalAlpha = e.lineAlpha * c;
            b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6);
            b.stroke();
          }
        } else if (e.type === PIXI.Graphics.RREC) {
          var v = f.x;
          var w = f.y;
          var x = f.width;
          var y = f.height;
          var z = f.radius;
          var A = Math.min(x, y) / 2 | 0;
          z = z > A ? A : z;
          b.beginPath();
          b.moveTo(v, w + z);
          b.lineTo(v, w + y - z);
          b.quadraticCurveTo(v, w + y, v + z, w + y);
          b.lineTo(v + x - z, w + y);
          b.quadraticCurveTo(v + x, w + y, v + x, w + y - z);
          b.lineTo(v + x, w + z);
          b.quadraticCurveTo(v + x, w, v + x - z, w);
          b.lineTo(v + z, w);
          b.quadraticCurveTo(v, w, v, w + z);
          b.closePath();
          if (e.fillColor || 0 === e.fillColor) {
            b.globalAlpha = e.fillAlpha * c;
            b.fillStyle = "#" + ("00000" + (0 | g).toString(16)).substr(-6);
            b.fill();
          }
          if (e.lineWidth) {
            b.globalAlpha = e.lineAlpha * c;
            b.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6);
            b.stroke();
          }
        }
      }
    };
    PIXI.CanvasGraphics.renderGraphicsMask = function (a, b) {
      var c = a.graphicsData.length;
      if (0 !== c) {
        b.beginPath();
        for (var d = 0; d < c; d++) {
          var e = a.graphicsData[d];
          var f = e.shape;
          if (e.type === PIXI.Graphics.POLY) {
            var g = f.points;
            b.moveTo(g[0], g[1]);
            for (var h = 1; h < g.length / 2; h++) {
              b.lineTo(g[2 * h], g[2 * h + 1]);
            }
            if (g[0] === g[g.length - 2] && g[1] === g[g.length - 1]) {
              b.closePath();
            }
          } else if (e.type === PIXI.Graphics.RECT) {
            b.rect(f.x, f.y, f.width, f.height);
            b.closePath();
          } else if (e.type === PIXI.Graphics.CIRC) {
            b.arc(f.x, f.y, f.radius, 0, 2 * Math.PI);
            b.closePath();
          } else if (e.type === PIXI.Graphics.ELIP) {
            var i = 2 * f.width;
            var j = 2 * f.height;
            var k = f.x - i / 2;
            var l = f.y - j / 2;
            var m = .5522848;
            var n = i / 2 * .5522848;
            var o = j / 2 * .5522848;
            var p = k + i;
            var q = l + j;
            var r = k + i / 2;
            var s = l + j / 2;
            b.moveTo(k, s);
            b.bezierCurveTo(k, s - o, r - n, l, r, l);
            b.bezierCurveTo(r + n, l, p, s - o, p, s);
            b.bezierCurveTo(p, s + o, r + n, q, r, q);
            b.bezierCurveTo(r - n, q, k, s + o, k, s);
            b.closePath();
          } else if (e.type === PIXI.Graphics.RREC) {
            var t = f.x;
            var u = f.y;
            var v = f.width;
            var w = f.height;
            var x = f.radius;
            var y = Math.min(v, w) / 2 | 0;
            x = x > y ? y : x;
            b.moveTo(t, u + x);
            b.lineTo(t, u + w - x);
            b.quadraticCurveTo(t, u + w, t + x, u + w);
            b.lineTo(t + v - x, u + w);
            b.quadraticCurveTo(t + v, u + w, t + v, u + w - x);
            b.lineTo(t + v, u + x);
            b.quadraticCurveTo(t + v, u, t + v - x, u);
            b.lineTo(t + x, u);
            b.quadraticCurveTo(t, u, t, u + x);
            b.closePath();
          }
        }
      }
    };
    PIXI.CanvasGraphics.updateGraphicsTint = function (a) {
      if (16777215 !== a.tint) {
        var b = (a.tint >> 16 & 255) / 255;
        var c = (a.tint >> 8 & 255) / 255;
        var d = (255 & a.tint) / 255;
        for (var e = 0; e < a.graphicsData.length; e++) {
          var f = a.graphicsData[e];
          var g = 0 | f.fillColor;
          var h = 0 | f.lineColor;
          f._fillTint = ((g >> 16 & 255) / 255 * b * 255 << 16) + ((g >> 8 & 255) / 255 * c * 255 << 8) + (255 & g) / 255 * d * 255;
          f._lineTint = ((h >> 16 & 255) / 255 * b * 255 << 16) + ((h >> 8 & 255) / 255 * c * 255 << 8) + (255 & h) / 255 * d * 255;
        }
      }
    };
    b.Graphics = function (a, c, d) {
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = 0;
      }
      this.type = b.GRAPHICS;
      this.physicsType = b.SPRITE;
      this.anchor = new b.Point();
      PIXI.Graphics.call(this);
      b.Component.Core.init.call(this, a, c, d, "", null);
    };
    b.Graphics.prototype = Object.create(PIXI.Graphics.prototype);
    b.Graphics.prototype.constructor = b.Graphics;
    b.Component.Core.install.call(b.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]);
    b.Graphics.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate;
    b.Graphics.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate;
    b.Graphics.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.Graphics.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.Graphics.prototype.preUpdate = function () {
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.Graphics.prototype.postUpdate = function () {
      b.Component.PhysicsBody.postUpdate.call(this);
      b.Component.FixedToCamera.postUpdate.call(this);
      if (this._boundsDirty) {
        this.updateLocalBounds();
        this._boundsDirty = false;
      }
      for (var a = 0; a < this.children.length; a++) {
        this.children[a].postUpdate();
      }
    };
    b.Graphics.prototype.destroy = function (a) {
      this.clear();
      b.Component.Destroy.prototype.destroy.call(this, a);
    };
    b.Graphics.prototype.drawTriangle = function (a, c) {
      if (undefined === c) {
        c = false;
      }
      var d = new b.Polygon(a);
      if (c) {
        var e = new b.Point(this.game.camera.x - a[0].x, this.game.camera.y - a[0].y);
        var f = new b.Point(a[1].x - a[0].x, a[1].y - a[0].y);
        var g = new b.Point(a[1].x - a[2].x, a[1].y - a[2].y);
        var h = g.cross(f);
        if (e.dot(h) > 0) {
          this.drawPolygon(d);
        }
      } else {
        this.drawPolygon(d);
      }
    };
    b.Graphics.prototype.drawTriangles = function (a, c, d) {
      if (undefined === d) {
        d = false;
      }
      var i;
      var e = new b.Point();
      var f = new b.Point();
      var g = new b.Point();
      var h = [];
      if (c) {
        if (a[0] instanceof b.Point) {
          for (i = 0; i < c.length / 3; i++) {
            h.push(a[c[3 * i]]);
            h.push(a[c[3 * i + 1]]);
            h.push(a[c[3 * i + 2]]);
            if (3 === h.length) {
              this.drawTriangle(h, d);
              h = [];
            }
          }
        } else {
          for (i = 0; i < c.length; i++) {
            e.x = a[2 * c[i]];
            e.y = a[2 * c[i] + 1];
            h.push(e.copyTo({}));
            if (3 === h.length) {
              this.drawTriangle(h, d);
              h = [];
            }
          }
        }
      } else if (a[0] instanceof b.Point) {
        for (i = 0; i < a.length / 3; i++) {
          this.drawTriangle([a[3 * i], a[3 * i + 1], a[3 * i + 2]], d);
        }
      } else {
        for (i = 0; i < a.length / 6; i++) {
          e.x = a[6 * i + 0];
          e.y = a[6 * i + 1];
          f.x = a[6 * i + 2];
          f.y = a[6 * i + 3];
          g.x = a[6 * i + 4];
          g.y = a[6 * i + 5];
          this.drawTriangle([e, f, g], d);
        }
      }
    };
    b.RenderTexture = function (a, c, d, e, f, g) {
      if (undefined === e) {
        e = "";
      }
      if (undefined === f) {
        f = b.scaleModes.DEFAULT;
      }
      if (undefined === g) {
        g = 1;
      }
      this.game = a;
      this.key = e;
      this.type = b.RENDERTEXTURE;
      this._tempMatrix = new PIXI.Matrix();
      PIXI.RenderTexture.call(this, c, d, this.game.renderer, f, g);
      this.render = b.RenderTexture.prototype.render;
    };
    b.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);
    b.RenderTexture.prototype.constructor = b.RenderTexture;
    b.RenderTexture.prototype.renderXY = function (a, b, c, d) {
      a.updateTransform();
      this._tempMatrix.copyFrom(a.worldTransform);
      this._tempMatrix.tx = b;
      this._tempMatrix.ty = c;
      if (this.renderer.type === PIXI.WEBGL_RENDERER) {
        this.renderWebGL(a, this._tempMatrix, d);
      } else {
        this.renderCanvas(a, this._tempMatrix, d);
      }
    };
    b.RenderTexture.prototype.renderRawXY = function (a, b, c, d) {
      this._tempMatrix.identity().translate(b, c);
      if (this.renderer.type === PIXI.WEBGL_RENDERER) {
        this.renderWebGL(a, this._tempMatrix, d);
      } else {
        this.renderCanvas(a, this._tempMatrix, d);
      }
    };
    b.RenderTexture.prototype.render = function (a, b, c) {
      if (undefined === b || null === b) {
        this._tempMatrix.copyFrom(a.worldTransform);
      } else {
        this._tempMatrix.copyFrom(b);
      }
      if (this.renderer.type === PIXI.WEBGL_RENDERER) {
        this.renderWebGL(a, this._tempMatrix, c);
      } else {
        this.renderCanvas(a, this._tempMatrix, c);
      }
    };
    b.Text = function (a, c, d, e, f) {
      c = c || 0;
      d = d || 0;
      e = undefined === e || null === e ? "" : e.toString();
      f = b.Utils.extend({}, f);
      this.type = b.TEXT;
      this.physicsType = b.SPRITE;
      this.padding = new b.Point();
      this.textBounds = null;
      this.canvas = PIXI.CanvasPool.create(this);
      this.context = this.canvas.getContext("2d");
      this.colors = [];
      this.strokeColors = [];
      this.fontStyles = [];
      this.fontWeights = [];
      this.autoRound = false;
      this.useAdvancedWrap = false;
      this._res = a.renderer.resolution;
      this._text = e;
      this._fontComponents = null;
      this._lineSpacing = 0;
      this._charCount = 0;
      this._width = 0;
      this._height = 0;
      b.Sprite.call(this, a, c, d, PIXI.Texture.fromCanvas(this.canvas));
      this.setStyle(f);
      if ("" !== e) {
        this.updateText();
      }
    };
    b.Text.prototype = Object.create(b.Sprite.prototype);
    b.Text.prototype.constructor = b.Text;
    b.Text.prototype.preUpdate = function () {
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.Text.prototype.update = function () {};
    b.Text.prototype.destroy = function (a) {
      this.texture.destroy(true);
      b.Component.Destroy.prototype.destroy.call(this, a);
    };
    b.Text.prototype.setShadow = function (a, b, c, d, e, f) {
      if (undefined === a) {
        a = 0;
      }
      if (undefined === b) {
        b = 0;
      }
      if (undefined === c) {
        c = "rgba(0, 0, 0, 1)";
      }
      if (undefined === d) {
        d = 0;
      }
      if (undefined === e) {
        e = true;
      }
      if (undefined === f) {
        f = true;
      }
      this.style.shadowOffsetX = a;
      this.style.shadowOffsetY = b;
      this.style.shadowColor = c;
      this.style.shadowBlur = d;
      this.style.shadowStroke = e;
      this.style.shadowFill = f;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.setStyle = function (a, b) {
      if (undefined === b) {
        b = false;
      }
      a = a || {};
      a.font = a.font || "bold 20pt Arial";
      a.backgroundColor = a.backgroundColor || null;
      a.fill = a.fill || "black";
      a.align = a.align || "left";
      a.boundsAlignH = a.boundsAlignH || "left";
      a.boundsAlignV = a.boundsAlignV || "top";
      a.stroke = a.stroke || "black";
      a.strokeThickness = a.strokeThickness || 0;
      a.wordWrap = a.wordWrap || false;
      a.wordWrapWidth = a.wordWrapWidth || 100;
      a.maxLines = a.maxLines || 0;
      a.shadowOffsetX = a.shadowOffsetX || 0;
      a.shadowOffsetY = a.shadowOffsetY || 0;
      a.shadowColor = a.shadowColor || "rgba(0,0,0,0)";
      a.shadowBlur = a.shadowBlur || 0;
      a.tabs = a.tabs || 0;
      var c = this.fontToComponents(a.font);
      if (a.fontStyle) {
        c.fontStyle = a.fontStyle;
      }
      if (a.fontVariant) {
        c.fontVariant = a.fontVariant;
      }
      if (a.fontWeight) {
        c.fontWeight = a.fontWeight;
      }
      if (a.fontSize) {
        if ("number" == typeof a.fontSize) {
          a.fontSize = a.fontSize + "px";
        }
        c.fontSize = a.fontSize;
      }
      this._fontComponents = c;
      a.font = this.componentsToFont(this._fontComponents);
      this.style = a;
      this.dirty = true;
      if (b) {
        this.updateText();
      }
      return this;
    };
    b.Text.prototype.updateText = function () {
      this.texture.baseTexture.resolution = this._res;
      this.context.font = this.style.font;
      var a = this.text;
      if (this.style.wordWrap) {
        a = this.runWordWrap(this.text);
      }
      var b = a.split(/(?:\r\n|\r|\n)/);
      var c = this.style.tabs;
      var d = [];
      var e = 0;
      var f = this.determineFontProperties(this.style.font);
      var g = b.length;
      if (this.style.maxLines > 0 && this.style.maxLines < b.length) {
        g = this.style.maxLines;
      }
      this._charCount = 0;
      for (var h = 0; h < g; h++) {
        if (0 === c) {
          var i = this.style.strokeThickness + this.padding.x;
          if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) {
            i += this.measureLine(b[h]);
          } else {
            i += this.context.measureText(b[h]).width;
          }
          if (this.style.wordWrap) {
            i -= this.context.measureText(" ").width;
          }
        } else {
          var j = b[h].split(/(?:\t)/);
          var i = this.padding.x + this.style.strokeThickness;
          if (Array.isArray(c)) {
            var k = 0;
            for (var l = 0; l < j.length; l++) {
              var m = 0;
              m = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width);
              if (l > 0) {
                k += c[l - 1];
              }
              i = k + m;
            }
          } else {
            for (var l = 0; l < j.length; l++) {
              if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                i += this.measureLine(j[l]);
              } else {
                i += Math.ceil(this.context.measureText(j[l]).width);
              }
              var n = this.game.math.snapToCeil(i, c) - i;
              i += n;
            }
          }
        }
        d[h] = Math.ceil(i);
        e = Math.max(e, d[h]);
      }
      this.canvas.width = e * this._res;
      var o = f.fontSize + this.style.strokeThickness + this.padding.y;
      var p = o * g;
      var q = this._lineSpacing;
      if (q < 0 && Math.abs(q) > o) {
        q = -o;
      }
      if (0 !== q) {
        p += q > 0 ? q * b.length : q * (b.length - 1);
      }
      this.canvas.height = p * this._res;
      this.context.scale(this._res, this._res);
      if (navigator.isCocoonJS) {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
      if (this.style.backgroundColor) {
        this.context.fillStyle = this.style.backgroundColor;
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      this.context.fillStyle = this.style.fill;
      this.context.font = this.style.font;
      this.context.strokeStyle = this.style.stroke;
      this.context.textBaseline = "alphabetic";
      this.context.lineWidth = this.style.strokeThickness;
      this.context.lineCap = "round";
      this.context.lineJoin = "round";
      var r;
      var s;
      this._charCount = 0;
      for (h = 0; h < g; h++) {
        r = this.style.strokeThickness / 2;
        s = this.style.strokeThickness / 2 + h * o + f.ascent;
        if (h > 0) {
          s += q * h;
        }
        if ("right" === this.style.align) {
          r += e - d[h];
        } else if ("center" === this.style.align) {
          r += (e - d[h]) / 2;
        }
        if (this.autoRound) {
          r = Math.round(r);
          s = Math.round(s);
        }
        if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) {
          this.updateLine(b[h], r, s);
        } else {
          if (this.style.stroke && this.style.strokeThickness) {
            this.updateShadow(this.style.shadowStroke);
            if (0 === c) {
              this.context.strokeText(b[h], r, s);
            } else {
              this.renderTabLine(b[h], r, s, false);
            }
          }
          if (this.style.fill) {
            this.updateShadow(this.style.shadowFill);
            if (0 === c) {
              this.context.fillText(b[h], r, s);
            } else {
              this.renderTabLine(b[h], r, s, true);
            }
          }
        }
      }
      this.updateTexture();
      this.dirty = false;
    };
    b.Text.prototype.renderTabLine = function (a, b, c, d) {
      var e = a.split(/(?:\t)/);
      var f = this.style.tabs;
      var g = 0;
      if (Array.isArray(f)) {
        var h = 0;
        for (var i = 0; i < e.length; i++) {
          if (i > 0) {
            h += f[i - 1];
          }
          g = b + h;
          if (d) {
            this.context.fillText(e[i], g, c);
          } else {
            this.context.strokeText(e[i], g, c);
          }
        }
      } else {
        for (var i = 0; i < e.length; i++) {
          var j = Math.ceil(this.context.measureText(e[i]).width);
          g = this.game.math.snapToCeil(b, f);
          if (d) {
            this.context.fillText(e[i], g, c);
          } else {
            this.context.strokeText(e[i], g, c);
          }
          b = g + j;
        }
      }
    };
    b.Text.prototype.updateShadow = function (a) {
      if (a) {
        this.context.shadowOffsetX = this.style.shadowOffsetX;
        this.context.shadowOffsetY = this.style.shadowOffsetY;
        this.context.shadowColor = this.style.shadowColor;
        this.context.shadowBlur = this.style.shadowBlur;
      } else {
        this.context.shadowOffsetX = 0;
        this.context.shadowOffsetY = 0;
        this.context.shadowColor = 0;
        this.context.shadowBlur = 0;
      }
    };
    b.Text.prototype.measureLine = function (a) {
      var b = 0;
      for (var c = 0; c < a.length; c++) {
        var d = a[c];
        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
          var e = this.fontToComponents(this.context.font);
          if (this.fontStyles[this._charCount]) {
            e.fontStyle = this.fontStyles[this._charCount];
          }
          if (this.fontWeights[this._charCount]) {
            e.fontWeight = this.fontWeights[this._charCount];
          }
          this.context.font = this.componentsToFont(e);
        }
        if (this.style.stroke && this.style.strokeThickness) {
          if (this.strokeColors[this._charCount]) {
            this.context.strokeStyle = this.strokeColors[this._charCount];
          }
          this.updateShadow(this.style.shadowStroke);
        }
        if (this.style.fill) {
          if (this.colors[this._charCount]) {
            this.context.fillStyle = this.colors[this._charCount];
          }
          this.updateShadow(this.style.shadowFill);
        }
        b += this.context.measureText(d).width;
        this._charCount++;
      }
      return Math.ceil(b);
    };
    b.Text.prototype.updateLine = function (a, b, c) {
      for (var d = 0; d < a.length; d++) {
        var e = a[d];
        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
          var f = this.fontToComponents(this.context.font);
          if (this.fontStyles[this._charCount]) {
            f.fontStyle = this.fontStyles[this._charCount];
          }
          if (this.fontWeights[this._charCount]) {
            f.fontWeight = this.fontWeights[this._charCount];
          }
          this.context.font = this.componentsToFont(f);
        }
        if (this.style.stroke && this.style.strokeThickness) {
          if (this.strokeColors[this._charCount]) {
            this.context.strokeStyle = this.strokeColors[this._charCount];
          }
          this.updateShadow(this.style.shadowStroke);
          this.context.strokeText(e, b, c);
        }
        if (this.style.fill) {
          if (this.colors[this._charCount]) {
            this.context.fillStyle = this.colors[this._charCount];
          }
          this.updateShadow(this.style.shadowFill);
          this.context.fillText(e, b, c);
        }
        b += this.context.measureText(e).width;
        this._charCount++;
      }
    };
    b.Text.prototype.clearColors = function () {
      this.colors = [];
      this.strokeColors = [];
      this.dirty = true;
      return this;
    };
    b.Text.prototype.clearFontValues = function () {
      this.fontStyles = [];
      this.fontWeights = [];
      this.dirty = true;
      return this;
    };
    b.Text.prototype.addColor = function (a, b) {
      this.colors[b] = a;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.addStrokeColor = function (a, b) {
      this.strokeColors[b] = a;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.addFontStyle = function (a, b) {
      this.fontStyles[b] = a;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.addFontWeight = function (a, b) {
      this.fontWeights[b] = a;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.precalculateWordWrap = function (a) {
      this.texture.baseTexture.resolution = this._res;
      this.context.font = this.style.font;
      return this.runWordWrap(a).split(/(?:\r\n|\r|\n)/);
    };
    b.Text.prototype.runWordWrap = function (a) {
      return this.useAdvancedWrap ? this.advancedWordWrap(a) : this.basicWordWrap(a);
    };
    b.Text.prototype.advancedWordWrap = function (a) {
      var b = this.context;
      var c = this.style.wordWrapWidth;
      var d = "";
      var e = a.replace(/ +/gi, " ").split(/\r?\n/gi);
      var f = e.length;
      for (var g = 0; g < f; g++) {
        var h = e[g];
        var i = "";
        h = h.replace(/^ *|\s*$/gi, "");
        if (b.measureText(h).width < c) {
          d += h + "\n";
        } else {
          var k = c;
          var l = h.split(" ");
          for (var m = 0; m < l.length; m++) {
            var n = l[m];
            var o = n + " ";
            var p = b.measureText(o).width;
            if (p > k) {
              if (0 === m) {
                for (var q = o; q.length && (q = q.slice(0, -1), !((p = b.measureText(q).width) <= k));) {
                  ;
                }
                if (!q.length) {
                  throw new Error("This text's wordWrapWidth setting is less than a single character!");
                }
                var r = n.substr(q.length);
                l[m] = r;
                i += q;
              }
              var s = l[m].length ? m : m + 1;
              var t = l.slice(s).join(" ").replace(/[ \n]*$/gi, "");
              e[g + 1] = t + " " + (e[g + 1] || "");
              f = e.length;
              break;
            }
            i += o;
            k -= p;
          }
          d += i.replace(/[ \n]*$/gi, "") + "\n";
        }
      }
      return d = d.replace(/[\s|\n]*$/gi, "");
    };
    b.Text.prototype.basicWordWrap = function (a) {
      var b = "";
      var c = a.split("\n");
      for (var d = 0; d < c.length; d++) {
        var e = this.style.wordWrapWidth;
        var f = c[d].split(" ");
        for (var g = 0; g < f.length; g++) {
          var h = this.context.measureText(f[g]).width;
          var i = h + this.context.measureText(" ").width;
          if (i > e) {
            if (g > 0) {
              b += "\n";
            }
            b += f[g] + " ";
            e = this.style.wordWrapWidth - h;
          } else {
            e -= i;
            b += f[g] + " ";
          }
        }
        if (d < c.length - 1) {
          b += "\n";
        }
      }
      return b;
    };
    b.Text.prototype.updateFont = function (a) {
      var b = this.componentsToFont(a);
      if (this.style.font !== b) {
        this.style.font = b;
        this.dirty = true;
        if (this.parent) {
          this.updateTransform();
        }
      }
    };
    b.Text.prototype.fontToComponents = function (a) {
      var b = a.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
      if (b) {
        var c = b[5].trim();
        if (!(/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(c) || /['",]/.exec(c))) {
          c = "'" + c + "'";
        }
        return {
          font: a,
          fontStyle: b[1] || "normal",
          fontVariant: b[2] || "normal",
          fontWeight: b[3] || "normal",
          fontSize: b[4] || "medium",
          fontFamily: c
        };
      }
      console.warn("Phaser.Text - unparsable CSS font: " + a);
      return {
        font: a
      };
    };
    b.Text.prototype.componentsToFont = function (a) {
      var c;
      var b = [];
      c = a.fontStyle;
      if (c && "normal" !== c) {
        b.push(c);
      }
      c = a.fontVariant;
      if (c && "normal" !== c) {
        b.push(c);
      }
      c = a.fontWeight;
      if (c && "normal" !== c) {
        b.push(c);
      }
      c = a.fontSize;
      if (c && "medium" !== c) {
        b.push(c);
      }
      c = a.fontFamily;
      if (c) {
        b.push(c);
      }
      if (!b.length) {
        b.push(a.font);
      }
      return b.join(" ");
    };
    b.Text.prototype.setText = function (a, b) {
      if (undefined === b) {
        b = false;
      }
      this.text = a.toString() || "";
      if (b) {
        this.updateText();
      } else {
        this.dirty = true;
      }
      return this;
    };
    b.Text.prototype.parseList = function (a) {
      if (!Array.isArray(a)) {
        return this;
      }
      var b = "";
      for (var c = 0; c < a.length; c++) {
        if (Array.isArray(a[c])) {
          b += a[c].join("\t");
          if (c < a.length - 1) {
            b += "\n";
          }
        } else {
          b += a[c];
          if (c < a.length - 1) {
            b += "\t";
          }
        }
      }
      this.text = b;
      this.dirty = true;
      return this;
    };
    b.Text.prototype.setTextBounds = function (a, c, d, e) {
      if (undefined === a) {
        this.textBounds = null;
      } else {
        if (this.textBounds) {
          this.textBounds.setTo(a, c, d, e);
        } else {
          this.textBounds = new b.Rectangle(a, c, d, e);
        }
        if (this.style.wordWrapWidth > d) {
          this.style.wordWrapWidth = d;
        }
      }
      this.updateTexture();
      return this;
    };
    b.Text.prototype.updateTexture = function () {
      var a = this.texture.baseTexture;
      var b = this.texture.crop;
      var c = this.texture.frame;
      var d = this.canvas.width;
      var e = this.canvas.height;
      a.width = d;
      a.height = e;
      b.width = d;
      b.height = e;
      c.width = d;
      c.height = e;
      this.texture.width = d;
      this.texture.height = e;
      this._width = d;
      this._height = e;
      if (this.textBounds) {
        var f = this.textBounds.x;
        var g = this.textBounds.y;
        if ("right" === this.style.boundsAlignH) {
          f += this.textBounds.width - this.canvas.width / this.resolution;
        } else if ("center" === this.style.boundsAlignH) {
          f += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2;
        }
        if ("bottom" === this.style.boundsAlignV) {
          g += this.textBounds.height - this.canvas.height / this.resolution;
        } else if ("middle" === this.style.boundsAlignV) {
          g += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2;
        }
        this.pivot.x = -f;
        this.pivot.y = -g;
      }
      this.renderable = 0 !== d && 0 !== e;
      this.texture.requiresReTint = true;
      this.texture.baseTexture.dirty();
    };
    b.Text.prototype._renderWebGL = function (a) {
      if (this.dirty) {
        this.updateText();
        this.dirty = false;
      }
      PIXI.Sprite.prototype._renderWebGL.call(this, a);
    };
    b.Text.prototype._renderCanvas = function (a) {
      if (this.dirty) {
        this.updateText();
        this.dirty = false;
      }
      PIXI.Sprite.prototype._renderCanvas.call(this, a);
    };
    b.Text.prototype.determineFontProperties = function (a) {
      var c = b.Text.fontPropertiesCache[a];
      if (!c) {
        c = {};
        var d = b.Text.fontPropertiesCanvas;
        var e = b.Text.fontPropertiesContext;
        e.font = a;
        var f = Math.ceil(e.measureText("|Mq").width);
        var g = Math.ceil(e.measureText("|Mq").width);
        var h = 2 * g;
        g = 1.4 * g | 0;
        d.width = f;
        d.height = h;
        e.fillStyle = "#f00";
        e.fillRect(0, 0, f, h);
        e.font = a;
        e.textBaseline = "alphabetic";
        e.fillStyle = "#000";
        e.fillText("|Mq", 0, g);
        if (!e.getImageData(0, 0, f, h)) {
          c.ascent = g;
          c.descent = g + 6;
          c.fontSize = c.ascent + c.descent;
          b.Text.fontPropertiesCache[a] = c;
          return c;
        }
        var l;
        var m;
        var i = e.getImageData(0, 0, f, h).data;
        var j = i.length;
        var k = 4 * f;
        var n = 0;
        var o = false;
        for (l = 0; l < g; l++) {
          for (m = 0; m < k; m += 4) {
            if (255 !== i[n + m]) {
              o = true;
              break;
            }
          }
          if (o) {
            break;
          }
          n += k;
        }
        c.ascent = g - l;
        n = j - k;
        o = false;
        for (l = h; l > g; l--) {
          for (m = 0; m < k; m += 4) {
            if (255 !== i[n + m]) {
              o = true;
              break;
            }
          }
          if (o) {
            break;
          }
          n -= k;
        }
        c.descent = l - g;
        c.descent += 6;
        c.fontSize = c.ascent + c.descent;
        b.Text.fontPropertiesCache[a] = c;
      }
      return c;
    };
    b.Text.prototype.getBounds = function (a) {
      if (this.dirty) {
        this.updateText();
        this.dirty = false;
      }
      return PIXI.Sprite.prototype.getBounds.call(this, a);
    };
    Object.defineProperty(b.Text.prototype, "text", {
      get: function () {
        return this._text;
      },
      set: function (a) {
        if (a !== this._text) {
          this._text = a.toString() || "";
          this.dirty = true;
          if (this.parent) {
            this.updateTransform();
          }
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "cssFont", {
      get: function () {
        return this.componentsToFont(this._fontComponents);
      },
      set: function (a) {
        a = a || "bold 20pt Arial";
        this._fontComponents = this.fontToComponents(a);
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "font", {
      get: function () {
        return this._fontComponents.fontFamily;
      },
      set: function (a) {
        a = a || "Arial";
        a = a.trim();
        if (!(/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(a) || /['",]/.exec(a))) {
          a = "'" + a + "'";
        }
        this._fontComponents.fontFamily = a;
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "fontSize", {
      get: function () {
        var a = this._fontComponents.fontSize;
        return a && /(?:^0$|px$)/.exec(a) ? parseInt(a, 10) : a;
      },
      set: function (a) {
        a = a || "0";
        if ("number" == typeof a) {
          a += "px";
        }
        this._fontComponents.fontSize = a;
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "fontWeight", {
      get: function () {
        return this._fontComponents.fontWeight || "normal";
      },
      set: function (a) {
        a = a || "normal";
        this._fontComponents.fontWeight = a;
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "fontStyle", {
      get: function () {
        return this._fontComponents.fontStyle || "normal";
      },
      set: function (a) {
        a = a || "normal";
        this._fontComponents.fontStyle = a;
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "fontVariant", {
      get: function () {
        return this._fontComponents.fontVariant || "normal";
      },
      set: function (a) {
        a = a || "normal";
        this._fontComponents.fontVariant = a;
        this.updateFont(this._fontComponents);
      }
    });
    Object.defineProperty(b.Text.prototype, "fill", {
      get: function () {
        return this.style.fill;
      },
      set: function (a) {
        if (a !== this.style.fill) {
          this.style.fill = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "align", {
      get: function () {
        return this.style.align;
      },
      set: function (a) {
        if (a !== this.style.align) {
          this.style.align = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "resolution", {
      get: function () {
        return this._res;
      },
      set: function (a) {
        if (a !== this._res) {
          this._res = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "tabs", {
      get: function () {
        return this.style.tabs;
      },
      set: function (a) {
        if (a !== this.style.tabs) {
          this.style.tabs = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "boundsAlignH", {
      get: function () {
        return this.style.boundsAlignH;
      },
      set: function (a) {
        if (a !== this.style.boundsAlignH) {
          this.style.boundsAlignH = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "boundsAlignV", {
      get: function () {
        return this.style.boundsAlignV;
      },
      set: function (a) {
        if (a !== this.style.boundsAlignV) {
          this.style.boundsAlignV = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "stroke", {
      get: function () {
        return this.style.stroke;
      },
      set: function (a) {
        if (a !== this.style.stroke) {
          this.style.stroke = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "strokeThickness", {
      get: function () {
        return this.style.strokeThickness;
      },
      set: function (a) {
        if (a !== this.style.strokeThickness) {
          this.style.strokeThickness = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "wordWrap", {
      get: function () {
        return this.style.wordWrap;
      },
      set: function (a) {
        if (a !== this.style.wordWrap) {
          this.style.wordWrap = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "wordWrapWidth", {
      get: function () {
        return this.style.wordWrapWidth;
      },
      set: function (a) {
        if (a !== this.style.wordWrapWidth) {
          this.style.wordWrapWidth = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "lineSpacing", {
      get: function () {
        return this._lineSpacing;
      },
      set: function (a) {
        if (a !== this._lineSpacing) {
          this._lineSpacing = parseFloat(a);
          this.dirty = true;
          if (this.parent) {
            this.updateTransform();
          }
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowOffsetX", {
      get: function () {
        return this.style.shadowOffsetX;
      },
      set: function (a) {
        if (a !== this.style.shadowOffsetX) {
          this.style.shadowOffsetX = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowOffsetY", {
      get: function () {
        return this.style.shadowOffsetY;
      },
      set: function (a) {
        if (a !== this.style.shadowOffsetY) {
          this.style.shadowOffsetY = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowColor", {
      get: function () {
        return this.style.shadowColor;
      },
      set: function (a) {
        if (a !== this.style.shadowColor) {
          this.style.shadowColor = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowBlur", {
      get: function () {
        return this.style.shadowBlur;
      },
      set: function (a) {
        if (a !== this.style.shadowBlur) {
          this.style.shadowBlur = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowStroke", {
      get: function () {
        return this.style.shadowStroke;
      },
      set: function (a) {
        if (a !== this.style.shadowStroke) {
          this.style.shadowStroke = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "shadowFill", {
      get: function () {
        return this.style.shadowFill;
      },
      set: function (a) {
        if (a !== this.style.shadowFill) {
          this.style.shadowFill = a;
          this.dirty = true;
        }
      }
    });
    Object.defineProperty(b.Text.prototype, "width", {
      get: function () {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
        return this.scale.x * this.texture.frame.width;
      },
      set: function (a) {
        this.scale.x = a / this.texture.frame.width;
        this._width = a;
      }
    });
    Object.defineProperty(b.Text.prototype, "height", {
      get: function () {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
        return this.scale.y * this.texture.frame.height;
      },
      set: function (a) {
        this.scale.y = a / this.texture.frame.height;
        this._height = a;
      }
    });
    b.Text.fontPropertiesCache = {};
    b.Text.fontPropertiesCanvas = document.createElement("canvas");
    b.Text.fontPropertiesContext = b.Text.fontPropertiesCanvas.getContext("2d");
    b.BitmapText = function (a, c, d, e, f, g, h) {
      c = c || 0;
      d = d || 0;
      e = e || "";
      f = f || "";
      g = g || 32;
      h = h || "left";
      PIXI.DisplayObjectContainer.call(this);
      this.type = b.BITMAPTEXT;
      this.physicsType = b.SPRITE;
      this.textWidth = 0;
      this.textHeight = 0;
      this.anchor = new b.Point();
      this._prevAnchor = new b.Point();
      this._glyphs = [];
      this._maxWidth = 0;
      this._text = f.toString() || "";
      this._data = a.cache.getBitmapFont(e);
      this._font = e;
      this._fontSize = g;
      this._align = h;
      this._tint = 16777215;
      this.updateText();
      this.dirty = false;
      b.Component.Core.init.call(this, a, c, d, "", null);
    };
    b.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
    b.BitmapText.prototype.constructor = b.BitmapText;
    b.Component.Core.install.call(b.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]);
    b.BitmapText.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate;
    b.BitmapText.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate;
    b.BitmapText.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.BitmapText.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.BitmapText.prototype.preUpdate = function () {
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.BitmapText.prototype.postUpdate = function () {
      b.Component.PhysicsBody.postUpdate.call(this);
      b.Component.FixedToCamera.postUpdate.call(this);
      if (this.body && this.body.type === b.Physics.ARCADE) {
        if (!(this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight)) {
          this.body.setSize(this.textWidth, this.textHeight);
        }
      }
    };
    b.BitmapText.prototype.setText = function (a) {
      this.text = a;
    };
    b.BitmapText.prototype.scanLine = function (a, b, c) {
      var d = 0;
      var e = 0;
      var f = -1;
      var g = 0;
      var h = null;
      var i = this._maxWidth > 0 ? this._maxWidth : null;
      var j = [];
      for (var k = 0; k < c.length; k++) {
        var l = k === c.length - 1;
        if (/(?:\r\n|\r|\n)/.test(c.charAt(k))) {
          return {
            width: e,
            text: c.substr(0, k),
            end: l,
            chars: j
          };
        }
        var m = c.charCodeAt(k);
        var n = a.chars[m];
        var o = 0;
        if (undefined === n) {
          m = 32;
          n = a.chars[m];
        }
        var p = h && n.kerning[h] ? n.kerning[h] : 0;
        if (/(\s)/.test(c.charAt(k))) {
          f = k;
          g = e;
        }
        o = (p + n.texture.width + n.xOffset) * b;
        if (i && e + o >= i && f > -1) {
          return {
            width: g || e,
            text: c.substr(0, k - (k - f)),
            end: l,
            chars: j
          };
        }
        e += (n.xAdvance + p) * b;
        j.push(d + (n.xOffset + p) * b);
        d += (n.xAdvance + p) * b;
        h = m;
      }
      return {
        width: e,
        text: c,
        end: l,
        chars: j
      };
    };
    b.BitmapText.prototype.cleanText = function (a, b) {
      if (undefined === b) {
        b = "";
      }
      var c = this._data.font;
      if (!c) {
        return "";
      }
      var e = a.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n");
      for (var f = 0; f < e.length; f++) {
        var g = "";
        var h = e[f];
        for (var i = 0; i < h.length; i++) {
          g = c.chars[h.charCodeAt(i)] ? g.concat(h[i]) : g.concat(b);
        }
        e[f] = g;
      }
      return e.join("\n");
    };
    b.BitmapText.prototype.updateText = function () {
      var a = this._data.font;
      if (a) {
        var b = this.text;
        var c = this._fontSize / a.size;
        var d = [];
        var e = 0;
        this.textWidth = 0;
        do {
          var f = this.scanLine(a, c, b);
          f.y = e;
          d.push(f);
          if (f.width > this.textWidth) {
            this.textWidth = f.width;
          }
          e += a.lineHeight * c;
          b = b.substr(f.text.length + 1);
        } while (false === f.end);
        this.textHeight = e;
        var g = 0;
        var h = 0;
        var i = this.textWidth * this.anchor.x;
        var j = this.textHeight * this.anchor.y;
        for (var k = 0; k < d.length; k++) {
          var f = d[k];
          if ("right" === this._align) {
            h = this.textWidth - f.width;
          } else if ("center" === this._align) {
            h = (this.textWidth - f.width) / 2;
          }
          for (var l = 0; l < f.text.length; l++) {
            var m = f.text.charCodeAt(l);
            var n = a.chars[m];
            if (undefined === n) {
              m = 32;
              n = a.chars[m];
            }
            var o = this._glyphs[g];
            if (o) {
              o.texture = n.texture;
            } else {
              o = new PIXI.Sprite(n.texture);
              o.name = f.text[l];
              this._glyphs.push(o);
            }
            o.position.x = f.chars[l] + h - i;
            o.position.y = f.y + n.yOffset * c - j;
            o.scale.set(c);
            o.tint = this.tint;
            o.texture.requiresReTint = true;
            if (!o.parent) {
              this.addChild(o);
            }
            g++;
          }
        }
        for (k = g; k < this._glyphs.length; k++) {
          this.removeChild(this._glyphs[k]);
        }
      }
    };
    b.BitmapText.prototype.purgeGlyphs = function () {
      var a = this._glyphs.length;
      var b = [];
      for (var c = 0; c < this._glyphs.length; c++) {
        if (this._glyphs[c].parent !== this) {
          this._glyphs[c].destroy();
        } else {
          b.push(this._glyphs[c]);
        }
      }
      this._glyphs = [];
      this._glyphs = b;
      this.updateText();
      return a - b.length;
    };
    b.BitmapText.prototype.updateTransform = function () {
      if (!(!this.dirty && this.anchor.equals(this._prevAnchor))) {
        this.updateText();
        this.dirty = false;
        this._prevAnchor.copyFrom(this.anchor);
      }
      PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
    };
    Object.defineProperty(b.BitmapText.prototype, "align", {
      get: function () {
        return this._align;
      },
      set: function (a) {
        if (!(a === this._align || "left" !== a && "center" !== a && "right" !== a)) {
          this._align = a;
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "tint", {
      get: function () {
        return this._tint;
      },
      set: function (a) {
        if (a !== this._tint) {
          this._tint = a;
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "font", {
      get: function () {
        return this._font;
      },
      set: function (a) {
        if (a !== this._font) {
          this._font = a.trim();
          this._data = this.game.cache.getBitmapFont(this._font);
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "fontSize", {
      get: function () {
        return this._fontSize;
      },
      set: function (a) {
        if ((a = parseInt(a, 10)) !== this._fontSize && a > 0) {
          this._fontSize = a;
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "text", {
      get: function () {
        return this._text;
      },
      set: function (a) {
        if (a !== this._text) {
          this._text = a.toString() || "";
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "maxWidth", {
      get: function () {
        return this._maxWidth;
      },
      set: function (a) {
        if (a !== this._maxWidth) {
          this._maxWidth = a;
          this.updateText();
        }
      }
    });
    Object.defineProperty(b.BitmapText.prototype, "smoothed", {
      get: function () {
        return !this._data.base.scaleMode;
      },
      set: function (a) {
        this._data.base.scaleMode = a ? 0 : 1;
      }
    });
    b.RetroFont = function (a, c, d, e, f, g, h, i, j, k) {
      if (!a.cache.checkImageKey(c)) {
        return false;
      }
      if (!(undefined !== g && null !== g)) {
        g = a.cache.getImage(c).width / d;
      }
      this.characterWidth = d;
      this.characterHeight = e;
      this.characterSpacingX = h || 0;
      this.characterSpacingY = i || 0;
      this.characterPerRow = g;
      this.offsetX = j || 0;
      this.offsetY = k || 0;
      this.align = "left";
      this.multiLine = false;
      this.autoUpperCase = true;
      this.customSpacingX = 0;
      this.customSpacingY = 0;
      this.fixedWidth = 0;
      this.fontSet = a.cache.getImage(c);
      this._text = "";
      this.grabData = [];
      this.frameData = new b.FrameData();
      var l = this.offsetX;
      var m = this.offsetY;
      var n = 0;
      for (var o = 0; o < f.length; o++) {
        var p = this.frameData.addFrame(new b.Frame(o, l, m, this.characterWidth, this.characterHeight));
        this.grabData[f.charCodeAt(o)] = p.index;
        n++;
        if (n === this.characterPerRow) {
          n = 0;
          l = this.offsetX;
          m += this.characterHeight + this.characterSpacingY;
        } else {
          l += this.characterWidth + this.characterSpacingX;
        }
      }
      a.cache.updateFrameData(c, this.frameData);
      this.stamp = new b.Image(a, 0, 0, c, 0);
      b.RenderTexture.call(this, a, 100, 100, "", b.scaleModes.NEAREST);
      this.type = b.RETROFONT;
    };
    b.RetroFont.prototype = Object.create(b.RenderTexture.prototype);
    b.RetroFont.prototype.constructor = b.RetroFont;
    b.RetroFont.ALIGN_LEFT = "left";
    b.RetroFont.ALIGN_RIGHT = "right";
    b.RetroFont.ALIGN_CENTER = "center";
    b.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
    b.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    b.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    b.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789";
    b.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789";
    b.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ";
    b.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39";
    b.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    b.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!";
    b.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    b.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789";
    b.RetroFont.prototype.setFixedWidth = function (a, b) {
      if (undefined === b) {
        b = "left";
      }
      this.fixedWidth = a;
      this.align = b;
    };
    b.RetroFont.prototype.setText = function (a, b, c, d, e, f) {
      this.multiLine = b || false;
      this.customSpacingX = c || 0;
      this.customSpacingY = d || 0;
      this.align = e || "left";
      this.autoUpperCase = !f;
      if (a.length > 0) {
        this.text = a;
      }
    };
    b.RetroFont.prototype.buildRetroFontText = function () {
      var a = 0;
      var c = 0;
      this.clear();
      if (this.multiLine) {
        var d = this._text.split("\n");
        if (this.fixedWidth > 0) {
          this.resize(this.fixedWidth, d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
        } else {
          this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), d.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
        }
        for (var e = 0; e < d.length; e++) {
          a = 0;
          if (this.align === b.RetroFont.ALIGN_RIGHT) {
            a = this.width - d[e].length * (this.characterWidth + this.customSpacingX);
          } else if (this.align === b.RetroFont.ALIGN_CENTER) {
            a = this.width / 2 - d[e].length * (this.characterWidth + this.customSpacingX) / 2;
            a += this.customSpacingX / 2;
          }
          if (a < 0) {
            a = 0;
          }
          this.pasteLine(d[e], a, c, this.customSpacingX);
          c += this.characterHeight + this.customSpacingY;
        }
      } else {
        if (this.fixedWidth > 0) {
          this.resize(this.fixedWidth, this.characterHeight, true);
        } else {
          this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true);
        }
        a = 0;
        if (this.align === b.RetroFont.ALIGN_RIGHT) {
          a = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
        } else if (this.align === b.RetroFont.ALIGN_CENTER) {
          a = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
          a += this.customSpacingX / 2;
        }
        if (a < 0) {
          a = 0;
        }
        this.pasteLine(this._text, a, 0, this.customSpacingX);
      }
      this.requiresReTint = true;
    };
    b.RetroFont.prototype.pasteLine = function (a, b, c, d) {
      for (var e = 0; e < a.length; e++) {
        if (" " === a.charAt(e)) {
          b += this.characterWidth + d;
        } else if (this.grabData[a.charCodeAt(e)] >= 0 && (this.stamp.frame = this.grabData[a.charCodeAt(e)], this.renderXY(this.stamp, b, c, false), (b += this.characterWidth + d) > this.width)) {
          break;
        }
      }
    };
    b.RetroFont.prototype.getLongestLine = function () {
      var a = 0;
      if (this._text.length > 0) {
        var b = this._text.split("\n");
        for (var c = 0; c < b.length; c++) {
          if (b[c].length > a) {
            a = b[c].length;
          }
        }
      }
      return a;
    };
    b.RetroFont.prototype.removeUnsupportedCharacters = function (a) {
      var b = "";
      for (var c = 0; c < this._text.length; c++) {
        var d = this._text[c];
        var e = d.charCodeAt(0);
        if (this.grabData[e] >= 0 || !a && "\n" === d) {
          b = b.concat(d);
        }
      }
      return b;
    };
    b.RetroFont.prototype.updateOffset = function (a, b) {
      if (this.offsetX !== a || this.offsetY !== b) {
        var c = a - this.offsetX;
        var d = b - this.offsetY;
        var e = this.game.cache.getFrameData(this.stamp.key).getFrames();
        for (var f = e.length; f--;) {
          e[f].x += c;
          e[f].y += d;
        }
        this.buildRetroFontText();
      }
    };
    Object.defineProperty(b.RetroFont.prototype, "text", {
      get: function () {
        return this._text;
      },
      set: function (a) {
        var b;
        if ((b = this.autoUpperCase ? a.toUpperCase() : a) !== this._text) {
          this._text = b;
          this.removeUnsupportedCharacters(this.multiLine);
          this.buildRetroFontText();
        }
      }
    });
    Object.defineProperty(b.RetroFont.prototype, "smoothed", {
      get: function () {
        return this.stamp.smoothed;
      },
      set: function (a) {
        this.stamp.smoothed = a;
        this.buildRetroFontText();
      }
    });
    b.Rope = function (a, c, d, e, f, g) {
      this.points = [];
      this.points = g;
      this._hasUpdateAnimation = false;
      this._updateAnimationCallback = null;
      c = c || 0;
      d = d || 0;
      e = e || null;
      f = f || null;
      this.type = b.ROPE;
      PIXI.Rope.call(this, b.Cache.DEFAULT, this.points);
      b.Component.Core.init.call(this, a, c, d, e, f);
    };
    b.Rope.prototype = Object.create(PIXI.Rope.prototype);
    b.Rope.prototype.constructor = b.Rope;
    b.Component.Core.install.call(b.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]);
    b.Rope.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate;
    b.Rope.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate;
    b.Rope.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.Rope.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.Rope.prototype.preUpdate = function () {
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.Rope.prototype.update = function () {
      if (this._hasUpdateAnimation) {
        this.updateAnimation.call(this);
      }
    };
    b.Rope.prototype.reset = function (a, c) {
      b.Component.Reset.prototype.reset.call(this, a, c);
      return this;
    };
    Object.defineProperty(b.Rope.prototype, "updateAnimation", {
      get: function () {
        return this._updateAnimation;
      },
      set: function (a) {
        if (a && "function" == typeof a) {
          this._hasUpdateAnimation = true;
          this._updateAnimation = a;
        } else {
          this._hasUpdateAnimation = false;
          this._updateAnimation = null;
        }
      }
    });
    Object.defineProperty(b.Rope.prototype, "segments", {
      get: function () {
        var c;
        var d;
        var e;
        var f;
        var g;
        var h;
        var i;
        var j;
        var a = [];
        for (var k = 0; k < this.points.length; k++) {
          c = 4 * k;
          d = this.vertices[c] * this.scale.x;
          e = this.vertices[c + 1] * this.scale.y;
          f = this.vertices[c + 4] * this.scale.x;
          g = this.vertices[c + 3] * this.scale.y;
          h = b.Math.difference(d, f);
          i = b.Math.difference(e, g);
          d += this.world.x;
          e += this.world.y;
          j = new b.Rectangle(d, e, h, i);
          a.push(j);
        }
        return a;
      }
    });
    b.TileSprite = function (a, c, d, e, f, g, h) {
      c = c || 0;
      d = d || 0;
      e = e || 256;
      f = f || 256;
      g = g || null;
      h = h || null;
      this.type = b.TILESPRITE;
      this.physicsType = b.SPRITE;
      this._scroll = new b.Point();
      var i = a.cache.getImage("__default", true);
      PIXI.TilingSprite.call(this, new PIXI.Texture(i.base), e, f);
      b.Component.Core.init.call(this, a, c, d, g, h);
    };
    b.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);
    b.TileSprite.prototype.constructor = b.TileSprite;
    b.Component.Core.install.call(b.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]);
    b.TileSprite.prototype.preUpdatePhysics = b.Component.PhysicsBody.preUpdate;
    b.TileSprite.prototype.preUpdateLifeSpan = b.Component.LifeSpan.preUpdate;
    b.TileSprite.prototype.preUpdateInWorld = b.Component.InWorld.preUpdate;
    b.TileSprite.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.TileSprite.prototype.preUpdate = function () {
      if (0 !== this._scroll.x) {
        this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;
      }
      if (0 !== this._scroll.y) {
        this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;
      }
      return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore();
    };
    b.TileSprite.prototype.autoScroll = function (a, b) {
      this._scroll.set(a, b);
    };
    b.TileSprite.prototype.stopScroll = function () {
      this._scroll.set(0, 0);
    };
    b.TileSprite.prototype.destroy = function (a) {
      b.Component.Destroy.prototype.destroy.call(this, a);
      PIXI.TilingSprite.prototype.destroy.call(this);
    };
    b.TileSprite.prototype.reset = function (a, c) {
      b.Component.Reset.prototype.reset.call(this, a, c);
      this.tilePosition.x = 0;
      this.tilePosition.y = 0;
      return this;
    };
    b.Device = function () {
      this.deviceReadyAt = 0;
      this.initialized = false;
      this.desktop = false;
      this.iOS = false;
      this.iOSVersion = 0;
      this.cocoonJS = false;
      this.cocoonJSApp = false;
      this.cordova = false;
      this.node = false;
      this.nodeWebkit = false;
      this.electron = false;
      this.ejecta = false;
      this.crosswalk = false;
      this.android = false;
      this.chromeOS = false;
      this.linux = false;
      this.macOS = false;
      this.windows = false;
      this.windowsPhone = false;
      this.canvas = false;
      this.canvasBitBltShift = null;
      this.webGL = false;
      this.file = false;
      this.fileSystem = false;
      this.localStorage = false;
      this.worker = false;
      this.css3D = false;
      this.pointerLock = false;
      this.typedArray = false;
      this.vibration = false;
      this.getUserMedia = true;
      this.quirksMode = false;
      this.touch = false;
      this.mspointer = false;
      this.wheelEvent = null;
      this.arora = false;
      this.chrome = false;
      this.chromeVersion = 0;
      this.epiphany = false;
      this.firefox = false;
      this.firefoxVersion = 0;
      this.ie = false;
      this.ieVersion = 0;
      this.trident = false;
      this.tridentVersion = 0;
      this.edge = false;
      this.mobileSafari = false;
      this.midori = false;
      this.opera = false;
      this.safari = false;
      this.safariVersion = 0;
      this.webApp = false;
      this.silk = false;
      this.audioData = false;
      this.webAudio = false;
      this.ogg = false;
      this.opus = false;
      this.mp3 = false;
      this.wav = false;
      this.m4a = false;
      this.webm = false;
      this.dolby = false;
      this.oggVideo = false;
      this.h264Video = false;
      this.mp4Video = false;
      this.webmVideo = false;
      this.vp9Video = false;
      this.hlsVideo = false;
      this.iPhone = false;
      this.iPhone4 = false;
      this.iPad = false;
      this.pixelRatio = 0;
      this.littleEndian = false;
      this.LITTLE_ENDIAN = false;
      this.support32bit = false;
      this.fullscreen = false;
      this.requestFullscreen = "";
      this.cancelFullscreen = "";
      this.fullscreenKeyboard = false;
    };
    b.Device = new b.Device();
    b.Device.onInitialized = new b.Signal();
    b.Device.whenReady = function (a, b, c) {
      var d = this._readyCheck;
      if (this.deviceReadyAt || !d) {
        a.call(b, this);
      } else if (d._monitor || c) {
        d._queue = d._queue || [];
        d._queue.push([a, b]);
      } else {
        d._monitor = d.bind(this);
        d._queue = d._queue || [];
        d._queue.push([a, b]);
        var e = undefined !== window.cordova;
        var f = navigator.isCocoonJS;
        if ("complete" === document.readyState || "interactive" === document.readyState) {
          window.setTimeout(d._monitor, 0);
        } else if (e && !f) {
          document.addEventListener("deviceready", d._monitor, false);
        } else {
          document.addEventListener("DOMContentLoaded", d._monitor, false);
          window.addEventListener("load", d._monitor, false);
        }
      }
    };
    b.Device._readyCheck = function () {
      var a = this._readyCheck;
      if (document.body) {
        if (!this.deviceReadyAt) {
          this.deviceReadyAt = Date.now();
          document.removeEventListener("deviceready", a._monitor);
          document.removeEventListener("DOMContentLoaded", a._monitor);
          window.removeEventListener("load", a._monitor);
          this._initialize();
          this.initialized = true;
          this.onInitialized.dispatch(this);
          for (var b; b = a._queue.shift();) {
            var c = b[0];
            var d = b[1];
            c.call(d, this);
          }
          this._readyCheck = null;
          this._initialize = null;
          this.onInitialized = null;
        }
      } else {
        window.setTimeout(a._monitor, 20);
      }
    };
    b.Device._initialize = function () {
      function b() {
        var b = navigator.userAgent;
        if (/Playstation Vita/.test(b)) {
          a.vita = true;
        } else if (/Kindle/.test(b) || /\bKF[A-Z][A-Z]+/.test(b) || /Silk.*Mobile Safari/.test(b)) {
          a.kindle = true;
        } else if (/Android/.test(b)) {
          a.android = true;
        } else if (/CrOS/.test(b)) {
          a.chromeOS = true;
        } else if (/iP[ao]d|iPhone/i.test(b)) {
          a.iOS = true;
          navigator.appVersion.match(/OS (\d+)/);
          a.iOSVersion = parseInt(RegExp.$1, 10);
        } else if (/Linux/.test(b)) {
          a.linux = true;
        } else if (/Mac OS/.test(b)) {
          a.macOS = true;
        } else if (/Windows/.test(b)) {
          a.windows = true;
        }
        if (/Windows Phone/i.test(b) || /IEMobile/i.test(b)) {
          a.android = false;
          a.iOS = false;
          a.macOS = false;
          a.windows = true;
          a.windowsPhone = true;
        }
        var c = /Silk/.test(b);
        if (a.windows || a.macOS || a.linux && !c || a.chromeOS) {
          a.desktop = true;
        }
        if (a.windowsPhone || /Windows NT/i.test(b) && /Touch/i.test(b)) {
          a.desktop = false;
        }
      }
      function c() {
        a.canvas = !!window.CanvasRenderingContext2D || a.cocoonJS;
        try {
          a.localStorage = !!localStorage.getItem;
        } catch (b) {
          a.localStorage = false;
        }
        a.file = !!(window.File && window.FileReader && window.FileList && window.Blob);
        a.fileSystem = !!window.requestFileSystem;
        a.webGL = function () {
          try {
            var a = document.createElement("canvas");
            a.screencanvas = false;
            return !!window.WebGLRenderingContext && (a.getContext("webgl") || a.getContext("experimental-webgl"));
          } catch (a) {
            return false;
          }
        }();
        a.webGL = !!a.webGL;
        a.worker = !!window.Worker;
        a.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
        a.quirksMode = "CSS1Compat" !== document.compatMode;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
        a.getUserMedia = a.getUserMedia && !!navigator.getUserMedia && !!window.URL;
        if (a.firefox && a.firefoxVersion < 21) {
          a.getUserMedia = false;
        }
        if (!a.iOS && (a.ie || a.firefox || a.chrome)) {
          a.canvasBitBltShift = true;
        }
        if (a.safari || a.mobileSafari) {
          a.canvasBitBltShift = false;
        }
      }
      function d() {
        if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) {
          a.touch = true;
        }
        if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) {
          a.mspointer = true;
        }
        if (!a.cocoonJS) {
          if ("onwheel" in window || a.ie && "WheelEvent" in window) {
            a.wheelEvent = "wheel";
          } else if ("onmousewheel" in window) {
            a.wheelEvent = "mousewheel";
          } else if (a.firefox && "MouseScrollEvent" in window) {
            a.wheelEvent = "DOMMouseScroll";
          }
        }
      }
      function e() {
        var b = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"];
        var c = document.createElement("div");
        for (var d = 0; d < b.length; d++) {
          if (c[b[d]]) {
            a.fullscreen = true;
            a.requestFullscreen = b[d];
            break;
          }
        }
        var e = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
        if (a.fullscreen) {
          for (var d = 0; d < e.length; d++) {
            if (document[e[d]]) {
              a.cancelFullscreen = e[d];
              break;
            }
          }
        }
        if (window.Element && Element.ALLOW_KEYBOARD_INPUT) {
          a.fullscreenKeyboard = true;
        }
      }
      function f() {
        var b = navigator.userAgent;
        if (/Arora/.test(b)) {
          a.arora = true;
        } else if (/Edge\/\d+/.test(b)) {
          a.edge = true;
        } else if (/Chrome\/(\d+)/.test(b) && !a.windowsPhone) {
          a.chrome = true;
          a.chromeVersion = parseInt(RegExp.$1, 10);
        } else if (/Epiphany/.test(b)) {
          a.epiphany = true;
        } else if (/Firefox\D+(\d+)/.test(b)) {
          a.firefox = true;
          a.firefoxVersion = parseInt(RegExp.$1, 10);
        } else if (/AppleWebKit/.test(b) && a.iOS) {
          a.mobileSafari = true;
        } else if (/MSIE (\d+\.\d+);/.test(b)) {
          a.ie = true;
          a.ieVersion = parseInt(RegExp.$1, 10);
        } else if (/Midori/.test(b)) {
          a.midori = true;
        } else if (/Opera/.test(b)) {
          a.opera = true;
        } else if (/Safari\/(\d+)/.test(b) && !a.windowsPhone) {
          a.safari = true;
          if (/Version\/(\d+)\./.test(b)) {
            a.safariVersion = parseInt(RegExp.$1, 10);
          }
        } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(b)) {
          a.ie = true;
          a.trident = true;
          a.tridentVersion = parseInt(RegExp.$1, 10);
          a.ieVersion = parseInt(RegExp.$3, 10);
        }
        if (/Silk/.test(b)) {
          a.silk = true;
        }
        if (navigator.standalone) {
          a.webApp = true;
        }
        if (undefined !== window.cordova) {
          a.cordova = true;
        }
        if ("undefined" != typeof process && "undefined" != typeof require) {
          a.node = true;
        }
        if (a.node && "object" == typeof process.versions) {
          a.nodeWebkit = !!process.versions["node-webkit"];
          a.electron = !!process.versions.electron;
        }
        if (navigator.isCocoonJS) {
          a.cocoonJS = true;
        }
        if (a.cocoonJS) {
          try {
            a.cocoonJSApp = "undefined" != typeof CocoonJS;
          } catch (b) {
            a.cocoonJSApp = false;
          }
        }
        if (undefined !== window.ejecta) {
          a.ejecta = true;
        }
        if (/Crosswalk/.test(b)) {
          a.crosswalk = true;
        }
      }
      function g() {
        var b = document.createElement("video");
        try {
          if (!!b.canPlayType) {
            if (b.canPlayType("video/ogg; codecs=\"theora\"").replace(/^no$/, "")) {
              a.oggVideo = true;
            }
            if (b.canPlayType("video/mp4; codecs=\"avc1.42E01E\"").replace(/^no$/, "")) {
              a.h264Video = true;
              a.mp4Video = true;
            }
            if (b.canPlayType("video/webm; codecs=\"vp8, vorbis\"").replace(/^no$/, "")) {
              a.webmVideo = true;
            }
            if (b.canPlayType("video/webm; codecs=\"vp9\"").replace(/^no$/, "")) {
              a.vp9Video = true;
            }
            if (b.canPlayType("application/x-mpegURL; codecs=\"avc1.42E01E\"").replace(/^no$/, "")) {
              a.hlsVideo = true;
            }
          }
        } catch (a) {}
      }
      function h() {
        a.audioData = !!window.Audio;
        a.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
        var b = document.createElement("audio");
        try {
          if (!!b.canPlayType && (b.canPlayType("audio/ogg; codecs=\"vorbis\"").replace(/^no$/, "") && (a.ogg = true), (b.canPlayType("audio/ogg; codecs=\"opus\"").replace(/^no$/, "") || b.canPlayType("audio/opus;").replace(/^no$/, "")) && (a.opus = true), b.canPlayType("audio/mpeg;").replace(/^no$/, "") && (a.mp3 = true), b.canPlayType("audio/wav; codecs=\"1\"").replace(/^no$/, "") && (a.wav = true), (b.canPlayType("audio/x-m4a;") || b.canPlayType("audio/aac;").replace(/^no$/, "")) && (a.m4a = true), b.canPlayType("audio/webm; codecs=\"vorbis\"").replace(/^no$/, "") && (a.webm = true), "" !== b.canPlayType("audio/mp4;codecs=\"ec-3\""))) {
            if (a.edge) {
              a.dolby = true;
            } else if (a.safari && a.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
              var d = parseInt(RegExp.$1, 10);
              var e = parseInt(RegExp.$2, 10);
              if (10 === d && e >= 11 || d > 10) {
                a.dolby = true;
              }
            }
          }
        } catch (a) {}
      }
      function i() {
        var a = new ArrayBuffer(4);
        var b = new Uint8Array(a);
        var c = new Uint32Array(a);
        b[0] = 161;
        b[1] = 178;
        b[2] = 195;
        b[3] = 212;
        return 3569595041 === c[0] || 2712847316 !== c[0] && null;
      }
      function j() {
        if (undefined === Uint8ClampedArray) {
          return false;
        }
        var a = PIXI.CanvasPool.create(this, 1, 1);
        var b = a.getContext("2d");
        if (!b) {
          return false;
        }
        var c = b.createImageData(1, 1);
        PIXI.CanvasPool.remove(this);
        return c.data instanceof Uint8ClampedArray;
      }
      function k() {
        a.pixelRatio = window.devicePixelRatio || 1;
        a.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone");
        a.iPhone4 = 2 === a.pixelRatio && a.iPhone;
        a.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad");
        if ("undefined" != typeof Int8Array) {
          a.typedArray = true;
        } else {
          a.typedArray = false;
        }
        if ("undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array) {
          a.littleEndian = i();
          a.LITTLE_ENDIAN = a.littleEndian;
        }
        a.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== a.littleEndian && j();
        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
        if (navigator.vibrate) {
          a.vibration = true;
        }
      }
      function l() {
        var c;
        var b = document.createElement("p");
        var d = {
          webkitTransform: "-webkit-transform",
          OTransform: "-o-transform",
          msTransform: "-ms-transform",
          MozTransform: "-moz-transform",
          transform: "transform"
        };
        document.body.insertBefore(b, null);
        for (var e in d) if (undefined !== b.style[e]) {
          b.style[e] = "translate3d(1px,1px,1px)";
          c = window.getComputedStyle(b).getPropertyValue(d[e]);
        }
        document.body.removeChild(b);
        a.css3D = undefined !== c && c.length > 0 && "none" !== c;
      }
      var a = this;
      b();
      f();
      h();
      g();
      l();
      k();
      c();
      e();
      d();
    };
    b.Device.canPlayAudio = function (a) {
      return !("mp3" !== a || !this.mp3) || !("ogg" !== a || !this.ogg && !this.opus) || !("m4a" !== a || !this.m4a) || !("opus" !== a || !this.opus) || !("wav" !== a || !this.wav) || !("webm" !== a || !this.webm) || !("mp4" !== a || !this.dolby);
    };
    b.Device.canPlayVideo = function (a) {
      return !("webm" !== a || !this.webmVideo && !this.vp9Video) || !("mp4" !== a || !this.mp4Video && !this.h264Video) || !("ogg" !== a && "ogv" !== a || !this.oggVideo) || !("mpeg" !== a || !this.hlsVideo);
    };
    b.Device.isConsoleOpen = function () {
      return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && console.profiles.length > 0;
    };
    b.Device.isAndroidStockBrowser = function () {
      var a = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
      return a && a[1] < 537;
    };
    b.Canvas = {
      create: function (a, b, c, d, e) {
        b = b || 256;
        c = c || 256;
        var f = e ? document.createElement("canvas") : PIXI.CanvasPool.create(a, b, c);
        if ("string" == typeof d && "" !== d) {
          f.id = d;
        }
        f.width = b;
        f.height = c;
        f.style.display = "block";
        return f;
      },
      setBackgroundColor: function (a, b) {
        b = b || "rgb(0,0,0)";
        a.style.backgroundColor = b;
        return a;
      },
      setTouchAction: function (a, b) {
        b = b || "none";
        a.style.msTouchAction = b;
        a.style["ms-touch-action"] = b;
        a.style["touch-action"] = b;
        return a;
      },
      setUserSelect: function (a, b) {
        b = b || "none";
        a.style["-webkit-touch-callout"] = b;
        a.style["-webkit-user-select"] = b;
        a.style["-khtml-user-select"] = b;
        a.style["-moz-user-select"] = b;
        a.style["-ms-user-select"] = b;
        a.style["user-select"] = b;
        a.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
        return a;
      },
      addToDOM: function (a, b, c) {
        var d;
        if (undefined === c) {
          c = true;
        }
        if (b) {
          if ("string" == typeof b) {
            d = document.getElementById(b);
          } else if ("object" == typeof b && 1 === b.nodeType) {
            d = b;
          }
        }
        if (!d) {
          d = document.body;
        }
        if (c && d.style) {
          d.style.overflow = "hidden";
        }
        d.appendChild(a);
        return a;
      },
      removeFromDOM: function (a) {
        if (a.parentNode) {
          a.parentNode.removeChild(a);
        }
      },
      setTransform: function (a, b, c, d, e, f, g) {
        a.setTransform(d, f, g, e, b, c);
        return a;
      },
      setSmoothingEnabled: function (a, c) {
        var d = b.Canvas.getSmoothingPrefix(a);
        if (d) {
          a[d] = c;
        }
        return a;
      },
      getSmoothingPrefix: function (a) {
        var b = ["i", "webkitI", "msI", "mozI", "oI"];
        for (var c in b) {
          var d = b[c] + "mageSmoothingEnabled";
          if (d in a) {
            return d;
          }
        }
        return null;
      },
      getSmoothingEnabled: function (a) {
        var c = b.Canvas.getSmoothingPrefix(a);
        if (c) {
          return a[c];
        }
      },
      setImageRenderingCrisp: function (a) {
        var b = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"];
        for (var c = 0; c < b.length; c++) {
          a.style["image-rendering"] = b[c];
        }
        a.style.msInterpolationMode = "nearest-neighbor";
        return a;
      },
      setImageRenderingBicubic: function (a) {
        a.style["image-rendering"] = "auto";
        a.style.msInterpolationMode = "bicubic";
        return a;
      }
    };
    b.RequestAnimationFrame = function (a, b) {
      if (undefined === b) {
        b = false;
      }
      this.game = a;
      this.isRunning = false;
      this.forceSetTimeOut = b;
      var c = ["ms", "moz", "webkit", "o"];
      for (var d = 0; d < c.length && !window.requestAnimationFrame; d++) {
        window.requestAnimationFrame = window[c[d] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[c[d] + "CancelAnimationFrame"];
      }
      this._isSetTimeOut = false;
      this._onLoop = null;
      this._timeOutID = null;
    };
    b.RequestAnimationFrame.prototype = {
      start: function () {
        this.isRunning = true;
        var a = this;
        if (!window.requestAnimationFrame || this.forceSetTimeOut) {
          this._isSetTimeOut = true;
          this._onLoop = function () {
            return a.updateSetTimeout();
          };
          this._timeOutID = window.setTimeout(this._onLoop, 0);
        } else {
          this._isSetTimeOut = false;
          this._onLoop = function (b) {
            return a.updateRAF(b);
          };
          this._timeOutID = window.requestAnimationFrame(this._onLoop);
        }
      },
      updateRAF: function (a) {
        if (this.isRunning) {
          this.game.update(Math.floor(a));
          this._timeOutID = window.requestAnimationFrame(this._onLoop);
        }
      },
      updateSetTimeout: function () {
        if (this.isRunning) {
          this.game.update(Date.now());
          this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
        }
      },
      stop: function () {
        if (this._isSetTimeOut) {
          clearTimeout(this._timeOutID);
        } else {
          window.cancelAnimationFrame(this._timeOutID);
        }
        this.isRunning = false;
      },
      isSetTimeOut: function () {
        return this._isSetTimeOut;
      },
      isRAF: function () {
        return false === this._isSetTimeOut;
      }
    };
    b.RequestAnimationFrame.prototype.constructor = b.RequestAnimationFrame;
    b.Math = {
      PI2: 2 * Math.PI,
      between: function (a, b) {
        return Math.floor(Math.random() * (b - a + 1) + a);
      },
      fuzzyEqual: function (a, b, c) {
        if (undefined === c) {
          c = 1e-4;
        }
        return Math.abs(a - b) < c;
      },
      fuzzyLessThan: function (a, b, c) {
        if (undefined === c) {
          c = 1e-4;
        }
        return a < b + c;
      },
      fuzzyGreaterThan: function (a, b, c) {
        if (undefined === c) {
          c = 1e-4;
        }
        return a > b - c;
      },
      fuzzyCeil: function (a, b) {
        if (undefined === b) {
          b = 1e-4;
        }
        return Math.ceil(a - b);
      },
      fuzzyFloor: function (a, b) {
        if (undefined === b) {
          b = 1e-4;
        }
        return Math.floor(a + b);
      },
      average: function () {
        var a = 0;
        var b = arguments.length;
        for (var c = 0; c < b; c++) {
          a += +arguments[c];
        }
        return a / b;
      },
      shear: function (a) {
        return a % 1;
      },
      snapTo: function (a, b, c) {
        if (undefined === c) {
          c = 0;
        }
        return 0 === b ? a : (a -= c, a = b * Math.round(a / b), c + a);
      },
      snapToFloor: function (a, b, c) {
        if (undefined === c) {
          c = 0;
        }
        return 0 === b ? a : (a -= c, a = b * Math.floor(a / b), c + a);
      },
      snapToCeil: function (a, b, c) {
        if (undefined === c) {
          c = 0;
        }
        return 0 === b ? a : (a -= c, a = b * Math.ceil(a / b), c + a);
      },
      roundTo: function (a, b, c) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = 10;
        }
        var d = Math.pow(c, -b);
        return Math.round(a * d) / d;
      },
      floorTo: function (a, b, c) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = 10;
        }
        var d = Math.pow(c, -b);
        return Math.floor(a * d) / d;
      },
      ceilTo: function (a, b, c) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = 10;
        }
        var d = Math.pow(c, -b);
        return Math.ceil(a * d) / d;
      },
      rotateToAngle: function (a, c, d) {
        if (undefined === d) {
          d = .05;
        }
        return a === c ? a : (Math.abs(c - a) <= d || Math.abs(c - a) >= b.Math.PI2 - d ? a = c : (Math.abs(c - a) > Math.PI && (c < a ? c += b.Math.PI2 : c -= b.Math.PI2), c > a ? a += d : c < a && (a -= d)), a);
      },
      getShortestAngle: function (a, b) {
        var c = b - a;
        return 0 === c ? 0 : c - 360 * Math.floor((c + 180) / 360);
      },
      angleBetween: function (a, b, c, d) {
        return Math.atan2(d - b, c - a);
      },
      angleBetweenY: function (a, b, c, d) {
        return Math.atan2(c - a, d - b);
      },
      angleBetweenPoints: function (a, b) {
        return Math.atan2(b.y - a.y, b.x - a.x);
      },
      angleBetweenPointsY: function (a, b) {
        return Math.atan2(b.x - a.x, b.y - a.y);
      },
      reverseAngle: function (a) {
        return this.normalizeAngle(a + Math.PI, true);
      },
      normalizeAngle: function (a) {
        a %= 2 * Math.PI;
        return a >= 0 ? a : a + 2 * Math.PI;
      },
      maxAdd: function (a, b, c) {
        return Math.min(a + b, c);
      },
      minSub: function (a, b, c) {
        return Math.max(a - b, c);
      },
      wrap: function (a, b, c) {
        var d = c - b;
        if (d <= 0) {
          return 0;
        }
        var e = (a - b) % d;
        if (e < 0) {
          e += d;
        }
        return e + b;
      },
      wrapValue: function (a, b, c) {
        a = Math.abs(a);
        b = Math.abs(b);
        c = Math.abs(c);
        return (a + b) % c;
      },
      isOdd: function (a) {
        return !!(1 & a);
      },
      isEven: function (a) {
        return !(1 & a);
      },
      min: function () {
        if (1 === arguments.length && "object" == typeof arguments[0]) {
          var a = arguments[0];
        } else {
          var a = arguments;
        }
        var b = 1;
        var c = 0;
        for (var d = a.length; b < d; b++) {
          if (a[b] < a[c]) {
            c = b;
          }
        }
        return a[c];
      },
      max: function () {
        if (1 === arguments.length && "object" == typeof arguments[0]) {
          var a = arguments[0];
        } else {
          var a = arguments;
        }
        var b = 1;
        var c = 0;
        for (var d = a.length; b < d; b++) {
          if (a[b] > a[c]) {
            c = b;
          }
        }
        return a[c];
      },
      minProperty: function (a) {
        if (2 === arguments.length && "object" == typeof arguments[1]) {
          var b = arguments[1];
        } else {
          var b = arguments.slice(1);
        }
        var c = 1;
        var d = 0;
        for (var e = b.length; c < e; c++) {
          if (b[c][a] < b[d][a]) {
            d = c;
          }
        }
        return b[d][a];
      },
      maxProperty: function (a) {
        if (2 === arguments.length && "object" == typeof arguments[1]) {
          var b = arguments[1];
        } else {
          var b = arguments.slice(1);
        }
        var c = 1;
        var d = 0;
        for (var e = b.length; c < e; c++) {
          if (b[c][a] > b[d][a]) {
            d = c;
          }
        }
        return b[d][a];
      },
      wrapAngle: function (a, b) {
        return b ? this.wrap(a, -Math.PI, Math.PI) : this.wrap(a, -180, 180);
      },
      linearInterpolation: function (a, b) {
        var c = a.length - 1;
        var d = c * b;
        var e = Math.floor(d);
        return b < 0 ? this.linear(a[0], a[1], d) : b > 1 ? this.linear(a[c], a[c - 1], c - d) : this.linear(a[e], a[e + 1 > c ? c : e + 1], d - e);
      },
      bezierInterpolation: function (a, b) {
        var c = 0;
        var d = a.length - 1;
        for (var e = 0; e <= d; e++) {
          c += Math.pow(1 - b, d - e) * Math.pow(b, e) * a[e] * this.bernstein(d, e);
        }
        return c;
      },
      catmullRomInterpolation: function (a, b) {
        var c = a.length - 1;
        var d = c * b;
        var e = Math.floor(d);
        return a[0] === a[c] ? (b < 0 && (e = Math.floor(d = c * (1 + b))), this.catmullRom(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : b < 0 ? a[0] - (this.catmullRom(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (this.catmullRom(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : this.catmullRom(a[e ? e - 1 : 0], a[e], a[c < e + 1 ? c : e + 1], a[c < e + 2 ? c : e + 2], d - e);
      },
      linear: function (a, b, c) {
        return (b - a) * c + a;
      },
      bernstein: function (a, b) {
        return this.factorial(a) / this.factorial(b) / this.factorial(a - b);
      },
      factorial: function (a) {
        if (0 === a) {
          return 1;
        }
        for (var b = a; --a;) {
          b *= a;
        }
        return b;
      },
      catmullRom: function (a, b, c, d, e) {
        var f = .5 * (c - a);
        var g = .5 * (d - b);
        var h = e * e;
        return (2 * b - 2 * c + f + g) * (e * h) + (-3 * b + 3 * c - 2 * f - g) * h + f * e + b;
      },
      difference: function (a, b) {
        return Math.abs(a - b);
      },
      roundAwayFromZero: function (a) {
        return a > 0 ? Math.ceil(a) : Math.floor(a);
      },
      sinCosGenerator: function (a, b, c, d) {
        if (undefined === b) {
          b = 1;
        }
        if (undefined === c) {
          c = 1;
        }
        if (undefined === d) {
          d = 1;
        }
        var e = b;
        var f = c;
        var g = d * Math.PI / a;
        var h = [];
        var i = [];
        for (var j = 0; j < a; j++) {
          f -= e * g;
          e += f * g;
          h[j] = f;
          i[j] = e;
        }
        return {
          sin: i,
          cos: h,
          length: a
        };
      },
      distance: function (a, b, c, d) {
        var e = a - c;
        var f = b - d;
        return Math.sqrt(e * e + f * f);
      },
      distanceSq: function (a, b, c, d) {
        var e = a - c;
        var f = b - d;
        return e * e + f * f;
      },
      distancePow: function (a, b, c, d, e) {
        if (undefined === e) {
          e = 2;
        }
        return Math.sqrt(Math.pow(c - a, e) + Math.pow(d - b, e));
      },
      clamp: function (a, b, c) {
        return a < b ? b : c < a ? c : a;
      },
      clampBottom: function (a, b) {
        return a < b ? b : a;
      },
      within: function (a, b, c) {
        return Math.abs(a - b) <= c;
      },
      mapLinear: function (a, b, c, d, e) {
        return d + (a - b) * (e - d) / (c - b);
      },
      smoothstep: function (a, b, c) {
        return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * (3 - 2 * a);
      },
      smootherstep: function (a, b, c) {
        return (a = Math.max(0, Math.min(1, (a - b) / (c - b)))) * a * a * (a * (6 * a - 15) + 10);
      },
      sign: function (a) {
        return a < 0 ? -1 : a > 0 ? 1 : 0;
      },
      percent: function (a, b, c) {
        if (undefined === c) {
          c = 0;
        }
        return a > b || c > b ? 1 : a < c || c > a ? 0 : (a - c) / b;
      }
    };
    var k = Math.PI / 180;
    var l = 180 / Math.PI;
    b.Math.degToRad = function (b) {
      return b * k;
    };
    b.Math.radToDeg = function (b) {
      return b * l;
    };
    b.RandomDataGenerator = function (a) {
      if (undefined === a) {
        a = [];
      }
      this.c = 1;
      this.s0 = 0;
      this.s1 = 0;
      this.s2 = 0;
      if ("string" == typeof a) {
        this.state(a);
      } else {
        this.sow(a);
      }
    };
    b.RandomDataGenerator.prototype = {
      rnd: function () {
        var a = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
        this.c = 0 | a;
        this.s0 = this.s1;
        this.s1 = this.s2;
        this.s2 = a - this.c;
        return this.s2;
      },
      sow: function (a) {
        this.s0 = this.hash(" ");
        this.s1 = this.hash(this.s0);
        this.s2 = this.hash(this.s1);
        this.c = 1;
        if (a) {
          for (var b = 0; b < a.length && null != a[b]; b++) {
            var c = a[b];
            this.s0 -= this.hash(c);
            this.s0 += ~~(this.s0 < 0);
            this.s1 -= this.hash(c);
            this.s1 += ~~(this.s1 < 0);
            this.s2 -= this.hash(c);
            this.s2 += ~~(this.s2 < 0);
          }
        }
      },
      hash: function (a) {
        var b;
        var c;
        var d;
        d = 4022871197;
        a = a.toString();
        for (c = 0; c < a.length; c++) {
          d += a.charCodeAt(c);
          b = .02519603282416938 * d;
          d = b >>> 0;
          b -= d;
          b *= d;
          d = b >>> 0;
          b -= d;
          d += 4294967296 * b;
        }
        return 2.3283064365386963e-10 * (d >>> 0);
      },
      integer: function () {
        return 4294967296 * this.rnd.apply(this);
      },
      frac: function () {
        return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0);
      },
      real: function () {
        return this.integer() + this.frac();
      },
      integerInRange: function (a, b) {
        return Math.floor(this.realInRange(0, b - a + 1) + a);
      },
      between: function (a, b) {
        return this.integerInRange(a, b);
      },
      realInRange: function (a, b) {
        return this.frac() * (b - a) + a;
      },
      normal: function () {
        return 1 - 2 * this.frac();
      },
      uuid: function () {
        var a = "";
        var b = "";
        for (b = a = ""; a++ < 36; b += ~a % 5 | 3 * a & 4 ? (15 ^ a ? 8 ^ this.frac() * (20 ^ a ? 16 : 4) : 4).toString(16) : "-") {
          ;
        }
        return b;
      },
      pick: function (a) {
        return a[this.integerInRange(0, a.length - 1)];
      },
      sign: function () {
        return this.pick([-1, 1]);
      },
      weightedPick: function (a) {
        return a[~~(Math.pow(this.frac(), 2) * (a.length - 1) + .5)];
      },
      timestamp: function (a, b) {
        return this.realInRange(a || 9466848e5, b || 1577862e6);
      },
      angle: function () {
        return this.integerInRange(-180, 180);
      },
      state: function (a) {
        if ("string" == typeof a && a.match(/^!rnd/)) {
          a = a.split(",");
          this.c = parseFloat(a[1]);
          this.s0 = parseFloat(a[2]);
          this.s1 = parseFloat(a[3]);
          this.s2 = parseFloat(a[4]);
        }
        return ["!rnd", this.c, this.s0, this.s1, this.s2].join(",");
      }
    };
    b.RandomDataGenerator.prototype.constructor = b.RandomDataGenerator;
    b.QuadTree = function (a, b, c, d, e, f, g) {
      this.maxObjects = 10;
      this.maxLevels = 4;
      this.level = 0;
      this.bounds = {};
      this.objects = [];
      this.nodes = [];
      this._empty = [];
      this.reset(a, b, c, d, e, f, g);
    };
    b.QuadTree.prototype = {
      reset: function (a, b, c, d, e, f, g) {
        this.maxObjects = e || 10;
        this.maxLevels = f || 4;
        this.level = g || 0;
        this.bounds = {
          x: Math.round(a),
          y: Math.round(b),
          width: c,
          height: d,
          subWidth: Math.floor(c / 2),
          subHeight: Math.floor(d / 2),
          right: Math.round(a) + Math.floor(c / 2),
          bottom: Math.round(b) + Math.floor(d / 2)
        };
        this.objects.length = 0;
        this.nodes.length = 0;
      },
      populate: function (a) {
        a.forEach(this.populateHandler, this, true);
      },
      populateHandler: function (a) {
        if (a.body && a.exists) {
          this.insert(a.body);
        }
      },
      split: function () {
        this.nodes[0] = new b.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        this.nodes[1] = new b.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        this.nodes[2] = new b.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
        this.nodes[3] = new b.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
      },
      insert: function (a) {
        var c;
        var b = 0;
        if (null != this.nodes[0] && -1 !== (c = this.getIndex(a))) {
          return void this.nodes[c].insert(a);
        }
        this.objects.push(a);
        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
          for (null == this.nodes[0] && this.split(); b < this.objects.length;) {
            c = this.getIndex(this.objects[b]);
            if (-1 !== c) {
              this.nodes[c].insert(this.objects.splice(b, 1)[0]);
            } else {
              b++;
            }
          }
        }
      },
      getIndex: function (a) {
        var b = -1;
        if (a.x < this.bounds.right && a.right < this.bounds.right) {
          if (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom) {
            b = 1;
          } else if (a.y > this.bounds.bottom) {
            b = 2;
          }
        } else if (a.x > this.bounds.right) {
          if (a.y < this.bounds.bottom && a.bottom < this.bounds.bottom) {
            b = 0;
          } else if (a.y > this.bounds.bottom) {
            b = 3;
          }
        }
        return b;
      },
      retrieve: function (a) {
        if (a instanceof b.Rectangle) {
          var c = this.objects;
          var d = this.getIndex(a);
        } else {
          if (!a.body) {
            return this._empty;
          }
          var c = this.objects;
          var d = this.getIndex(a.body);
        }
        if (this.nodes[0]) {
          if (-1 !== d) {
            c = c.concat(this.nodes[d].retrieve(a));
          } else {
            c = c.concat(this.nodes[0].retrieve(a));
            c = c.concat(this.nodes[1].retrieve(a));
            c = c.concat(this.nodes[2].retrieve(a));
            c = c.concat(this.nodes[3].retrieve(a));
          }
        }
        return c;
      },
      clear: function () {
        this.objects.length = 0;
        for (var a = this.nodes.length; a--;) {
          this.nodes[a].clear();
          this.nodes.splice(a, 1);
        }
        this.nodes.length = 0;
      }
    };
    b.QuadTree.prototype.constructor = b.QuadTree;
    b.Net = function (a) {
      this.game = a;
    };
    b.Net.prototype = {
      getHostName: function () {
        return window.location && window.location.hostname ? window.location.hostname : null;
      },
      checkDomainName: function (a) {
        return -1 !== window.location.hostname.indexOf(a);
      },
      updateQueryString: function (a, b, c, d) {
        if (undefined === c) {
          c = false;
        }
        if (!(undefined !== d && "" !== d)) {
          d = window.location.href;
        }
        var e = "";
        var f = new RegExp("([?|&])" + a + "=.*?(&|#|$)(.*)", "gi");
        if (f.test(d)) {
          e = undefined !== b && null !== b ? d.replace(f, "$1" + a + "=" + b + "$2$3") : d.replace(f, "$1$3").replace(/(&|\?)$/, "");
        } else if (undefined !== b && null !== b) {
          var g = -1 !== d.indexOf("?") ? "&" : "?";
          var h = d.split("#");
          d = h[0] + g + a + "=" + b;
          if (h[1]) {
            d += "#" + h[1];
          }
          e = d;
        } else {
          e = d;
        }
        if (!c) {
          return e;
        }
        window.location.href = e;
      },
      getQueryString: function (a) {
        if (undefined === a) {
          a = "";
        }
        var b = {};
        var c = location.search.substring(1).split("&");
        for (var d in c) {
          var e = c[d].split("=");
          if (e.length > 1) {
            if (a && a === this.decodeURI(e[0])) {
              return this.decodeURI(e[1]);
            }
            b[this.decodeURI(e[0])] = this.decodeURI(e[1]);
          }
        }
        return b;
      },
      decodeURI: function (a) {
        return decodeURIComponent(a.replace(/\+/g, " "));
      }
    };
    b.Net.prototype.constructor = b.Net;
    b.TweenManager = function (a) {
      this.game = a;
      this.frameBased = false;
      this._tweens = [];
      this._add = [];
      this.easeMap = {
        Power0: b.Easing.Power0,
        Power1: b.Easing.Power1,
        Power2: b.Easing.Power2,
        Power3: b.Easing.Power3,
        Power4: b.Easing.Power4,
        Linear: b.Easing.Linear.None,
        Quad: b.Easing.Quadratic.Out,
        Cubic: b.Easing.Cubic.Out,
        Quart: b.Easing.Quartic.Out,
        Quint: b.Easing.Quintic.Out,
        Sine: b.Easing.Sinusoidal.Out,
        Expo: b.Easing.Exponential.Out,
        Circ: b.Easing.Circular.Out,
        Elastic: b.Easing.Elastic.Out,
        Back: b.Easing.Back.Out,
        Bounce: b.Easing.Bounce.Out,
        "Quad.easeIn": b.Easing.Quadratic.In,
        "Cubic.easeIn": b.Easing.Cubic.In,
        "Quart.easeIn": b.Easing.Quartic.In,
        "Quint.easeIn": b.Easing.Quintic.In,
        "Sine.easeIn": b.Easing.Sinusoidal.In,
        "Expo.easeIn": b.Easing.Exponential.In,
        "Circ.easeIn": b.Easing.Circular.In,
        "Elastic.easeIn": b.Easing.Elastic.In,
        "Back.easeIn": b.Easing.Back.In,
        "Bounce.easeIn": b.Easing.Bounce.In,
        "Quad.easeOut": b.Easing.Quadratic.Out,
        "Cubic.easeOut": b.Easing.Cubic.Out,
        "Quart.easeOut": b.Easing.Quartic.Out,
        "Quint.easeOut": b.Easing.Quintic.Out,
        "Sine.easeOut": b.Easing.Sinusoidal.Out,
        "Expo.easeOut": b.Easing.Exponential.Out,
        "Circ.easeOut": b.Easing.Circular.Out,
        "Elastic.easeOut": b.Easing.Elastic.Out,
        "Back.easeOut": b.Easing.Back.Out,
        "Bounce.easeOut": b.Easing.Bounce.Out,
        "Quad.easeInOut": b.Easing.Quadratic.InOut,
        "Cubic.easeInOut": b.Easing.Cubic.InOut,
        "Quart.easeInOut": b.Easing.Quartic.InOut,
        "Quint.easeInOut": b.Easing.Quintic.InOut,
        "Sine.easeInOut": b.Easing.Sinusoidal.InOut,
        "Expo.easeInOut": b.Easing.Exponential.InOut,
        "Circ.easeInOut": b.Easing.Circular.InOut,
        "Elastic.easeInOut": b.Easing.Elastic.InOut,
        "Back.easeInOut": b.Easing.Back.InOut,
        "Bounce.easeInOut": b.Easing.Bounce.InOut
      };
      this.game.onPause.add(this._pauseAll, this);
      this.game.onResume.add(this._resumeAll, this);
    };
    b.TweenManager.prototype = {
      getAll: function () {
        return this._tweens;
      },
      removeAll: function () {
        for (var a = 0; a < this._tweens.length; a++) {
          this._tweens[a].pendingDelete = true;
        }
        this._add = [];
      },
      removeFrom: function (a, c) {
        if (undefined === c) {
          c = true;
        }
        var d;
        var e;
        if (Array.isArray(a)) {
          d = 0;
          for (e = a.length; d < e; d++) {
            this.removeFrom(a[d]);
          }
        } else if (a.type === b.GROUP && c) {
          var d = 0;
          for (var e = a.children.length; d < e; d++) {
            this.removeFrom(a.children[d]);
          }
        } else {
          d = 0;
          for (e = this._tweens.length; d < e; d++) {
            if (a === this._tweens[d].target) {
              this.remove(this._tweens[d]);
            }
          }
          d = 0;
          for (e = this._add.length; d < e; d++) {
            if (a === this._add[d].target) {
              this.remove(this._add[d]);
            }
          }
        }
      },
      add: function (a) {
        a._manager = this;
        this._add.push(a);
      },
      create: function (a) {
        return new b.Tween(a, this.game, this);
      },
      remove: function (a) {
        var b = this._tweens.indexOf(a);
        if (-1 !== b) {
          this._tweens[b].pendingDelete = true;
        } else if (-1 !== (b = this._add.indexOf(a))) {
          this._add[b].pendingDelete = true;
        }
      },
      update: function () {
        var a = this._add.length;
        var b = this._tweens.length;
        if (0 === b && 0 === a) {
          return false;
        }
        for (var c = 0; c < b;) {
          if (this._tweens[c].update(this.game.time.time)) {
            c++;
          } else {
            this._tweens.splice(c, 1);
            b--;
          }
        }
        if (a > 0) {
          this._tweens = this._tweens.concat(this._add);
          this._add.length = 0;
        }
        return true;
      },
      isTweening: function (a) {
        return this._tweens.some(function (b) {
          return b.target === a;
        });
      },
      _pauseAll: function () {
        for (var a = this._tweens.length - 1; a >= 0; a--) {
          this._tweens[a]._pause();
        }
      },
      _resumeAll: function () {
        for (var a = this._tweens.length - 1; a >= 0; a--) {
          this._tweens[a]._resume();
        }
      },
      pauseAll: function () {
        for (var a = this._tweens.length - 1; a >= 0; a--) {
          this._tweens[a].pause();
        }
      },
      resumeAll: function () {
        for (var a = this._tweens.length - 1; a >= 0; a--) {
          this._tweens[a].resume(true);
        }
      }
    };
    b.TweenManager.prototype.constructor = b.TweenManager;
    b.Tween = function (a, c, d) {
      this.game = c;
      this.target = a;
      this.manager = d;
      this.timeline = [];
      this.reverse = false;
      this.timeScale = 1;
      this.repeatCounter = 0;
      this.pendingDelete = false;
      this.onStart = new b.Signal();
      this.onLoop = new b.Signal();
      this.onRepeat = new b.Signal();
      this.onChildComplete = new b.Signal();
      this.onComplete = new b.Signal();
      this.isRunning = false;
      this.current = 0;
      this.properties = {};
      this.chainedTween = null;
      this.isPaused = false;
      this.frameBased = d.frameBased;
      this._onUpdateCallback = null;
      this._onUpdateCallbackContext = null;
      this._pausedTime = 0;
      this._codePaused = false;
      this._hasStarted = false;
    };
    b.Tween.prototype = {
      to: function (a, c, d, e, f, g, h) {
        if (undefined === c || c <= 0) {
          c = 1e3;
        }
        if (!(undefined !== d && null !== d)) {
          d = b.Easing.Default;
        }
        if (undefined === e) {
          e = false;
        }
        if (undefined === f) {
          f = 0;
        }
        if (undefined === g) {
          g = 0;
        }
        if (undefined === h) {
          h = false;
        }
        if ("string" == typeof d && this.manager.easeMap[d]) {
          d = this.manager.easeMap[d];
        }
        return this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new b.TweenData(this).to(a, c, d, f, g, h)), e && this.start(), this);
      },
      from: function (a, c, d, e, f, g, h) {
        if (undefined === c) {
          c = 1e3;
        }
        if (!(undefined !== d && null !== d)) {
          d = b.Easing.Default;
        }
        if (undefined === e) {
          e = false;
        }
        if (undefined === f) {
          f = 0;
        }
        if (undefined === g) {
          g = 0;
        }
        if (undefined === h) {
          h = false;
        }
        if ("string" == typeof d && this.manager.easeMap[d]) {
          d = this.manager.easeMap[d];
        }
        return this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new b.TweenData(this).from(a, c, d, f, g, h)), e && this.start(), this);
      },
      start: function (a) {
        if (undefined === a) {
          a = 0;
        }
        if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) {
          return this;
        }
        for (var b = 0; b < this.timeline.length; b++) {
          for (var c in this.timeline[b].vEnd) {
            this.properties[c] = this.target[c] || 0;
            if (!Array.isArray(this.properties[c])) {
              this.properties[c] *= 1;
            }
          }
        }
        for (var b = 0; b < this.timeline.length; b++) {
          this.timeline[b].loadValues();
        }
        this.manager.add(this);
        this.isRunning = true;
        if (a < 0 || a > this.timeline.length - 1) {
          a = 0;
        }
        this.current = a;
        this.timeline[this.current].start();
        return this;
      },
      stop: function (a) {
        if (undefined === a) {
          a = false;
        }
        this.isRunning = false;
        this._onUpdateCallback = null;
        this._onUpdateCallbackContext = null;
        if (a) {
          this.onComplete.dispatch(this.target, this);
          this._hasStarted = false;
          if (this.chainedTween) {
            this.chainedTween.start();
          }
        }
        this.manager.remove(this);
        return this;
      },
      updateTweenData: function (a, b, c) {
        if (0 === this.timeline.length) {
          return this;
        }
        if (undefined === c) {
          c = 0;
        }
        if (-1 === c) {
          for (var d = 0; d < this.timeline.length; d++) {
            this.timeline[d][a] = b;
          }
        } else {
          this.timeline[c][a] = b;
        }
        return this;
      },
      delay: function (a, b) {
        return this.updateTweenData("delay", a, b);
      },
      repeat: function (a, b, c) {
        if (undefined === b) {
          b = 0;
        }
        this.updateTweenData("repeatCounter", a, c);
        return this.updateTweenData("repeatDelay", b, c);
      },
      repeatDelay: function (a, b) {
        return this.updateTweenData("repeatDelay", a, b);
      },
      yoyo: function (a, b, c) {
        if (undefined === b) {
          b = 0;
        }
        this.updateTweenData("yoyo", a, c);
        return this.updateTweenData("yoyoDelay", b, c);
      },
      yoyoDelay: function (a, b) {
        return this.updateTweenData("yoyoDelay", a, b);
      },
      easing: function (a, b) {
        if ("string" == typeof a && this.manager.easeMap[a]) {
          a = this.manager.easeMap[a];
        }
        return this.updateTweenData("easingFunction", a, b);
      },
      interpolation: function (a, c, d) {
        if (undefined === c) {
          c = b.Math;
        }
        this.updateTweenData("interpolationFunction", a, d);
        return this.updateTweenData("interpolationContext", c, d);
      },
      repeatAll: function (a) {
        if (undefined === a) {
          a = 0;
        }
        this.repeatCounter = a;
        return this;
      },
      chain: function () {
        for (var a = arguments.length; a--;) {
          if (a > 0) {
            arguments[a - 1].chainedTween = arguments[a];
          } else {
            this.chainedTween = arguments[a];
          }
        }
        return this;
      },
      loop: function (a) {
        if (undefined === a) {
          a = true;
        }
        this.repeatCounter = a ? -1 : 0;
        return this;
      },
      onUpdateCallback: function (a, b) {
        this._onUpdateCallback = a;
        this._onUpdateCallbackContext = b;
        return this;
      },
      pause: function () {
        this.isPaused = true;
        this._codePaused = true;
        this._pausedTime = this.game.time.time;
      },
      _pause: function () {
        if (!this._codePaused) {
          this.isPaused = true;
          this._pausedTime = this.game.time.time;
        }
      },
      resume: function () {
        if (this.isPaused) {
          this.isPaused = false;
          this._codePaused = false;
          for (var a = 0; a < this.timeline.length; a++) {
            if (!this.timeline[a].isRunning) {
              this.timeline[a].startTime += this.game.time.time - this._pausedTime;
            }
          }
        }
      },
      _resume: function () {
        if (!this._codePaused) {
          this.resume();
        }
      },
      update: function (a) {
        if (this.pendingDelete || !this.target) {
          return false;
        }
        if (this.isPaused) {
          return true;
        }
        var c = this.timeline[this.current].update(a);
        if (c === b.TweenData.PENDING) {
          return true;
        }
        if (c === b.TweenData.RUNNING) {
          if (!this._hasStarted) {
            this.onStart.dispatch(this.target, this);
            this._hasStarted = true;
          }
          if (null !== this._onUpdateCallback) {
            this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]);
          }
          return this.isRunning;
        }
        if (c === b.TweenData.LOOPED) {
          if (-1 === this.timeline[this.current].repeatCounter) {
            this.onLoop.dispatch(this.target, this);
          } else {
            this.onRepeat.dispatch(this.target, this);
          }
          return true;
        }
        if (c === b.TweenData.COMPLETE) {
          var d = false;
          if (this.reverse) {
            if (--this.current < 0) {
              this.current = this.timeline.length - 1;
              d = true;
            }
          } else if (++this.current === this.timeline.length) {
            this.current = 0;
            d = true;
          }
          return d ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), true) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), true) : (this.isRunning = false, this.onComplete.dispatch(this.target, this), this._hasStarted = false, this.chainedTween && this.chainedTween.start(), false) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), true);
        }
      },
      generateData: function (a, b) {
        if (null === this.game || null === this.target) {
          return null;
        }
        if (undefined === a) {
          a = 60;
        }
        if (undefined === b) {
          b = [];
        }
        for (var c = 0; c < this.timeline.length; c++) {
          for (var d in this.timeline[c].vEnd) {
            this.properties[d] = this.target[d] || 0;
            if (!Array.isArray(this.properties[d])) {
              this.properties[d] *= 1;
            }
          }
        }
        for (var c = 0; c < this.timeline.length; c++) {
          this.timeline[c].loadValues();
        }
        for (var c = 0; c < this.timeline.length; c++) {
          b = b.concat(this.timeline[c].generateData(a));
        }
        return b;
      }
    };
    Object.defineProperty(b.Tween.prototype, "totalDuration", {
      get: function () {
        var a = 0;
        for (var b = 0; b < this.timeline.length; b++) {
          a += this.timeline[b].duration;
        }
        return a;
      }
    });
    b.Tween.prototype.constructor = b.Tween;
    b.TweenData = function (a) {
      this.parent = a;
      this.game = a.game;
      this.vStart = {};
      this.vStartCache = {};
      this.vEnd = {};
      this.vEndCache = {};
      this.duration = 1e3;
      this.percent = 0;
      this.value = 0;
      this.repeatCounter = 0;
      this.repeatDelay = 0;
      this.repeatTotal = 0;
      this.interpolate = false;
      this.yoyo = false;
      this.yoyoDelay = 0;
      this.inReverse = false;
      this.delay = 0;
      this.dt = 0;
      this.startTime = null;
      this.easingFunction = b.Easing.Default;
      this.interpolationFunction = b.Math.linearInterpolation;
      this.interpolationContext = b.Math;
      this.isRunning = false;
      this.isFrom = false;
    };
    b.TweenData.PENDING = 0;
    b.TweenData.RUNNING = 1;
    b.TweenData.LOOPED = 2;
    b.TweenData.COMPLETE = 3;
    b.TweenData.prototype = {
      to: function (a, b, c, d, e, f) {
        this.vEnd = a;
        this.duration = b;
        this.easingFunction = c;
        this.delay = d;
        this.repeatTotal = e;
        this.yoyo = f;
        this.isFrom = false;
        return this;
      },
      from: function (a, b, c, d, e, f) {
        this.vEnd = a;
        this.duration = b;
        this.easingFunction = c;
        this.delay = d;
        this.repeatTotal = e;
        this.yoyo = f;
        this.isFrom = true;
        return this;
      },
      start: function () {
        this.startTime = this.game.time.time + this.delay;
        if (this.parent.reverse) {
          this.dt = this.duration;
        } else {
          this.dt = 0;
        }
        if (this.delay > 0) {
          this.isRunning = false;
        } else {
          this.isRunning = true;
        }
        if (this.isFrom) {
          for (var a in this.vStartCache) {
            this.vStart[a] = this.vEndCache[a];
            this.vEnd[a] = this.vStartCache[a];
            this.parent.target[a] = this.vStart[a];
          }
        }
        this.value = 0;
        this.yoyoCounter = 0;
        this.repeatCounter = this.repeatTotal;
        return this;
      },
      loadValues: function () {
        for (var a in this.parent.properties) {
          this.vStart[a] = this.parent.properties[a];
          if (Array.isArray(this.vEnd[a])) {
            if (0 === this.vEnd[a].length) {
              continue;
            }
            if (0 === this.percent) {
              this.vEnd[a] = [this.vStart[a]].concat(this.vEnd[a]);
            }
          }
          if (undefined !== this.vEnd[a]) {
            if ("string" == typeof this.vEnd[a]) {
              this.vEnd[a] = this.vStart[a] + parseFloat(this.vEnd[a], 10);
            }
            this.parent.properties[a] = this.vEnd[a];
          } else {
            this.vEnd[a] = this.vStart[a];
          }
          this.vStartCache[a] = this.vStart[a];
          this.vEndCache[a] = this.vEnd[a];
        }
        return this;
      },
      update: function (a) {
        if (this.isRunning) {
          if (a < this.startTime) {
            return b.TweenData.RUNNING;
          }
        } else {
          if (!(a >= this.startTime)) {
            return b.TweenData.PENDING;
          }
          this.isRunning = true;
        }
        var c = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
        if (this.parent.reverse) {
          this.dt -= c * this.parent.timeScale;
          this.dt = Math.max(this.dt, 0);
        } else {
          this.dt += c * this.parent.timeScale;
          this.dt = Math.min(this.dt, this.duration);
        }
        this.percent = this.dt / this.duration;
        this.value = this.easingFunction(this.percent);
        for (var d in this.vEnd) {
          var e = this.vStart[d];
          var f = this.vEnd[d];
          if (Array.isArray(f)) {
            this.parent.target[d] = this.interpolationFunction.call(this.interpolationContext, f, this.value);
          } else {
            this.parent.target[d] = e + (f - e) * this.value;
          }
        }
        return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : b.TweenData.RUNNING;
      },
      generateData: function (a) {
        if (this.parent.reverse) {
          this.dt = this.duration;
        } else {
          this.dt = 0;
        }
        var b = [];
        var c = false;
        var d = 1 / a * 1e3;
        do {
          if (this.parent.reverse) {
            this.dt -= d;
            this.dt = Math.max(this.dt, 0);
          } else {
            this.dt += d;
            this.dt = Math.min(this.dt, this.duration);
          }
          this.percent = this.dt / this.duration;
          this.value = this.easingFunction(this.percent);
          var e = {};
          for (var f in this.vEnd) {
            var g = this.vStart[f];
            var h = this.vEnd[f];
            if (Array.isArray(h)) {
              e[f] = this.interpolationFunction(h, this.value);
            } else {
              e[f] = g + (h - g) * this.value;
            }
          }
          b.push(e);
          if (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) {
            c = true;
          }
        } while (!c);
        if (this.yoyo) {
          var i = b.slice();
          i.reverse();
          b = b.concat(i);
        }
        return b;
      },
      repeat: function () {
        if (this.yoyo) {
          if (this.inReverse && 0 === this.repeatCounter) {
            for (var a in this.vStartCache) {
              this.vStart[a] = this.vStartCache[a];
              this.vEnd[a] = this.vEndCache[a];
            }
            this.inReverse = false;
            return b.TweenData.COMPLETE;
          }
          this.inReverse = !this.inReverse;
        } else if (0 === this.repeatCounter) {
          return b.TweenData.COMPLETE;
        }
        if (this.inReverse) {
          for (var a in this.vStartCache) {
            this.vStart[a] = this.vEndCache[a];
            this.vEnd[a] = this.vStartCache[a];
          }
        } else {
          for (var a in this.vStartCache) {
            this.vStart[a] = this.vStartCache[a];
            this.vEnd[a] = this.vEndCache[a];
          }
          if (this.repeatCounter > 0) {
            this.repeatCounter--;
          }
        }
        this.startTime = this.game.time.time;
        if (this.yoyo && this.inReverse) {
          this.startTime += this.yoyoDelay;
        } else if (!this.inReverse) {
          this.startTime += this.repeatDelay;
        }
        if (this.parent.reverse) {
          this.dt = this.duration;
        } else {
          this.dt = 0;
        }
        return b.TweenData.LOOPED;
      }
    };
    b.TweenData.prototype.constructor = b.TweenData;
    b.Easing = {
      Linear: {
        None: function (a) {
          return a;
        }
      },
      Quadratic: {
        In: function (a) {
          return a * a;
        },
        Out: function (a) {
          return a * (2 - a);
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? .5 * a * a : -.5 * (--a * (a - 2) - 1);
        }
      },
      Cubic: {
        In: function (a) {
          return a * a * a;
        },
        Out: function (a) {
          return --a * a * a + 1;
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2);
        }
      },
      Quartic: {
        In: function (a) {
          return a * a * a * a;
        },
        Out: function (a) {
          return 1 - --a * a * a * a;
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2);
        }
      },
      Quintic: {
        In: function (a) {
          return a * a * a * a * a;
        },
        Out: function (a) {
          return --a * a * a * a * a + 1;
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2);
        }
      },
      Sinusoidal: {
        In: function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : 1 - Math.cos(a * Math.PI / 2);
        },
        Out: function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : Math.sin(a * Math.PI / 2);
        },
        InOut: function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : .5 * (1 - Math.cos(Math.PI * a));
        }
      },
      Exponential: {
        In: function (a) {
          return 0 === a ? 0 : Math.pow(1024, a - 1);
        },
        Out: function (a) {
          return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
        },
        InOut: function (a) {
          return 0 === a ? 0 : 1 === a ? 1 : (a *= 2) < 1 ? .5 * Math.pow(1024, a - 1) : .5 * (2 - Math.pow(2, -10 * (a - 1)));
        }
      },
      Circular: {
        In: function (a) {
          return 1 - Math.sqrt(1 - a * a);
        },
        Out: function (a) {
          return Math.sqrt(1 - --a * a);
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
        }
      },
      Elastic: {
        In: function (a) {
          var b;
          var c = .1;
          return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = 0.1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), -c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / .4));
        },
        Out: function (a) {
          var b;
          var c = .1;
          return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = 0.1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), c * Math.pow(2, -10 * a) * Math.sin((a - b) * (2 * Math.PI) / .4) + 1);
        },
        InOut: function (a) {
          var b;
          var c = .1;
          return 0 === a ? 0 : 1 === a ? 1 : (!c || c < 1 ? (c = 1, b = 0.1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), (a *= 2) < 1 ? c * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / .4) * -.5 : c * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - b) * (2 * Math.PI) / .4) * .5 + 1);
        }
      },
      Back: {
        In: function (a) {
          return a * a * (2.70158 * a - 1.70158);
        },
        Out: function (a) {
          return --a * a * (2.70158 * a + 1.70158) + 1;
        },
        InOut: function (a) {
          return (a *= 2) < 1 ? a * a * (3.5949095 * a - 2.5949095) * .5 : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
        }
      },
      Bounce: {
        In: function (a) {
          return 1 - b.Easing.Bounce.Out(1 - a);
        },
        Out: function (a) {
          return a < 0.36363636363636365 ? 7.5625 * a * a : a < 0.7272727272727273 ? 7.5625 * (a -= 0.5454545454545454) * a + .75 : a < 0.9090909090909091 ? 7.5625 * (a -= 0.8181818181818182) * a + .9375 : 7.5625 * (a -= 0.9545454545454546) * a + .984375;
        },
        InOut: function (a) {
          return a < .5 ? .5 * b.Easing.Bounce.In(2 * a) : .5 * b.Easing.Bounce.Out(2 * a - 1) + .5;
        }
      }
    };
    b.Easing.Default = b.Easing.Linear.None;
    b.Easing.Power0 = b.Easing.Linear.None;
    b.Easing.Power1 = b.Easing.Quadratic.Out;
    b.Easing.Power2 = b.Easing.Cubic.Out;
    b.Easing.Power3 = b.Easing.Quartic.Out;
    b.Easing.Power4 = b.Easing.Quintic.Out;
    b.Time = function (a) {
      this.game = a;
      this.time = 0;
      this.prevTime = 0;
      this.now = 0;
      this.elapsed = 0;
      this.elapsedMS = 0;
      this.physicsElapsed = 0.016666666666666666;
      this.physicsElapsedMS = 16.666666666666668;
      this.desiredFpsMult = 0.016666666666666666;
      this._desiredFps = 60;
      this.suggestedFps = this.desiredFps;
      this.slowMotion = 1;
      this.advancedTiming = false;
      this.frames = 0;
      this.fps = 0;
      this.fpsMin = 1e3;
      this.fpsMax = 0;
      this.msMin = 1e3;
      this.msMax = 0;
      this.pauseDuration = 0;
      this.timeToCall = 0;
      this.timeExpected = 0;
      this.events = new b.Timer(this.game, false);
      this._frameCount = 0;
      this._elapsedAccumulator = 0;
      this._started = 0;
      this._timeLastSecond = 0;
      this._pauseStarted = 0;
      this._justResumed = false;
      this._timers = [];
    };
    b.Time.prototype = {
      boot: function () {
        this._started = Date.now();
        this.time = Date.now();
        this.events.start();
        this.timeExpected = this.time;
      },
      add: function (a) {
        this._timers.push(a);
        return a;
      },
      create: function (a) {
        if (undefined === a) {
          a = true;
        }
        var c = new b.Timer(this.game, a);
        this._timers.push(c);
        return c;
      },
      removeAll: function () {
        for (var a = 0; a < this._timers.length; a++) {
          this._timers[a].destroy();
        }
        this._timers = [];
        this.events.removeAll();
      },
      refresh: function () {
        var a = this.time;
        this.time = Date.now();
        this.elapsedMS = this.time - a;
      },
      update: function (a) {
        var b = this.time;
        this.time = Date.now();
        this.elapsedMS = this.time - b;
        this.prevTime = this.now;
        this.now = a;
        this.elapsed = this.now - this.prevTime;
        if (this.game.raf._isSetTimeOut) {
          this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - a)));
          this.timeExpected = a + this.timeToCall;
        }
        if (this.advancedTiming) {
          this.updateAdvancedTiming();
        }
        if (!this.game.paused) {
          this.events.update(this.time);
          if (this._timers.length) {
            this.updateTimers();
          }
        }
      },
      updateTimers: function () {
        var a = 0;
        for (var b = this._timers.length; a < b;) {
          if (this._timers[a].update(this.time)) {
            a++;
          } else {
            this._timers.splice(a, 1);
            b--;
          }
        }
      },
      updateAdvancedTiming: function () {
        this._frameCount++;
        this._elapsedAccumulator += this.elapsed;
        if (this._frameCount >= 2 * this._desiredFps) {
          this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount));
          this._frameCount = 0;
          this._elapsedAccumulator = 0;
        }
        this.msMin = Math.min(this.msMin, this.elapsed);
        this.msMax = Math.max(this.msMax, this.elapsed);
        this.frames++;
        if (this.now > this._timeLastSecond + 1e3) {
          this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond));
          this.fpsMin = Math.min(this.fpsMin, this.fps);
          this.fpsMax = Math.max(this.fpsMax, this.fps);
          this._timeLastSecond = this.now;
          this.frames = 0;
        }
      },
      gamePaused: function () {
        this._pauseStarted = Date.now();
        this.events.pause();
        for (var a = this._timers.length; a--;) {
          this._timers[a]._pause();
        }
      },
      gameResumed: function () {
        this.time = Date.now();
        this.pauseDuration = this.time - this._pauseStarted;
        this.events.resume();
        for (var a = this._timers.length; a--;) {
          this._timers[a]._resume();
        }
      },
      totalElapsedSeconds: function () {
        return .001 * (this.time - this._started);
      },
      elapsedSince: function (a) {
        return this.time - a;
      },
      elapsedSecondsSince: function (a) {
        return .001 * (this.time - a);
      },
      reset: function () {
        this._started = this.time;
        this.removeAll();
      }
    };
    Object.defineProperty(b.Time.prototype, "desiredFps", {
      get: function () {
        return this._desiredFps;
      },
      set: function (a) {
        this._desiredFps = a;
        this.physicsElapsed = 1 / a;
        this.physicsElapsedMS = 1e3 * this.physicsElapsed;
        this.desiredFpsMult = 1 / a;
      }
    });
    b.Time.prototype.constructor = b.Time;
    b.Timer = function (a, c) {
      if (undefined === c) {
        c = true;
      }
      this.game = a;
      this.running = false;
      this.autoDestroy = c;
      this.expired = false;
      this.elapsed = 0;
      this.events = [];
      this.onComplete = new b.Signal();
      this.nextTick = 0;
      this.timeCap = 1e3;
      this.paused = false;
      this._codePaused = false;
      this._started = 0;
      this._pauseStarted = 0;
      this._pauseTotal = 0;
      this._now = Date.now();
      this._len = 0;
      this._marked = 0;
      this._i = 0;
      this._diff = 0;
      this._newTick = 0;
    };
    b.Timer.MINUTE = 6e4;
    b.Timer.SECOND = 1e3;
    b.Timer.HALF = 500;
    b.Timer.QUARTER = 250;
    b.Timer.prototype = {
      create: function (a, c, d, e, f, g) {
        a = Math.round(a);
        var h = a;
        if (0 === this._now) {
          h += this.game.time.time;
        } else {
          h += this._now;
        }
        var i = new b.TimerEvent(this, a, h, d, c, e, f, g);
        this.events.push(i);
        this.order();
        this.expired = false;
        return i;
      },
      add: function (a, b, c) {
        return this.create(a, false, 0, b, c, Array.prototype.slice.call(arguments, 3));
      },
      repeat: function (a, b, c, d) {
        return this.create(a, false, b, c, d, Array.prototype.slice.call(arguments, 4));
      },
      loop: function (a, b, c) {
        return this.create(a, true, 0, b, c, Array.prototype.slice.call(arguments, 3));
      },
      start: function (a) {
        if (!this.running) {
          this._started = this.game.time.time + (a || 0);
          this.running = true;
          for (var b = 0; b < this.events.length; b++) {
            this.events[b].tick = this.events[b].delay + this._started;
          }
        }
      },
      stop: function (a) {
        this.running = false;
        if (undefined === a) {
          a = true;
        }
        if (a) {
          this.events.length = 0;
        }
      },
      remove: function (a) {
        for (var b = 0; b < this.events.length; b++) {
          if (this.events[b] === a) {
            this.events[b].pendingDelete = true;
            return true;
          }
        }
        return false;
      },
      order: function () {
        if (this.events.length > 0) {
          this.events.sort(this.sortHandler);
          this.nextTick = this.events[0].tick;
        }
      },
      sortHandler: function (a, b) {
        return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
      },
      clearPendingEvents: function () {
        for (this._i = this.events.length; this._i--;) {
          if (this.events[this._i].pendingDelete) {
            this.events.splice(this._i, 1);
          }
        }
        this._len = this.events.length;
        this._i = 0;
      },
      update: function (a) {
        if (this.paused) {
          return true;
        }
        this.elapsed = a - this._now;
        this._now = a;
        if (this.elapsed > this.timeCap) {
          this.adjustEvents(a - this.elapsed);
        }
        this._marked = 0;
        this.clearPendingEvents();
        if (this.running && this._now >= this.nextTick && this._len > 0) {
          for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) {
            this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick);
            if (this._newTick < 0) {
              this._newTick = this._now + this.events[this._i].delay;
            }
            if (true === this.events[this._i].loop) {
              this.events[this._i].tick = this._newTick;
              this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
            } else if (this.events[this._i].repeatCount > 0) {
              this.events[this._i].repeatCount--;
              this.events[this._i].tick = this._newTick;
              this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
            } else {
              this._marked++;
              this.events[this._i].pendingDelete = true;
              this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);
            }
            this._i++;
          }
          if (this.events.length > this._marked) {
            this.order();
          } else {
            this.expired = true;
            this.onComplete.dispatch(this);
          }
        }
        return !this.expired || !this.autoDestroy;
      },
      pause: function () {
        if (this.running) {
          this._codePaused = true;
          if (!this.paused) {
            this._pauseStarted = this.game.time.time;
            this.paused = true;
          }
        }
      },
      _pause: function () {
        if (!this.paused && this.running) {
          this._pauseStarted = this.game.time.time;
          this.paused = true;
        }
      },
      adjustEvents: function (a) {
        for (var b = 0; b < this.events.length; b++) {
          if (!this.events[b].pendingDelete) {
            var c = this.events[b].tick - a;
            if (c < 0) {
              c = 0;
            }
            this.events[b].tick = this._now + c;
          }
        }
        var d = this.nextTick - a;
        this.nextTick = d < 0 ? this._now : this._now + d;
      },
      resume: function () {
        if (this.paused) {
          var a = this.game.time.time;
          this._pauseTotal += a - this._now;
          this._now = a;
          this.adjustEvents(this._pauseStarted);
          this.paused = false;
          this._codePaused = false;
        }
      },
      _resume: function () {
        if (!this._codePaused) {
          this.resume();
        }
      },
      removeAll: function () {
        this.onComplete.removeAll();
        this.events.length = 0;
        this._len = 0;
        this._i = 0;
      },
      destroy: function () {
        this.onComplete.removeAll();
        this.running = false;
        this.events = [];
        this._len = 0;
        this._i = 0;
      }
    };
    Object.defineProperty(b.Timer.prototype, "next", {
      get: function () {
        return this.nextTick;
      }
    });
    Object.defineProperty(b.Timer.prototype, "duration", {
      get: function () {
        return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
      }
    });
    Object.defineProperty(b.Timer.prototype, "length", {
      get: function () {
        return this.events.length;
      }
    });
    Object.defineProperty(b.Timer.prototype, "ms", {
      get: function () {
        return this.running ? this._now - this._started - this._pauseTotal : 0;
      }
    });
    Object.defineProperty(b.Timer.prototype, "seconds", {
      get: function () {
        return this.running ? .001 * this.ms : 0;
      }
    });
    b.Timer.prototype.constructor = b.Timer;
    b.TimerEvent = function (a, b, c, d, e, f, g, h) {
      this.timer = a;
      this.delay = b;
      this.tick = c;
      this.repeatCount = d - 1;
      this.loop = e;
      this.callback = f;
      this.callbackContext = g;
      this.args = h;
      this.pendingDelete = false;
    };
    b.TimerEvent.prototype.constructor = b.TimerEvent;
    b.AnimationManager = function (a) {
      this.sprite = a;
      this.game = a.game;
      this.currentFrame = null;
      this.currentAnim = null;
      this.updateIfVisible = true;
      this.isLoaded = false;
      this._frameData = null;
      this._anims = {};
      this._outputFrames = [];
    };
    b.AnimationManager.prototype = {
      loadFrameData: function (a, b) {
        if (undefined === a) {
          return false;
        }
        if (this.isLoaded) {
          for (var c in this._anims) this._anims[c].updateFrameData(a);
        }
        this._frameData = a;
        if (undefined === b || null === b) {
          this.frame = 0;
        } else if ("string" == typeof b) {
          this.frameName = b;
        } else {
          this.frame = b;
        }
        this.isLoaded = true;
        return true;
      },
      copyFrameData: function (a, b) {
        this._frameData = a.clone();
        if (this.isLoaded) {
          for (var c in this._anims) this._anims[c].updateFrameData(this._frameData);
        }
        if (undefined === b || null === b) {
          this.frame = 0;
        } else if ("string" == typeof b) {
          this.frameName = b;
        } else {
          this.frame = b;
        }
        this.isLoaded = true;
        return true;
      },
      add: function (a, c, d, e, f) {
        c = c || [];
        d = d || 60;
        if (undefined === e) {
          e = false;
        }
        if (undefined === f) {
          f = !(!c || "number" != typeof c[0]);
        }
        this._outputFrames = [];
        this._frameData.getFrameIndexes(c, f, this._outputFrames);
        this._anims[a] = new b.Animation(this.game, this.sprite, a, this._frameData, this._outputFrames, d, e);
        this.currentAnim = this._anims[a];
        if (this.sprite.tilingTexture) {
          this.sprite.refreshTexture = true;
        }
        return this._anims[a];
      },
      validateFrames: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        for (var c = 0; c < a.length; c++) {
          if (true === b) {
            if (a[c] > this._frameData.total) {
              return false;
            }
          } else if (false === this._frameData.checkFrameName(a[c])) {
            return false;
          }
        }
        return true;
      },
      play: function (a, b, c, d) {
        if (this._anims[a]) {
          return this.currentAnim === this._anims[a] ? false === this.currentAnim.isPlaying ? (this.currentAnim.paused = false, this.currentAnim.play(b, c, d)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[a], this.currentAnim.paused = false, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(b, c, d));
        }
      },
      stop: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (!(!this.currentAnim || "string" == typeof a && a !== this.currentAnim.name)) {
          this.currentAnim.stop(b);
        }
      },
      update: function () {
        return !(this.updateIfVisible && !this.sprite.visible) && !(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, true);
      },
      next: function (a) {
        if (this.currentAnim) {
          this.currentAnim.next(a);
          this.currentFrame = this.currentAnim.currentFrame;
        }
      },
      previous: function (a) {
        if (this.currentAnim) {
          this.currentAnim.previous(a);
          this.currentFrame = this.currentAnim.currentFrame;
        }
      },
      getAnimation: function (a) {
        return "string" == typeof a && this._anims[a] ? this._anims[a] : null;
      },
      refreshFrame: function () {},
      destroy: function () {
        var a = null;
        for (var a in this._anims) if (this._anims.hasOwnProperty(a)) {
          this._anims[a].destroy();
        }
        this._anims = {};
        this._outputFrames = [];
        this._frameData = null;
        this.currentAnim = null;
        this.currentFrame = null;
        this.sprite = null;
        this.game = null;
      }
    };
    b.AnimationManager.prototype.constructor = b.AnimationManager;
    Object.defineProperty(b.AnimationManager.prototype, "frameData", {
      get: function () {
        return this._frameData;
      }
    });
    Object.defineProperty(b.AnimationManager.prototype, "frameTotal", {
      get: function () {
        return this._frameData.total;
      }
    });
    Object.defineProperty(b.AnimationManager.prototype, "paused", {
      get: function () {
        return this.currentAnim.isPaused;
      },
      set: function (a) {
        this.currentAnim.paused = a;
      }
    });
    Object.defineProperty(b.AnimationManager.prototype, "name", {
      get: function () {
        if (this.currentAnim) {
          return this.currentAnim.name;
        }
      }
    });
    Object.defineProperty(b.AnimationManager.prototype, "frame", {
      get: function () {
        if (this.currentFrame) {
          return this.currentFrame.index;
        }
      },
      set: function (a) {
        if ("number" == typeof a && this._frameData && null !== this._frameData.getFrame(a)) {
          this.currentFrame = this._frameData.getFrame(a);
          if (this.currentFrame) {
            this.sprite.setFrame(this.currentFrame);
          }
        }
      }
    });
    Object.defineProperty(b.AnimationManager.prototype, "frameName", {
      get: function () {
        if (this.currentFrame) {
          return this.currentFrame.name;
        }
      },
      set: function (a) {
        if ("string" == typeof a && this._frameData && null !== this._frameData.getFrameByName(a)) {
          this.currentFrame = this._frameData.getFrameByName(a);
          if (this.currentFrame) {
            this._frameIndex = this.currentFrame.index;
            this.sprite.setFrame(this.currentFrame);
          }
        } else {
          console.warn("Cannot set frameName: " + a);
        }
      }
    });
    b.Animation = function (a, c, d, e, f, g, h) {
      if (undefined === h) {
        h = false;
      }
      this.game = a;
      this._parent = c;
      this._frameData = e;
      this.name = d;
      this._frames = [];
      this._frames = this._frames.concat(f);
      this.delay = 1e3 / g;
      this.loop = h;
      this.loopCount = 0;
      this.killOnComplete = false;
      this.isFinished = false;
      this.isPlaying = false;
      this.isPaused = false;
      this._pauseStartTime = 0;
      this._frameIndex = 0;
      this._frameDiff = 0;
      this._frameSkip = 1;
      this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
      this.onStart = new b.Signal();
      this.onUpdate = null;
      this.onComplete = new b.Signal();
      this.onLoop = new b.Signal();
      this.isReversed = false;
      this.game.onPause.add(this.onPause, this);
      this.game.onResume.add(this.onResume, this);
    };
    b.Animation.prototype = {
      play: function (a, b, c) {
        if ("number" == typeof a) {
          this.delay = 1e3 / a;
        }
        if ("boolean" == typeof b) {
          this.loop = b;
        }
        if (undefined !== c) {
          this.killOnComplete = c;
        }
        this.isPlaying = true;
        this.isFinished = false;
        this.paused = false;
        this.loopCount = 0;
        this._timeLastFrame = this.game.time.time;
        this._timeNextFrame = this.game.time.time + this.delay;
        this._frameIndex = this.isReversed ? this._frames.length - 1 : 0;
        this.updateCurrentFrame(false, true);
        this._parent.events.onAnimationStart$dispatch(this._parent, this);
        this.onStart.dispatch(this._parent, this);
        this._parent.animations.currentAnim = this;
        this._parent.animations.currentFrame = this.currentFrame;
        return this;
      },
      restart: function () {
        this.isPlaying = true;
        this.isFinished = false;
        this.paused = false;
        this.loopCount = 0;
        this._timeLastFrame = this.game.time.time;
        this._timeNextFrame = this.game.time.time + this.delay;
        this._frameIndex = 0;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this._parent.setFrame(this.currentFrame);
        this._parent.animations.currentAnim = this;
        this._parent.animations.currentFrame = this.currentFrame;
        this.onStart.dispatch(this._parent, this);
      },
      reverse: function () {
        this.reversed = !this.reversed;
        return this;
      },
      reverseOnce: function () {
        this.onComplete.addOnce(this.reverse, this);
        return this.reverse();
      },
      setFrame: function (a, b) {
        var c;
        if (undefined === b) {
          b = false;
        }
        if ("string" == typeof a) {
          for (var d = 0; d < this._frames.length; d++) {
            if (this._frameData.getFrame(this._frames[d]).name === a) {
              c = d;
            }
          }
        } else if ("number" == typeof a) {
          if (b) {
            c = a;
          } else {
            for (var d = 0; d < this._frames.length; d++) {
              if (this._frames[d] === a) {
                c = d;
              }
            }
          }
        }
        if (c) {
          this._frameIndex = c - 1;
          this._timeNextFrame = this.game.time.time;
          this.update();
        }
      },
      stop: function (a, b) {
        if (undefined === a) {
          a = false;
        }
        if (undefined === b) {
          b = false;
        }
        this.isPlaying = false;
        this.isFinished = true;
        this.paused = false;
        if (a) {
          this.currentFrame = this._frameData.getFrame(this._frames[0]);
          this._parent.setFrame(this.currentFrame);
        }
        if (b) {
          this._parent.events.onAnimationComplete$dispatch(this._parent, this);
          this.onComplete.dispatch(this._parent, this);
        }
      },
      onPause: function () {
        if (this.isPlaying) {
          this._frameDiff = this._timeNextFrame - this.game.time.time;
        }
      },
      onResume: function () {
        if (this.isPlaying) {
          this._timeNextFrame = this.game.time.time + this._frameDiff;
        }
      },
      update: function () {
        return !this.isPaused && !!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), false) : this.updateCurrentFrame(true));
      },
      updateCurrentFrame: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (!this._frameData) {
          return false;
        }
        var c = this.currentFrame.index;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        if (this.currentFrame && (b || !b && c !== this.currentFrame.index)) {
          this._parent.setFrame(this.currentFrame);
        }
        return !this.onUpdate || !a || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData);
      },
      next: function (a) {
        if (undefined === a) {
          a = 1;
        }
        var b = this._frameIndex + a;
        if (b >= this._frames.length) {
          if (this.loop) {
            b %= this._frames.length;
          } else {
            b = this._frames.length - 1;
          }
        }
        if (b !== this._frameIndex) {
          this._frameIndex = b;
          this.updateCurrentFrame(true);
        }
      },
      previous: function (a) {
        if (undefined === a) {
          a = 1;
        }
        var b = this._frameIndex - a;
        if (b < 0) {
          if (this.loop) {
            b = this._frames.length + b;
          } else {
            b++;
          }
        }
        if (b !== this._frameIndex) {
          this._frameIndex = b;
          this.updateCurrentFrame(true);
        }
      },
      updateFrameData: function (a) {
        this._frameData = a;
        this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
      },
      destroy: function () {
        if (this._frameData) {
          this.game.onPause.remove(this.onPause, this);
          this.game.onResume.remove(this.onResume, this);
          this.game = null;
          this._parent = null;
          this._frames = null;
          this._frameData = null;
          this.currentFrame = null;
          this.isPlaying = false;
          this.onStart.dispose();
          this.onLoop.dispose();
          this.onComplete.dispose();
          if (this.onUpdate) {
            this.onUpdate.dispose();
          }
        }
      },
      complete: function () {
        this._frameIndex = this._frames.length - 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
        this.isPlaying = false;
        this.isFinished = true;
        this.paused = false;
        this._parent.events.onAnimationComplete$dispatch(this._parent, this);
        this.onComplete.dispatch(this._parent, this);
        if (this.killOnComplete) {
          this._parent.kill();
        }
      }
    };
    b.Animation.prototype.constructor = b.Animation;
    Object.defineProperty(b.Animation.prototype, "paused", {
      get: function () {
        return this.isPaused;
      },
      set: function (a) {
        this.isPaused = a;
        if (a) {
          this._pauseStartTime = this.game.time.time;
        } else if (this.isPlaying) {
          this._timeNextFrame = this.game.time.time + this.delay;
        }
      }
    });
    Object.defineProperty(b.Animation.prototype, "reversed", {
      get: function () {
        return this.isReversed;
      },
      set: function (a) {
        this.isReversed = a;
      }
    });
    Object.defineProperty(b.Animation.prototype, "frameTotal", {
      get: function () {
        return this._frames.length;
      }
    });
    Object.defineProperty(b.Animation.prototype, "frame", {
      get: function () {
        return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
      },
      set: function (a) {
        this.currentFrame = this._frameData.getFrame(this._frames[a]);
        if (null !== this.currentFrame) {
          this._frameIndex = a;
          this._parent.setFrame(this.currentFrame);
          if (this.onUpdate) {
            this.onUpdate.dispatch(this, this.currentFrame);
          }
        }
      }
    });
    Object.defineProperty(b.Animation.prototype, "speed", {
      get: function () {
        return 1e3 / this.delay;
      },
      set: function (a) {
        if (a > 0) {
          this.delay = 1e3 / a;
        }
      }
    });
    Object.defineProperty(b.Animation.prototype, "enableUpdate", {
      get: function () {
        return null !== this.onUpdate;
      },
      set: function (a) {
        if (a && null === this.onUpdate) {
          this.onUpdate = new b.Signal();
        } else if (!(a || null === this.onUpdate)) {
          this.onUpdate.dispose();
          this.onUpdate = null;
        }
      }
    });
    b.Animation.generateFrameNames = function (a, c, d, e, f) {
      if (undefined === e) {
        e = "";
      }
      var g = [];
      var h = "";
      if (c < d) {
        for (var i = c; i <= d; i++) {
          h = "number" == typeof f ? b.Utils.pad(i.toString(), f, "0", 1) : i.toString();
          h = a + h + e;
          g.push(h);
        }
      } else {
        for (var i = c; i >= d; i--) {
          h = "number" == typeof f ? b.Utils.pad(i.toString(), f, "0", 1) : i.toString();
          h = a + h + e;
          g.push(h);
        }
      }
      return g;
    };
    b.Frame = function (a, c, d, e, f, g) {
      this.index = a;
      this.x = c;
      this.y = d;
      this.width = e;
      this.height = f;
      this.name = g;
      this.centerX = Math.floor(e / 2);
      this.centerY = Math.floor(f / 2);
      this.distance = b.Math.distance(0, 0, e, f);
      this.rotated = false;
      this.rotationDirection = "cw";
      this.trimmed = false;
      this.sourceSizeW = e;
      this.sourceSizeH = f;
      this.spriteSourceSizeX = 0;
      this.spriteSourceSizeY = 0;
      this.spriteSourceSizeW = 0;
      this.spriteSourceSizeH = 0;
      this.right = this.x + this.width;
      this.bottom = this.y + this.height;
    };
    b.Frame.prototype = {
      resize: function (a, c) {
        this.width = a;
        this.height = c;
        this.centerX = Math.floor(a / 2);
        this.centerY = Math.floor(c / 2);
        this.distance = b.Math.distance(0, 0, a, c);
        this.sourceSizeW = a;
        this.sourceSizeH = c;
        this.right = this.x + a;
        this.bottom = this.y + c;
      },
      setTrim: function (a, b, c, d, e, f, g) {
        this.trimmed = a;
        if (a) {
          this.sourceSizeW = b;
          this.sourceSizeH = c;
          this.centerX = Math.floor(b / 2);
          this.centerY = Math.floor(c / 2);
          this.spriteSourceSizeX = d;
          this.spriteSourceSizeY = e;
          this.spriteSourceSizeW = f;
          this.spriteSourceSizeH = g;
        }
      },
      clone: function () {
        var a = new b.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
        for (var c in this) if (this.hasOwnProperty(c)) {
          a[c] = this[c];
        }
        return a;
      },
      getRect: function (a) {
        if (undefined === a) {
          a = new b.Rectangle(this.x, this.y, this.width, this.height);
        } else {
          a.setTo(this.x, this.y, this.width, this.height);
        }
        return a;
      }
    };
    b.Frame.prototype.constructor = b.Frame;
    b.FrameData = function () {
      this._frames = [];
      this._frameNames = [];
    };
    b.FrameData.prototype = {
      addFrame: function (a) {
        a.index = this._frames.length;
        this._frames.push(a);
        if ("" !== a.name) {
          this._frameNames[a.name] = a.index;
        }
        return a;
      },
      getFrame: function (a) {
        if (a >= this._frames.length) {
          a = 0;
        }
        return this._frames[a];
      },
      getFrameByName: function (a) {
        return "number" == typeof this._frameNames[a] ? this._frames[this._frameNames[a]] : null;
      },
      checkFrameName: function (a) {
        return null != this._frameNames[a];
      },
      clone: function () {
        var a = new b.FrameData();
        for (var c = 0; c < this._frames.length; c++) {
          a._frames.push(this._frames[c].clone());
        }
        for (var d in this._frameNames) if (this._frameNames.hasOwnProperty(d)) {
          a._frameNames.push(this._frameNames[d]);
        }
        return a;
      },
      getFrameRange: function (a, b, c) {
        if (undefined === c) {
          c = [];
        }
        for (var d = a; d <= b; d++) {
          c.push(this._frames[d]);
        }
        return c;
      },
      getFrames: function (a, b, c) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          c = [];
        }
        if (undefined === a || 0 === a.length) {
          for (var d = 0; d < this._frames.length; d++) {
            c.push(this._frames[d]);
          }
        } else {
          for (var d = 0; d < a.length; d++) {
            if (b) {
              c.push(this.getFrame(a[d]));
            } else {
              c.push(this.getFrameByName(a[d]));
            }
          }
        }
        return c;
      },
      getFrameIndexes: function (a, b, c) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          c = [];
        }
        if (undefined === a || 0 === a.length) {
          for (var d = 0; d < this._frames.length; d++) {
            c.push(this._frames[d].index);
          }
        } else {
          for (var d = 0; d < a.length; d++) {
            if (b && this._frames[a[d]]) {
              c.push(this._frames[a[d]].index);
            } else if (this.getFrameByName(a[d])) {
              c.push(this.getFrameByName(a[d]).index);
            }
          }
        }
        return c;
      },
      destroy: function () {
        this._frames = null;
        this._frameNames = null;
      }
    };
    b.FrameData.prototype.constructor = b.FrameData;
    Object.defineProperty(b.FrameData.prototype, "total", {
      get: function () {
        return this._frames.length;
      }
    });
    b.AnimationParser = {
      spriteSheet: function (a, c, d, e, f, g, h) {
        var i = c;
        if ("string" == typeof c) {
          i = a.cache.getImage(c);
        }
        if (null === i) {
          return null;
        }
        var j = i.width;
        var k = i.height;
        if (d <= 0) {
          d = Math.floor(-j / Math.min(-1, d));
        }
        if (e <= 0) {
          e = Math.floor(-k / Math.min(-1, e));
        }
        var l = Math.floor((j - g) / (d + h));
        var m = Math.floor((k - g) / (e + h));
        var n = l * m;
        if (-1 !== f) {
          n = f;
        }
        if (0 === j || 0 === k || j < d || k < e || 0 === n) {
          console.warn("Phaser.AnimationParser.spriteSheet: '" + c + "'s width/height zero or width/height < given frameWidth/frameHeight");
          return null;
        }
        var o = new b.FrameData();
        var p = g;
        var q = g;
        for (var r = 0; r < n; r++) {
          o.addFrame(new b.Frame(r, p, q, d, e, ""));
          if ((p += d + h) + d > j) {
            p = g;
            q += e + h;
          }
        }
        return o;
      },
      JSONData: function (a, c) {
        if (!c.frames) {
          console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
          return void console.log(c);
        }
        var f;
        var d = new b.FrameData();
        var e = c.frames;
        for (var g = 0; g < e.length; g++) {
          f = d.addFrame(new b.Frame(g, e[g].frame.x, e[g].frame.y, e[g].frame.w, e[g].frame.h, e[g].filename));
          if (e[g].trimmed) {
            f.setTrim(e[g].trimmed, e[g].sourceSize.w, e[g].sourceSize.h, e[g].spriteSourceSize.x, e[g].spriteSourceSize.y, e[g].spriteSourceSize.w, e[g].spriteSourceSize.h);
          }
        }
        return d;
      },
      JSONDataPyxel: function (a, c) {
        ["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function (a) {
          if (!c[a]) {
            console.warn("Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing \"" + a + "\" key.");
            return void console.log(c);
          }
        });
        if (1 !== c.layers.length) {
          console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.");
          return void console.log(c);
        }
        var i;
        var e = new b.FrameData();
        var f = c.tileheight;
        var g = c.tilewidth;
        var h = c.layers[0].tiles;
        for (var j = 0; j < h.length; j++) {
          i = e.addFrame(new b.Frame(j, h[j].x, h[j].y, g, f, "frame_" + j));
          i.setTrim(false);
        }
        return e;
      },
      JSONDataHash: function (a, c) {
        if (!c.frames) {
          console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
          return void console.log(c);
        }
        var f;
        var d = new b.FrameData();
        var e = c.frames;
        var g = 0;
        for (var h in e) {
          f = d.addFrame(new b.Frame(g, e[h].frame.x, e[h].frame.y, e[h].frame.w, e[h].frame.h, h));
          if (e[h].trimmed) {
            f.setTrim(e[h].trimmed, e[h].sourceSize.w, e[h].sourceSize.h, e[h].spriteSourceSize.x, e[h].spriteSourceSize.y, e[h].spriteSourceSize.w, e[h].spriteSourceSize.h);
          }
          g++;
        }
        return d;
      },
      XMLData: function (a, c) {
        if (!c.getElementsByTagName("TextureAtlas")) {
          return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
        }
        var f;
        var g;
        var h;
        var i;
        var j;
        var k;
        var l;
        var m;
        var n;
        var o;
        var p;
        var d = new b.FrameData();
        var e = c.getElementsByTagName("SubTexture");
        for (var q = 0; q < e.length; q++) {
          h = e[q].attributes;
          g = h.name.value;
          i = parseInt(h.x.value, 10);
          j = parseInt(h.y.value, 10);
          k = parseInt(h.width.value, 10);
          l = parseInt(h.height.value, 10);
          m = null;
          n = null;
          if (h.frameX) {
            m = Math.abs(parseInt(h.frameX.value, 10));
            n = Math.abs(parseInt(h.frameY.value, 10));
            o = parseInt(h.frameWidth.value, 10);
            p = parseInt(h.frameHeight.value, 10);
          }
          f = d.addFrame(new b.Frame(q, i, j, k, l, g));
          if (!(null === m && null === n)) {
            f.setTrim(true, k, l, m, n, o, p);
          }
        }
        return d;
      }
    };
    b.Cache = function (a) {
      this.game = a;
      this.autoResolveURL = false;
      this._cache = {
        canvas: {},
        image: {},
        texture: {},
        sound: {},
        video: {},
        text: {},
        json: {},
        xml: {},
        physics: {},
        tilemap: {},
        binary: {},
        bitmapData: {},
        bitmapFont: {},
        shader: {},
        renderTexture: {}
      };
      this._urlMap = {};
      this._urlResolver = new Image();
      this._urlTemp = null;
      this.onSoundUnlock = new b.Signal();
      this._cacheMap = [];
      this._cacheMap[b.Cache.CANVAS] = this._cache.canvas;
      this._cacheMap[b.Cache.IMAGE] = this._cache.image;
      this._cacheMap[b.Cache.TEXTURE] = this._cache.texture;
      this._cacheMap[b.Cache.SOUND] = this._cache.sound;
      this._cacheMap[b.Cache.TEXT] = this._cache.text;
      this._cacheMap[b.Cache.PHYSICS] = this._cache.physics;
      this._cacheMap[b.Cache.TILEMAP] = this._cache.tilemap;
      this._cacheMap[b.Cache.BINARY] = this._cache.binary;
      this._cacheMap[b.Cache.BITMAPDATA] = this._cache.bitmapData;
      this._cacheMap[b.Cache.BITMAPFONT] = this._cache.bitmapFont;
      this._cacheMap[b.Cache.JSON] = this._cache.json;
      this._cacheMap[b.Cache.XML] = this._cache.xml;
      this._cacheMap[b.Cache.VIDEO] = this._cache.video;
      this._cacheMap[b.Cache.SHADER] = this._cache.shader;
      this._cacheMap[b.Cache.RENDER_TEXTURE] = this._cache.renderTexture;
      this.addDefaultImage();
      this.addMissingImage();
    };
    b.Cache.CANVAS = 1;
    b.Cache.IMAGE = 2;
    b.Cache.TEXTURE = 3;
    b.Cache.SOUND = 4;
    b.Cache.TEXT = 5;
    b.Cache.PHYSICS = 6;
    b.Cache.TILEMAP = 7;
    b.Cache.BINARY = 8;
    b.Cache.BITMAPDATA = 9;
    b.Cache.BITMAPFONT = 10;
    b.Cache.JSON = 11;
    b.Cache.XML = 12;
    b.Cache.VIDEO = 13;
    b.Cache.SHADER = 14;
    b.Cache.RENDER_TEXTURE = 15;
    b.Cache.DEFAULT = null;
    b.Cache.MISSING = null;
    b.Cache.prototype = {
      addCanvas: function (a, b, c) {
        if (undefined === c) {
          c = b.getContext("2d");
        }
        this._cache.canvas[a] = {
          canvas: b,
          context: c
        };
      },
      addImage: function (a, c, d) {
        if (this.checkImageKey(a)) {
          this.removeImage(a);
        }
        var e = {
          key: a,
          url: c,
          data: d,
          base: new PIXI.BaseTexture(d),
          frame: new b.Frame(0, 0, 0, d.width, d.height, a),
          frameData: new b.FrameData()
        };
        e.frameData.addFrame(new b.Frame(0, 0, 0, d.width, d.height, c));
        this._cache.image[a] = e;
        this._resolveURL(c, e);
        if ("__default" === a) {
          b.Cache.DEFAULT = new PIXI.Texture(e.base);
        } else if ("__missing" === a) {
          b.Cache.MISSING = new PIXI.Texture(e.base);
        }
        return e;
      },
      addDefaultImage: function () {
        var a = new Image();
        a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
        var c = this.addImage("__default", null, a);
        c.base.skipRender = true;
        b.Cache.DEFAULT = new PIXI.Texture(c.base);
      },
      addMissingImage: function () {
        var a = new Image();
        a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
        var c = this.addImage("__missing", null, a);
        b.Cache.MISSING = new PIXI.Texture(c.base);
      },
      addSound: function (a, b, c, d, e) {
        if (undefined === d) {
          d = true;
          e = false;
        }
        if (undefined === e) {
          d = false;
          e = true;
        }
        var f = false;
        if (e) {
          f = true;
        }
        this._cache.sound[a] = {
          url: b,
          data: c,
          isDecoding: false,
          decoded: f,
          webAudio: d,
          audioTag: e,
          locked: this.game.sound.touchLocked
        };
        this._resolveURL(b, this._cache.sound[a]);
      },
      addText: function (a, b, c) {
        this._cache.text[a] = {
          url: b,
          data: c
        };
        this._resolveURL(b, this._cache.text[a]);
      },
      addPhysicsData: function (a, b, c, d) {
        this._cache.physics[a] = {
          url: b,
          data: c,
          format: d
        };
        this._resolveURL(b, this._cache.physics[a]);
      },
      addTilemap: function (a, b, c, d) {
        this._cache.tilemap[a] = {
          url: b,
          data: c,
          format: d
        };
        this._resolveURL(b, this._cache.tilemap[a]);
      },
      addBinary: function (a, b) {
        this._cache.binary[a] = b;
      },
      addBitmapData: function (a, c, d) {
        c.key = a;
        if (undefined === d) {
          d = new b.FrameData();
          d.addFrame(c.textureFrame);
        }
        this._cache.bitmapData[a] = {
          data: c,
          frameData: d
        };
        return c;
      },
      addBitmapFont: function (a, c, d, e, f, g, h) {
        var i = {
          url: c,
          data: d,
          font: null,
          base: new PIXI.BaseTexture(d)
        };
        if (undefined === g) {
          g = 0;
        }
        if (undefined === h) {
          h = 0;
        }
        i.font = "json" === f ? b.LoaderParser.jsonBitmapFont(e, i.base, g, h) : b.LoaderParser.xmlBitmapFont(e, i.base, g, h);
        this._cache.bitmapFont[a] = i;
        this._resolveURL(c, i);
      },
      addJSON: function (a, b, c) {
        this._cache.json[a] = {
          url: b,
          data: c
        };
        this._resolveURL(b, this._cache.json[a]);
      },
      addXML: function (a, b, c) {
        this._cache.xml[a] = {
          url: b,
          data: c
        };
        this._resolveURL(b, this._cache.xml[a]);
      },
      addVideo: function (a, b, c, d) {
        this._cache.video[a] = {
          url: b,
          data: c,
          isBlob: d,
          locked: true
        };
        this._resolveURL(b, this._cache.video[a]);
      },
      addShader: function (a, b, c) {
        this._cache.shader[a] = {
          url: b,
          data: c
        };
        this._resolveURL(b, this._cache.shader[a]);
      },
      addRenderTexture: function (a, c) {
        this._cache.renderTexture[a] = {
          texture: c,
          frame: new b.Frame(0, 0, 0, c.width, c.height, "", "")
        };
      },
      addSpriteSheet: function (a, c, d, e, f, g, h, i) {
        if (undefined === g) {
          g = -1;
        }
        if (undefined === h) {
          h = 0;
        }
        if (undefined === i) {
          i = 0;
        }
        var j = {
          key: a,
          url: c,
          data: d,
          frameWidth: e,
          frameHeight: f,
          margin: h,
          spacing: i,
          base: new PIXI.BaseTexture(d),
          frameData: b.AnimationParser.spriteSheet(this.game, d, e, f, g, h, i)
        };
        this._cache.image[a] = j;
        this._resolveURL(c, j);
      },
      addTextureAtlas: function (a, c, d, e, f) {
        var g = {
          key: a,
          url: c,
          data: d,
          base: new PIXI.BaseTexture(d)
        };
        if (f === b.Loader.TEXTURE_ATLAS_XML_STARLING) {
          g.frameData = b.AnimationParser.XMLData(this.game, e, a);
        } else if (f === b.Loader.TEXTURE_ATLAS_JSON_PYXEL) {
          g.frameData = b.AnimationParser.JSONDataPyxel(this.game, e, a);
        } else if (Array.isArray(e.frames)) {
          g.frameData = b.AnimationParser.JSONData(this.game, e, a);
        } else {
          g.frameData = b.AnimationParser.JSONDataHash(this.game, e, a);
        }
        this._cache.image[a] = g;
        this._resolveURL(c, g);
      },
      reloadSound: function (a) {
        var b = this;
        var c = this.getSound(a);
        if (c) {
          c.data.src = c.url;
          c.data.addEventListener("canplaythrough", function () {
            return b.reloadSoundComplete(a);
          }, false);
          c.data.load();
        }
      },
      reloadSoundComplete: function (a) {
        var b = this.getSound(a);
        if (b) {
          b.locked = false;
          this.onSoundUnlock.dispatch(a);
        }
      },
      updateSound: function (a, b, c) {
        var d = this.getSound(a);
        if (d) {
          d[b] = c;
        }
      },
      decodedSound: function (a, b) {
        var c = this.getSound(a);
        c.data = b;
        c.decoded = true;
        c.isDecoding = false;
      },
      isSoundDecoded: function (a) {
        var c = this.getItem(a, b.Cache.SOUND, "isSoundDecoded");
        if (c) {
          return c.decoded;
        }
      },
      isSoundReady: function (a) {
        var c = this.getItem(a, b.Cache.SOUND, "isSoundDecoded");
        if (c) {
          return c.decoded && !this.game.sound.touchLocked;
        }
      },
      checkKey: function (a, b) {
        return !!this._cacheMap[a][b];
      },
      checkURL: function (a) {
        return !!this._urlMap[this._resolveURL(a)];
      },
      checkCanvasKey: function (a) {
        return this.checkKey(b.Cache.CANVAS, a);
      },
      checkImageKey: function (a) {
        return this.checkKey(b.Cache.IMAGE, a);
      },
      checkTextureKey: function (a) {
        return this.checkKey(b.Cache.TEXTURE, a);
      },
      checkSoundKey: function (a) {
        return this.checkKey(b.Cache.SOUND, a);
      },
      checkTextKey: function (a) {
        return this.checkKey(b.Cache.TEXT, a);
      },
      checkPhysicsKey: function (a) {
        return this.checkKey(b.Cache.PHYSICS, a);
      },
      checkTilemapKey: function (a) {
        return this.checkKey(b.Cache.TILEMAP, a);
      },
      checkBinaryKey: function (a) {
        return this.checkKey(b.Cache.BINARY, a);
      },
      checkBitmapDataKey: function (a) {
        return this.checkKey(b.Cache.BITMAPDATA, a);
      },
      checkBitmapFontKey: function (a) {
        return this.checkKey(b.Cache.BITMAPFONT, a);
      },
      checkJSONKey: function (a) {
        return this.checkKey(b.Cache.JSON, a);
      },
      checkXMLKey: function (a) {
        return this.checkKey(b.Cache.XML, a);
      },
      checkVideoKey: function (a) {
        return this.checkKey(b.Cache.VIDEO, a);
      },
      checkShaderKey: function (a) {
        return this.checkKey(b.Cache.SHADER, a);
      },
      checkRenderTextureKey: function (a) {
        return this.checkKey(b.Cache.RENDER_TEXTURE, a);
      },
      getItem: function (a, b, c, d) {
        return this.checkKey(b, a) ? undefined === d ? this._cacheMap[b][a] : this._cacheMap[b][a][d] : (c && console.warn("Phaser.Cache." + c + ": Key \"" + a + "\" not found in Cache."), null);
      },
      getCanvas: function (a) {
        return this.getItem(a, b.Cache.CANVAS, "getCanvas", "canvas");
      },
      getImage: function (a, c) {
        if (!(undefined !== a && null !== a)) {
          a = "__default";
        }
        if (undefined === c) {
          c = false;
        }
        var d = this.getItem(a, b.Cache.IMAGE, "getImage");
        if (null === d) {
          d = this.getItem("__missing", b.Cache.IMAGE, "getImage");
        }
        return c ? d : d.data;
      },
      getTextureFrame: function (a) {
        return this.getItem(a, b.Cache.TEXTURE, "getTextureFrame", "frame");
      },
      getSound: function (a) {
        return this.getItem(a, b.Cache.SOUND, "getSound");
      },
      getSoundData: function (a) {
        return this.getItem(a, b.Cache.SOUND, "getSoundData", "data");
      },
      getText: function (a) {
        return this.getItem(a, b.Cache.TEXT, "getText", "data");
      },
      getPhysicsData: function (a, c, d) {
        var e = this.getItem(a, b.Cache.PHYSICS, "getPhysicsData", "data");
        if (null === e || undefined === c || null === c) {
          return e;
        }
        if (e[c]) {
          var f = e[c];
          if (!f || !d) {
            return f;
          }
          for (var g in f) {
            g = f[g];
            if (g.fixtureKey === d) {
              return g;
            }
          }
          console.warn("Phaser.Cache.getPhysicsData: Could not find given fixtureKey: \"" + d + " in " + a + "\"");
        } else {
          console.warn("Phaser.Cache.getPhysicsData: Invalid key/object: \"" + a + " / " + c + "\"");
        }
        return null;
      },
      getTilemapData: function (a) {
        return this.getItem(a, b.Cache.TILEMAP, "getTilemapData");
      },
      getBinary: function (a) {
        return this.getItem(a, b.Cache.BINARY, "getBinary");
      },
      getBitmapData: function (a) {
        return this.getItem(a, b.Cache.BITMAPDATA, "getBitmapData", "data");
      },
      getBitmapFont: function (a) {
        return this.getItem(a, b.Cache.BITMAPFONT, "getBitmapFont");
      },
      getJSON: function (a, c) {
        var d = this.getItem(a, b.Cache.JSON, "getJSON", "data");
        return d ? c ? b.Utils.extend(true, Array.isArray(d) ? [] : {}, d) : d : null;
      },
      getXML: function (a) {
        return this.getItem(a, b.Cache.XML, "getXML", "data");
      },
      getVideo: function (a) {
        return this.getItem(a, b.Cache.VIDEO, "getVideo");
      },
      getShader: function (a) {
        return this.getItem(a, b.Cache.SHADER, "getShader", "data");
      },
      getRenderTexture: function (a) {
        return this.getItem(a, b.Cache.RENDER_TEXTURE, "getRenderTexture");
      },
      getBaseTexture: function (a, c) {
        if (undefined === c) {
          c = b.Cache.IMAGE;
        }
        return this.getItem(a, c, "getBaseTexture", "base");
      },
      getFrame: function (a, c) {
        if (undefined === c) {
          c = b.Cache.IMAGE;
        }
        return this.getItem(a, c, "getFrame", "frame");
      },
      getFrameCount: function (a, b) {
        var c = this.getFrameData(a, b);
        return c ? c.total : 0;
      },
      getFrameData: function (a, c) {
        if (undefined === c) {
          c = b.Cache.IMAGE;
        }
        return this.getItem(a, c, "getFrameData", "frameData");
      },
      hasFrameData: function (a, c) {
        if (undefined === c) {
          c = b.Cache.IMAGE;
        }
        return null !== this.getItem(a, c, "", "frameData");
      },
      updateFrameData: function (a, c, d) {
        if (undefined === d) {
          d = b.Cache.IMAGE;
        }
        if (this._cacheMap[d][a]) {
          this._cacheMap[d][a].frameData = c;
        }
      },
      getFrameByIndex: function (a, b, c) {
        var d = this.getFrameData(a, c);
        return d ? d.getFrame(b) : null;
      },
      getFrameByName: function (a, b, c) {
        var d = this.getFrameData(a, c);
        return d ? d.getFrameByName(b) : null;
      },
      getURL: function (a) {
        var a = this._resolveURL(a);
        return a ? this._urlMap[a] : (console.warn("Phaser.Cache.getUrl: Invalid url: \"" + a + "\" or Cache.autoResolveURL was false"), null);
      },
      getKeys: function (a) {
        if (undefined === a) {
          a = b.Cache.IMAGE;
        }
        var c = [];
        if (this._cacheMap[a]) {
          for (var d in this._cacheMap[a]) if ("__default" !== d && "__missing" !== d) {
            c.push(d);
          }
        }
        return c;
      },
      removeCanvas: function (a) {
        delete this._cache.canvas[a];
      },
      removeImage: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        var c = this.getImage(a, true);
        if (b && c.base) {
          c.base.destroy();
        }
        delete this._cache.image[a];
      },
      removeSound: function (a) {
        delete this._cache.sound[a];
      },
      removeText: function (a) {
        delete this._cache.text[a];
      },
      removePhysics: function (a) {
        delete this._cache.physics[a];
      },
      removeTilemap: function (a) {
        delete this._cache.tilemap[a];
      },
      removeBinary: function (a) {
        delete this._cache.binary[a];
      },
      removeBitmapData: function (a) {
        delete this._cache.bitmapData[a];
      },
      removeBitmapFont: function (a) {
        delete this._cache.bitmapFont[a];
      },
      removeJSON: function (a) {
        delete this._cache.json[a];
      },
      removeXML: function (a) {
        delete this._cache.xml[a];
      },
      removeVideo: function (a) {
        delete this._cache.video[a];
      },
      removeShader: function (a) {
        delete this._cache.shader[a];
      },
      removeRenderTexture: function (a) {
        delete this._cache.renderTexture[a];
      },
      removeSpriteSheet: function (a) {
        delete this._cache.spriteSheet[a];
      },
      removeTextureAtlas: function (a) {
        delete this._cache.atlas[a];
      },
      clearGLTextures: function () {
        for (var a in this._cache.image) this._cache.image[a].base._glTextures = [];
      },
      _resolveURL: function (a, b) {
        return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + a, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", b && (this._urlMap[this._urlTemp] = b), this._urlTemp) : null;
      },
      destroy: function () {
        for (var a = 0; a < this._cacheMap.length; a++) {
          var b = this._cacheMap[a];
          for (var c in b) if ("__default" !== c && "__missing" !== c) {
            if (b[c].destroy) {
              b[c].destroy();
            }
            delete b[c];
          }
        }
        this._urlMap = null;
        this._urlResolver = null;
        this._urlTemp = null;
      }
    };
    b.Cache.prototype.constructor = b.Cache;
    b.Loader = function (a) {
      this.game = a;
      this.cache = a.cache;
      this.resetLocked = false;
      this.isLoading = false;
      this.hasLoaded = false;
      this.preloadSprite = null;
      this.crossOrigin = false;
      this.baseURL = "";
      this.path = "";
      this.headers = {
        requestedWith: false,
        json: "application/json",
        xml: "application/xml"
      };
      this.onLoadStart = new b.Signal();
      this.onLoadComplete = new b.Signal();
      this.onPackComplete = new b.Signal();
      this.onFileStart = new b.Signal();
      this.onFileComplete = new b.Signal();
      this.onFileError = new b.Signal();
      this.useXDomainRequest = false;
      this._warnedAboutXDomainRequest = false;
      this.enableParallel = true;
      this.maxParallelDownloads = 4;
      this._withSyncPointDepth = 0;
      this._fileList = [];
      this._flightQueue = [];
      this._processingHead = 0;
      this._fileLoadStarted = false;
      this._totalPackCount = 0;
      this._totalFileCount = 0;
      this._loadedPackCount = 0;
      this._loadedFileCount = 0;
    };
    b.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    b.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    b.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    b.Loader.PHYSICS_LIME_CORONA_JSON = 3;
    b.Loader.PHYSICS_PHASER_JSON = 4;
    b.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5;
    b.Loader.prototype = {
      setPreloadSprite: function (a, c) {
        c = c || 0;
        this.preloadSprite = {
          sprite: a,
          direction: c,
          width: a.width,
          height: a.height,
          rect: null
        };
        this.preloadSprite.rect = 0 === c ? new b.Rectangle(0, 0, 1, a.height) : new b.Rectangle(0, 0, a.width, 1);
        a.crop(this.preloadSprite.rect);
        a.visible = true;
      },
      resize: function () {
        if (this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height) {
          this.preloadSprite.rect.height = this.preloadSprite.sprite.height;
        }
      },
      checkKeyExists: function (a, b) {
        return this.getAssetIndex(a, b) > -1;
      },
      getAssetIndex: function (a, b) {
        var c = -1;
        for (var d = 0; d < this._fileList.length; d++) {
          var e = this._fileList[d];
          if (e.type === a && e.key === b && (c = d, !e.loaded && !e.loading)) {
            break;
          }
        }
        return c;
      },
      getAsset: function (a, b) {
        var c = this.getAssetIndex(a, b);
        return c > -1 && {
          index: c,
          file: this._fileList[c]
        };
      },
      reset: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (!this.resetLocked) {
          if (a) {
            this.preloadSprite = null;
          }
          this.isLoading = false;
          this._processingHead = 0;
          this._fileList.length = 0;
          this._flightQueue.length = 0;
          this._fileLoadStarted = false;
          this._totalFileCount = 0;
          this._totalPackCount = 0;
          this._loadedPackCount = 0;
          this._loadedFileCount = 0;
          if (b) {
            this.onLoadStart.removeAll();
            this.onLoadComplete.removeAll();
            this.onPackComplete.removeAll();
            this.onFileStart.removeAll();
            this.onFileComplete.removeAll();
            this.onFileError.removeAll();
          }
        }
      },
      addToFileList: function (a, b, c, d, e, f) {
        if (undefined === e) {
          e = false;
        }
        if (undefined === b || "" === b) {
          console.warn("Phaser.Loader: Invalid or no key given of type " + a);
          return this;
        }
        if (undefined === c || null === c) {
          if (!f) {
            console.warn("Phaser.Loader: No URL given for file type: " + a + " key: " + b);
            return this;
          }
          c = b + f;
        }
        var g = {
          type: a,
          key: b,
          path: this.path,
          url: c,
          syncPoint: this._withSyncPointDepth > 0,
          data: null,
          loading: false,
          loaded: false,
          error: false
        };
        if (d) {
          for (var h in d) g[h] = d[h];
        }
        var i = this.getAssetIndex(a, b);
        if (e && i > -1) {
          var j = this._fileList[i];
          if (j.loading || j.loaded) {
            this._fileList.push(g);
            this._totalFileCount++;
          } else {
            this._fileList[i] = g;
          }
        } else if (-1 === i) {
          this._fileList.push(g);
          this._totalFileCount++;
        }
        return this;
      },
      replaceInFileList: function (a, b, c, d) {
        return this.addToFileList(a, b, c, d, true);
      },
      pack: function (a, b, c, d) {
        if (undefined === b) {
          b = null;
        }
        if (undefined === c) {
          c = null;
        }
        if (undefined === d) {
          d = null;
        }
        if (!b && !c) {
          console.warn("Phaser.Loader.pack - Both url and data are null. One must be set.");
          return this;
        }
        var e = {
          type: "packfile",
          key: a,
          url: b,
          path: this.path,
          syncPoint: true,
          data: null,
          loading: false,
          loaded: false,
          error: false,
          callbackContext: d
        };
        if (c) {
          if ("string" == typeof c) {
            c = JSON.parse(c);
          }
          e.data = c || {};
          e.loaded = true;
        }
        for (var f = 0; f < this._fileList.length + 1; f++) {
          var g = this._fileList[f];
          if (!g || !g.loaded && !g.loading && "packfile" !== g.type) {
            this._fileList.splice(f, 0, e);
            this._totalPackCount++;
            break;
          }
        }
        return this;
      },
      image: function (a, b, c) {
        return this.addToFileList("image", a, b, undefined, c, ".png");
      },
      images: function (a, b) {
        if (Array.isArray(b)) {
          for (var c = 0; c < a.length; c++) {
            this.image(a[c], b[c]);
          }
        } else {
          for (var c = 0; c < a.length; c++) {
            this.image(a[c]);
          }
        }
        return this;
      },
      text: function (a, b, c) {
        return this.addToFileList("text", a, b, undefined, c, ".txt");
      },
      json: function (a, b, c) {
        return this.addToFileList("json", a, b, undefined, c, ".json");
      },
      shader: function (a, b, c) {
        return this.addToFileList("shader", a, b, undefined, c, ".frag");
      },
      xml: function (a, b, c) {
        return this.addToFileList("xml", a, b, undefined, c, ".xml");
      },
      script: function (a, b, c, d) {
        if (undefined === c) {
          c = false;
        }
        if (false !== c && undefined === d) {
          d = this;
        }
        return this.addToFileList("script", a, b, {
          syncPoint: true,
          callback: c,
          callbackContext: d
        }, false, ".js");
      },
      binary: function (a, b, c, d) {
        if (undefined === c) {
          c = false;
        }
        if (false !== c && undefined === c) {
          d = c;
        }
        return this.addToFileList("binary", a, b, {
          callback: c,
          callbackContext: c
        }, false, ".bin");
      },
      spritesheet: function (a, b, c, d, e, f, g) {
        if (undefined === e) {
          e = -1;
        }
        if (undefined === f) {
          f = 0;
        }
        if (undefined === g) {
          g = 0;
        }
        return this.addToFileList("spritesheet", a, b, {
          frameWidth: c,
          frameHeight: d,
          frameMax: e,
          margin: f,
          spacing: g
        }, false, ".png");
      },
      audio: function (a, b, c) {
        return this.game.sound.noAudio ? this : (undefined === c && (c = true), "string" == typeof b && (b = [b]), this.addToFileList("audio", a, b, {
          buffer: null,
          autoDecode: c
        }));
      },
      audioSprite: function (a, b, c, d, e) {
        return this.game.sound.noAudio ? this : (undefined === c && (c = null), undefined === d && (d = null), undefined === e && (e = true), this.audio(a, b, e), c ? this.json(a + "-audioatlas", c) : d ? ("string" == typeof d && (d = JSON.parse(d)), this.cache.addJSON(a + "-audioatlas", "", d)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this);
      },
      audiosprite: function (a, b, c, d, e) {
        return this.audioSprite(a, b, c, d, e);
      },
      video: function (a, b, c, d) {
        if (undefined === c) {
          c = this.game.device.firefox ? "loadeddata" : "canplaythrough";
        }
        if (undefined === d) {
          d = false;
        }
        if ("string" == typeof b) {
          b = [b];
        }
        return this.addToFileList("video", a, b, {
          buffer: null,
          asBlob: d,
          loadEvent: c
        });
      },
      tilemap: function (a, c, d, e) {
        if (undefined === c) {
          c = null;
        }
        if (undefined === d) {
          d = null;
        }
        if (undefined === e) {
          e = b.Tilemap.CSV;
        }
        if (!(c || d)) {
          c = e === b.Tilemap.CSV ? a + ".csv" : a + ".json";
        }
        if (d) {
          switch (e) {
            case b.Tilemap.CSV:
              break;
            case b.Tilemap.TILED_JSON:
              if ("string" == typeof d) {
                d = JSON.parse(d);
              }
          }
          this.cache.addTilemap(a, null, d, e);
        } else {
          this.addToFileList("tilemap", a, c, {
            format: e
          });
        }
        return this;
      },
      physics: function (a, c, d, e) {
        if (undefined === c) {
          c = null;
        }
        if (undefined === d) {
          d = null;
        }
        if (undefined === e) {
          e = b.Physics.LIME_CORONA_JSON;
        }
        if (!(c || d)) {
          c = a + ".json";
        }
        if (d) {
          if ("string" == typeof d) {
            d = JSON.parse(d);
          }
          this.cache.addPhysicsData(a, null, d, e);
        } else {
          this.addToFileList("physics", a, c, {
            format: e
          });
        }
        return this;
      },
      bitmapFont: function (a, b, c, d, e, f) {
        if (!(undefined !== b && null !== b)) {
          b = a + ".png";
        }
        if (undefined === c) {
          c = null;
        }
        if (undefined === d) {
          d = null;
        }
        if (null === c && null === d) {
          c = a + ".xml";
        }
        if (undefined === e) {
          e = 0;
        }
        if (undefined === f) {
          f = 0;
        }
        if (c) {
          this.addToFileList("bitmapfont", a, b, {
            atlasURL: c,
            xSpacing: e,
            ySpacing: f
          });
        } else if ("string" == typeof d) {
          var g;
          var h;
          try {
            g = JSON.parse(d);
          } catch (a) {
            h = this.parseXml(d);
          }
          if (!h && !g) {
            throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
          }
          this.addToFileList("bitmapfont", a, b, {
            atlasURL: null,
            atlasData: g || h,
            atlasType: g ? "json" : "xml",
            xSpacing: e,
            ySpacing: f
          });
        }
        return this;
      },
      atlasJSONArray: function (a, c, d, e) {
        return this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_JSON_ARRAY);
      },
      atlasJSONHash: function (a, c, d, e) {
        return this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_JSON_HASH);
      },
      atlasXML: function (a, c, d, e) {
        if (undefined === d) {
          d = null;
        }
        if (undefined === e) {
          e = null;
        }
        if (!(d || e)) {
          d = a + ".xml";
        }
        return this.atlas(a, c, d, e, b.Loader.TEXTURE_ATLAS_XML_STARLING);
      },
      atlas: function (a, c, d, e, f) {
        if (!(undefined !== c && null !== c)) {
          c = a + ".png";
        }
        if (undefined === d) {
          d = null;
        }
        if (undefined === e) {
          e = null;
        }
        if (undefined === f) {
          f = b.Loader.TEXTURE_ATLAS_JSON_ARRAY;
        }
        if (!(d || e)) {
          d = f === b.Loader.TEXTURE_ATLAS_XML_STARLING ? a + ".xml" : a + ".json";
        }
        if (d) {
          this.addToFileList("textureatlas", a, c, {
            atlasURL: d,
            format: f
          });
        } else {
          switch (f) {
            case b.Loader.TEXTURE_ATLAS_JSON_ARRAY:
              if ("string" == typeof e) {
                e = JSON.parse(e);
              }
              break;
            case b.Loader.TEXTURE_ATLAS_XML_STARLING:
              if ("string" == typeof e) {
                var g = this.parseXml(e);
                if (!g) {
                  throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                }
                e = g;
              }
          }
          this.addToFileList("textureatlas", a, c, {
            atlasURL: null,
            atlasData: e,
            format: f
          });
        }
        return this;
      },
      withSyncPoint: function (a, b) {
        this._withSyncPointDepth++;
        try {
          a.call(b || this, this);
        } finally {
          this._withSyncPointDepth--;
        }
        return this;
      },
      addSyncPoint: function (a, b) {
        var c = this.getAsset(a, b);
        if (c) {
          c.file.syncPoint = true;
        }
        return this;
      },
      removeFile: function (a, b) {
        var c = this.getAsset(a, b);
        if (c) {
          if (!(c.loaded || c.loading)) {
            this._fileList.splice(c.index, 1);
          }
        }
      },
      removeAll: function () {
        this._fileList.length = 0;
        this._flightQueue.length = 0;
      },
      start: function () {
        if (!this.isLoading) {
          this.hasLoaded = false;
          this.isLoading = true;
          this.updateProgress();
          this.processLoadQueue();
        }
      },
      processLoadQueue: function () {
        if (!this.isLoading) {
          console.warn("Phaser.Loader - active loading canceled / reset");
          return void this.finishedLoading(true);
        }
        for (var a = 0; a < this._flightQueue.length; a++) {
          var c = this._flightQueue[a];
          if (c.loaded || c.error) {
            this._flightQueue.splice(a, 1);
            a--;
            c.loading = false;
            c.requestUrl = null;
            c.requestObject = null;
            if (c.error) {
              this.onFileError.dispatch(c.key, c);
            }
            if ("packfile" !== c.type) {
              this._loadedFileCount++;
              this.onFileComplete.dispatch(this.progress, c.key, !c.error, this._loadedFileCount, this._totalFileCount);
            } else if ("packfile" === c.type && c.error) {
              this._loadedPackCount++;
              this.onPackComplete.dispatch(c.key, !c.error, this._loadedPackCount, this._totalPackCount);
            }
          }
        }
        var d = false;
        var e = this.enableParallel ? b.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
        for (var a = this._processingHead; a < this._fileList.length; a++) {
          var c = this._fileList[a];
          if ("packfile" === c.type && !c.error && c.loaded && a === this._processingHead) {
            this.processPack(c);
            this._loadedPackCount++;
            this.onPackComplete.dispatch(c.key, !c.error, this._loadedPackCount, this._totalPackCount);
          }
          if (c.loaded || c.error) {
            if (a === this._processingHead) {
              this._processingHead = a + 1;
            }
          } else if (!c.loading && this._flightQueue.length < e) {
            if ("packfile" !== c.type || c.data) {
              if (!d) {
                if (!this._fileLoadStarted) {
                  this._fileLoadStarted = true;
                  this.onLoadStart.dispatch();
                }
                this._flightQueue.push(c);
                c.loading = true;
                this.onFileStart.dispatch(this.progress, c.key, c.url);
                this.loadFile(c);
              }
            } else {
              this._flightQueue.push(c);
              c.loading = true;
              this.loadFile(c);
            }
          }
          if (!c.loaded && c.syncPoint) {
            d = true;
          }
          if (this._flightQueue.length >= e || d && this._loadedPackCount === this._totalPackCount) {
            break;
          }
        }
        this.updateProgress();
        if (this._processingHead >= this._fileList.length) {
          this.finishedLoading();
        } else if (!this._flightQueue.length) {
          console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
          var f = this;
          setTimeout(function () {
            f.finishedLoading(true);
          }, 2e3);
        }
      },
      finishedLoading: function (a) {
        if (!this.hasLoaded) {
          this.hasLoaded = true;
          this.isLoading = false;
          if (!(a || this._fileLoadStarted)) {
            this._fileLoadStarted = true;
            this.onLoadStart.dispatch();
          }
          this.onLoadComplete.dispatch();
          this.game.state.loadComplete();
          this.reset();
        }
      },
      asyncComplete: function (a, b) {
        if (undefined === b) {
          b = "";
        }
        a.loaded = true;
        a.error = !!b;
        if (b) {
          a.errorMessage = b;
          console.warn("Phaser.Loader - iren " + a.type + "[" + a.key + "]ni: " + b);
        }
        this.processLoadQueue();
      },
      processPack: function (a) {
        var c = a.data[a.key];
        if (!c) {
          return void console.warn("Phaser.Loader - " + a.key + ": pack has data, but not for pack key");
        }
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          switch (e.type) {
            case "image":
              this.image(e.key, e.url, e.overwrite);
              break;
            case "text":
              this.text(e.key, e.url, e.overwrite);
              break;
            case "json":
              this.json(e.key, e.url, e.overwrite);
              break;
            case "xml":
              this.xml(e.key, e.url, e.overwrite);
              break;
            case "script":
              this.script(e.key, e.url, e.callback, a.callbackContext || this);
              break;
            case "binary":
              this.binary(e.key, e.url, e.callback, a.callbackContext || this);
              break;
            case "spritesheet":
              this.spritesheet(e.key, e.url, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing);
              break;
            case "video":
              this.video(e.key, e.urls);
              break;
            case "audio":
              this.audio(e.key, e.urls, e.autoDecode);
              break;
            case "audiosprite":
              this.audiosprite(e.key, e.urls, e.jsonURL, e.jsonData, e.autoDecode);
              break;
            case "tilemap":
              this.tilemap(e.key, e.url, e.data, b.Tilemap[e.format]);
              break;
            case "physics":
              this.physics(e.key, e.url, e.data, b.Loader[e.format]);
              break;
            case "bitmapFont":
              this.bitmapFont(e.key, e.textureURL, e.atlasURL, e.atlasData, e.xSpacing, e.ySpacing);
              break;
            case "atlasJSONArray":
              this.atlasJSONArray(e.key, e.textureURL, e.atlasURL, e.atlasData);
              break;
            case "atlasJSONHash":
              this.atlasJSONHash(e.key, e.textureURL, e.atlasURL, e.atlasData);
              break;
            case "atlasXML":
              this.atlasXML(e.key, e.textureURL, e.atlasURL, e.atlasData);
              break;
            case "atlas":
              this.atlas(e.key, e.textureURL, e.atlasURL, e.atlasData, b.Loader[e.format]);
              break;
            case "shader":
              this.shader(e.key, e.url, e.overwrite);
          }
        }
      },
      transformUrl: function (a, b) {
        return !!a && (a.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? a : this.baseURL + b.path + a);
      },
      loadFile: function (a) {
        switch (a.type) {
          case "packfile":
            this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
            break;
          case "image":
          case "spritesheet":
          case "textureatlas":
          case "bitmapfont":
            this.loadImageTag(a);
            break;
          case "audio":
            a.url = this.getAudioURL(a.url);
            if (a.url) {
              if (this.game.sound.usingWebAudio) {
                this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
              } else if (this.game.sound.usingAudioTag) {
                this.loadAudioTag(a);
              }
            } else {
              this.fileError(a, null, "No supported audio URL specified or device does not have audio playback support");
            }
            break;
          case "video":
            a.url = this.getVideoURL(a.url);
            if (a.url) {
              if (a.asBlob) {
                this.xhrLoad(a, this.transformUrl(a.url, a), "blob", this.fileComplete);
              } else {
                this.loadVideoTag(a);
              }
            } else {
              this.fileError(a, null, "No supported video URL specified or device does not have video playback support");
            }
            break;
          case "json":
            this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
            break;
          case "xml":
            this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.xmlLoadComplete);
            break;
          case "tilemap":
            if (a.format === b.Tilemap.TILED_JSON) {
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.jsonLoadComplete);
            } else if (a.format === b.Tilemap.CSV) {
              this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.csvLoadComplete);
            } else {
              this.asyncComplete(a, "invalid Tilemap format: " + a.format);
            }
            break;
          case "text":
          case "script":
          case "shader":
          case "physics":
            this.xhrLoad(a, this.transformUrl(a.url, a), "text", this.fileComplete);
            break;
          case "binary":
            this.xhrLoad(a, this.transformUrl(a.url, a), "arraybuffer", this.fileComplete);
        }
      },
      loadImageTag: function (a) {
        var b = this;
        a.data = new Image();
        a.data.name = a.key;
        if (this.crossOrigin) {
          a.data.crossOrigin = this.crossOrigin;
        }
        a.data.onload = function () {
          if (a.data.onload) {
            a.data.onload = null;
            a.data.onerror = null;
            b.fileComplete(a);
          }
        };
        a.data.onerror = function () {
          if (a.data.onload) {
            a.data.onload = null;
            a.data.onerror = null;
            b.fileError(a);
          }
        };
        a.data.src = this.transformUrl(a.url, a);
        if (a.data.complete && a.data.width && a.data.height) {
          a.data.onload = null;
          a.data.onerror = null;
          this.fileComplete(a);
        }
      },
      loadVideoTag: function (a) {
        var c = this;
        a.data = document.createElement("video");
        a.data.name = a.key;
        a.data.controls = false;
        a.data.autoplay = false;
        var d = function () {
          a.data.removeEventListener(a.loadEvent, d, false);
          a.data.onerror = null;
          a.data.canplay = true;
          b.GAMES[c.game.id].load.fileComplete(a);
        };
        a.data.onerror = function () {
          a.data.removeEventListener(a.loadEvent, d, false);
          a.data.onerror = null;
          a.data.canplay = false;
          c.fileError(a);
        };
        a.data.addEventListener(a.loadEvent, d, false);
        a.data.src = this.transformUrl(a.url, a);
        a.data.load();
      },
      loadAudioTag: function (a) {
        var b = this;
        if (this.game.sound.touchLocked) {
          a.data = new Audio();
          a.data.name = a.key;
          a.data.preload = "auto";
          a.data.src = this.transformUrl(a.url, a);
          this.fileComplete(a);
        } else {
          a.data = new Audio();
          a.data.name = a.key;
          var c = function () {
            a.data.removeEventListener("canplaythrough", c, false);
            a.data.onerror = null;
            b.fileComplete(a);
          };
          a.data.onerror = function () {
            a.data.removeEventListener("canplaythrough", c, false);
            a.data.onerror = null;
            b.fileError(a);
          };
          a.data.preload = "auto";
          a.data.src = this.transformUrl(a.url, a);
          a.data.addEventListener("canplaythrough", c, false);
          a.data.load();
        }
      },
      xhrLoad: function (a, b, c, d, e) {
        if (this.useXDomainRequest && window.XDomainRequest) {
          return void this.xhrLoadWithXDR(a, b, c, d, e);
        }
        var f = new XMLHttpRequest();
        f.open("GET", b, true);
        f.responseType = c;
        if (false !== this.headers.requestedWith) {
          f.setRequestHeader("X-Requested-With", this.headers.requestedWith);
        }
        if (this.headers[a.type]) {
          f.setRequestHeader("Accept", this.headers[a.type]);
        }
        e = e || this.fileError;
        var g = this;
        f.onload = function () {
          try {
            return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
          } catch (b) {
            if (g.hasLoaded) {
              if (window.console) {
                console.error(b);
              }
            } else {
              g.asyncComplete(a, b.message || "Exception");
            }
          }
        };
        f.onerror = function () {
          try {
            return e.call(g, a, f);
          } catch (b) {
            if (g.hasLoaded) {
              if (window.console) {
                console.error(b);
              }
            } else {
              g.asyncComplete(a, b.message || "Exception");
            }
          }
        };
        a.requestObject = f;
        a.requestUrl = b;
        f.send();
      },
      xhrLoadWithXDR: function (a, b, c, d, e) {
        if (!(this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10))) {
          this._warnedAboutXDomainRequest = true;
          console.warn("Phaser.Loader - using XDomainRequest outside of IE 9");
        }
        var f = new window.XDomainRequest();
        f.open("GET", b, true);
        f.responseType = c;
        f.timeout = 3e3;
        e = e || this.fileError;
        var g = this;
        f.onerror = function () {
          try {
            return e.call(g, a, f);
          } catch (b) {
            g.asyncComplete(a, b.message || "Exception");
          }
        };
        f.ontimeout = function () {
          try {
            return e.call(g, a, f);
          } catch (b) {
            g.asyncComplete(a, b.message || "Exception");
          }
        };
        f.onprogress = function () {};
        f.onload = function () {
          try {
            return 4 === f.readyState && f.status >= 400 && f.status <= 599 ? e.call(g, a, f) : d.call(g, a, f);
          } catch (b) {
            g.asyncComplete(a, b.message || "Exception");
          }
        };
        a.requestObject = f;
        a.requestUrl = b;
        setTimeout(function () {
          f.send();
        }, 0);
      },
      getVideoURL: function (a) {
        for (var b = 0; b < a.length; b++) {
          var d;
          var c = a[b];
          if (c.uri) {
            d = c.type;
            c = c.uri;
            if (this.game.device.canPlayVideo(d)) {
              return c;
            }
          } else {
            if (0 === c.indexOf("blob:") || 0 === c.indexOf("data:")) {
              return c;
            }
            if (c.indexOf("?") >= 0) {
              c = c.substr(0, c.indexOf("?"));
            }
            d = c.substr((Math.max(0, c.lastIndexOf(".")) || Infinity) + 1).toLowerCase();
            if (this.game.device.canPlayVideo(d)) {
              return a[b];
            }
          }
        }
        return null;
      },
      getAudioURL: function (a) {
        if (this.game.sound.noAudio) {
          return null;
        }
        for (var b = 0; b < a.length; b++) {
          var d;
          var c = a[b];
          if (c.uri) {
            d = c.type;
            c = c.uri;
            if (this.game.device.canPlayAudio(d)) {
              return c;
            }
          } else {
            if (0 === c.indexOf("blob:") || 0 === c.indexOf("data:")) {
              return c;
            }
            if (c.indexOf("?") >= 0) {
              c = c.substr(0, c.indexOf("?"));
            }
            d = c.substr((Math.max(0, c.lastIndexOf(".")) || Infinity) + 1).toLowerCase();
            if (this.game.device.canPlayAudio(d)) {
              return a[b];
            }
          }
        }
        return null;
      },
      fileError: function (a, b, c) {
        var d = a.requestUrl || this.transformUrl(a.url, a);
        var e = "error loading asset from URL " + d;
        if (!c && b) {
          c = b.status;
        }
        if (c) {
          e = e + " (" + c + ")";
        }
        this.asyncComplete(a, e);
      },
      fileComplete: function (a, c) {
        var d = true;
        switch (a.type) {
          case "packfile":
            var e = JSON.parse(c.responseText);
            a.data = e || {};
            break;
          case "image":
            this.cache.addImage(a.key, a.url, a.data);
            break;
          case "spritesheet":
            this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
            break;
          case "textureatlas":
            if (null == a.atlasURL) {
              this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
            } else {
              d = false;
              if (a.format === b.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format === b.Loader.TEXTURE_ATLAS_JSON_HASH || a.format === b.Loader.TEXTURE_ATLAS_JSON_PYXEL) {
                this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
              } else {
                if (a.format !== b.Loader.TEXTURE_ATLAS_XML_STARLING) {
                  throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                }
                this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete);
              }
            }
            break;
          case "bitmapfont":
            if (a.atlasURL) {
              d = false;
              this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function (a, b) {
                var c;
                try {
                  c = JSON.parse(b.responseText);
                } catch (a) {}
                if (c) {
                  a.atlasType = "json";
                  this.jsonLoadComplete(a, b);
                } else {
                  a.atlasType = "xml";
                  this.xmlLoadComplete(a, b);
                }
              });
            } else {
              this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
            }
            break;
          case "video":
            if (a.asBlob) {
              try {
                a.data = c.response;
              } catch (b) {
                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key);
              }
            }
            this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
            break;
          case "audio":
            if (this.game.sound.usingWebAudio) {
              a.data = c.response;
              this.cache.addSound(a.key, a.url, a.data, true, false);
              if (a.autoDecode) {
                this.game.sound.decode(a.key);
              }
            } else {
              this.cache.addSound(a.key, a.url, a.data, false, true);
            }
            break;
          case "text":
            a.data = c.responseText;
            this.cache.addText(a.key, a.url, a.data);
            break;
          case "shader":
            a.data = c.responseText;
            this.cache.addShader(a.key, a.url, a.data);
            break;
          case "physics":
            var e = JSON.parse(c.responseText);
            this.cache.addPhysicsData(a.key, a.url, e, a.format);
            break;
          case "script":
            a.data = document.createElement("script");
            a.data.language = "javascript";
            a.data.type = "text/javascript";
            a.data.defer = false;
            a.data.text = c.responseText;
            document.head.appendChild(a.data);
            if (a.callback) {
              a.data = a.callback.call(a.callbackContext, a.key, c.responseText);
            }
            break;
          case "binary":
            if (a.callback) {
              a.data = a.callback.call(a.callbackContext, a.key, c.response);
            } else {
              a.data = c.response;
            }
            this.cache.addBinary(a.key, a.data);
        }
        if (d) {
          this.asyncComplete(a);
        }
      },
      jsonLoadComplete: function (a, b) {
        var c = JSON.parse(b.responseText);
        if ("tilemap" === a.type) {
          this.cache.addTilemap(a.key, a.url, c, a.format);
        } else if ("bitmapfont" === a.type) {
          this.cache.addBitmapFont(a.key, a.url, a.data, c, a.atlasType, a.xSpacing, a.ySpacing);
        } else if ("json" === a.type) {
          this.cache.addJSON(a.key, a.url, c);
        } else {
          this.cache.addTextureAtlas(a.key, a.url, a.data, c, a.format);
        }
        this.asyncComplete(a);
      },
      csvLoadComplete: function (a, b) {
        var c = b.responseText;
        this.cache.addTilemap(a.key, a.url, c, a.format);
        this.asyncComplete(a);
      },
      xmlLoadComplete: function (a, b) {
        var c = b.responseText;
        var d = this.parseXml(c);
        if (!d) {
          var e = b.responseType || b.contentType;
          console.warn("Phaser.Loader - " + a.key + ": invalid XML (" + e + ")");
          return void this.asyncComplete(a, "invalid XML");
        }
        if ("bitmapfont" === a.type) {
          this.cache.addBitmapFont(a.key, a.url, a.data, d, a.atlasType, a.xSpacing, a.ySpacing);
        } else if ("textureatlas" === a.type) {
          this.cache.addTextureAtlas(a.key, a.url, a.data, d, a.format);
        } else if ("xml" === a.type) {
          this.cache.addXML(a.key, a.url, d);
        }
        this.asyncComplete(a);
      },
      parseXml: function (a) {
        var b;
        try {
          if (window.DOMParser) {
            var c = new DOMParser();
            b = c.parseFromString(a, "text/xml");
          } else {
            b = new ActiveXObject("Microsoft.XMLDOM");
            b.async = "false";
            b.loadXML(a);
          }
        } catch (a) {
          b = null;
        }
        return b && b.documentElement && !b.getElementsByTagName("parsererror").length ? b : null;
      },
      updateProgress: function () {
        if (this.preloadSprite) {
          if (0 === this.preloadSprite.direction) {
            this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
          } else {
            this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
          }
          if (this.preloadSprite.sprite) {
            this.preloadSprite.sprite.updateCrop();
          } else {
            this.preloadSprite = null;
          }
        }
      },
      totalLoadedFiles: function () {
        return this._loadedFileCount;
      },
      totalQueuedFiles: function () {
        return this._totalFileCount - this._loadedFileCount;
      },
      totalLoadedPacks: function () {
        return this._totalPackCount;
      },
      totalQueuedPacks: function () {
        return this._totalPackCount - this._loadedPackCount;
      }
    };
    Object.defineProperty(b.Loader.prototype, "progressFloat", {
      get: function () {
        var a = this._loadedFileCount / this._totalFileCount * 100;
        return b.Math.clamp(a || 0, 0, 100);
      }
    });
    Object.defineProperty(b.Loader.prototype, "progress", {
      get: function () {
        return Math.round(this.progressFloat);
      }
    });
    b.Loader.prototype.constructor = b.Loader;
    b.LoaderParser = {
      bitmapFont: function (a, b, c, d) {
        return this.xmlBitmapFont(a, b, c, d);
      },
      xmlBitmapFont: function (a, b, c, d) {
        var e = {};
        var f = a.getElementsByTagName("info")[0];
        var g = a.getElementsByTagName("common")[0];
        e.font = f.getAttribute("face");
        e.size = parseInt(f.getAttribute("size"), 10);
        e.lineHeight = parseInt(g.getAttribute("lineHeight"), 10) + d;
        e.chars = {};
        var h = a.getElementsByTagName("char");
        for (var i = 0; i < h.length; i++) {
          var j = parseInt(h[i].getAttribute("id"), 10);
          e.chars[j] = {
            x: parseInt(h[i].getAttribute("x"), 10),
            y: parseInt(h[i].getAttribute("y"), 10),
            width: parseInt(h[i].getAttribute("width"), 10),
            height: parseInt(h[i].getAttribute("height"), 10),
            xOffset: parseInt(h[i].getAttribute("xoffset"), 10),
            yOffset: parseInt(h[i].getAttribute("yoffset"), 10),
            xAdvance: parseInt(h[i].getAttribute("xadvance"), 10) + c,
            kerning: {}
          };
        }
        var k = a.getElementsByTagName("kerning");
        for (i = 0; i < k.length; i++) {
          var l = parseInt(k[i].getAttribute("first"), 10);
          var m = parseInt(k[i].getAttribute("second"), 10);
          var n = parseInt(k[i].getAttribute("amount"), 10);
          e.chars[m].kerning[l] = n;
        }
        return this.finalizeBitmapFont(b, e);
      },
      jsonBitmapFont: function (a, b, c, d) {
        var e = {
          font: a.font.info._face,
          size: parseInt(a.font.info._size, 10),
          lineHeight: parseInt(a.font.common._lineHeight, 10) + d,
          chars: {}
        };
        a.font.chars.char.forEach(function (b) {
          var d = parseInt(b._id, 10);
          e.chars[d] = {
            x: parseInt(b._x, 10),
            y: parseInt(b._y, 10),
            width: parseInt(b._width, 10),
            height: parseInt(b._height, 10),
            xOffset: parseInt(b._xoffset, 10),
            yOffset: parseInt(b._yoffset, 10),
            xAdvance: parseInt(b._xadvance, 10) + c,
            kerning: {}
          };
        });
        if (a.font.kernings && a.font.kernings.kerning) {
          a.font.kernings.kerning.forEach(function (b) {
            e.chars[b._second].kerning[b._first] = parseInt(b._amount, 10);
          });
        }
        return this.finalizeBitmapFont(b, e);
      },
      finalizeBitmapFont: function (a, c) {
        Object.keys(c.chars).forEach(function (e) {
          var f = c.chars[e];
          f.texture = new PIXI.Texture(a, new b.Rectangle(f.x, f.y, f.width, f.height));
        });
        return c;
      }
    };
    b.AudioSprite = function (a, b) {
      this.game = a;
      this.key = b;
      this.config = this.game.cache.getJSON(b + "-audioatlas");
      this.autoplayKey = null;
      this.autoplay = false;
      this.sounds = {};
      for (var c in this.config.spritemap) {
        var d = this.config.spritemap[c];
        var e = this.game.add.sound(this.key);
        e.addMarker(c, d.start, d.end - d.start, null, d.loop);
        this.sounds[c] = e;
      }
      if (this.config.autoplay) {
        this.autoplayKey = this.config.autoplay;
        this.play(this.autoplayKey);
        this.autoplay = this.sounds[this.autoplayKey];
      }
    };
    b.AudioSprite.prototype = {
      play: function (a, b) {
        if (undefined === b) {
          b = 1;
        }
        return this.sounds[a].play(a, null, b);
      },
      stop: function (a) {
        if (a) {
          this.sounds[a].stop();
        } else {
          for (var b in this.sounds) this.sounds[b].stop();
        }
      },
      get: function (a) {
        return this.sounds[a];
      }
    };
    b.AudioSprite.prototype.constructor = b.AudioSprite;
    b.Sound = function (a, c, d, e, f) {
      if (undefined === d) {
        d = 1;
      }
      if (undefined === e) {
        e = false;
      }
      if (undefined === f) {
        f = a.sound.connectToMaster;
      }
      this.game = a;
      this.name = c;
      this.key = c;
      this.loop = e;
      this.markers = {};
      this.context = null;
      this.autoplay = false;
      this.totalDuration = 0;
      this.startTime = 0;
      this.currentTime = 0;
      this.duration = 0;
      this.durationMS = 0;
      this.position = 0;
      this.stopTime = 0;
      this.paused = false;
      this.pausedPosition = 0;
      this.pausedTime = 0;
      this.isPlaying = false;
      this.currentMarker = "";
      this.fadeTween = null;
      this.pendingPlayback = false;
      this.override = false;
      this.allowMultiple = false;
      this.usingWebAudio = this.game.sound.usingWebAudio;
      this.usingAudioTag = this.game.sound.usingAudioTag;
      this.externalNode = null;
      this.masterGainNode = null;
      this.gainNode = null;
      this._sound = null;
      if (this.usingWebAudio) {
        this.context = this.game.sound.context;
        this.masterGainNode = this.game.sound.masterGain;
        if (undefined === this.context.createGain) {
          this.gainNode = this.context.createGainNode();
        } else {
          this.gainNode = this.context.createGain();
        }
        this.gainNode.gain.value = d * this.game.sound.volume;
        if (f) {
          this.gainNode.connect(this.masterGainNode);
        }
      } else if (this.usingAudioTag) {
        if (this.game.cache.getSound(c) && this.game.cache.isSoundReady(c)) {
          this._sound = this.game.cache.getSoundData(c);
          this.totalDuration = 0;
          if (this._sound.duration) {
            this.totalDuration = this._sound.duration;
          }
        } else {
          this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
        }
      }
      this.onDecoded = new b.Signal();
      this.onPlay = new b.Signal();
      this.onPause = new b.Signal();
      this.onResume = new b.Signal();
      this.onLoop = new b.Signal();
      this.onStop = new b.Signal();
      this.onMute = new b.Signal();
      this.onMarkerComplete = new b.Signal();
      this.onFadeComplete = new b.Signal();
      this._volume = d;
      this._buffer = null;
      this._muted = false;
      this._tempMarker = 0;
      this._tempPosition = 0;
      this._tempVolume = 0;
      this._tempPause = 0;
      this._muteVolume = 0;
      this._tempLoop = 0;
      this._paused = false;
      this._onDecodedEventDispatched = false;
    };
    b.Sound.prototype = {
      soundHasUnlocked: function (a) {
        if (a === this.key) {
          this._sound = this.game.cache.getSoundData(this.key);
          this.totalDuration = this._sound.duration;
        }
      },
      addMarker: function (a, b, c, d, e) {
        if (!(undefined !== c && null !== c)) {
          c = 1;
        }
        if (!(undefined !== d && null !== d)) {
          d = 1;
        }
        if (undefined === e) {
          e = false;
        }
        this.markers[a] = {
          name: a,
          start: b,
          stop: b + c,
          volume: d,
          duration: c,
          durationMS: 1e3 * c,
          loop: e
        };
      },
      removeMarker: function (a) {
        delete this.markers[a];
      },
      onEndedHandler: function () {
        this._sound.onended = null;
        this.isPlaying = false;
        this.currentTime = this.durationMS;
        this.stop();
      },
      update: function () {
        if (!this.game.cache.checkSoundKey(this.key)) {
          return void this.destroy();
        }
        if (this.isDecoded && !this._onDecodedEventDispatched) {
          this.onDecoded.dispatch(this);
          this._onDecodedEventDispatched = true;
        }
        if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
          this.pendingPlayback = false;
          this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
        }
        if (this.isPlaying) {
          this.currentTime = this.game.time.time - this.startTime;
          if (this.currentTime >= this.durationMS) {
            if (this.usingWebAudio) {
              if (this.loop) {
                this.onLoop.dispatch(this);
                this.isPlaying = false;
                if ("" === this.currentMarker) {
                  this.currentTime = 0;
                  this.startTime = this.game.time.time;
                  this.isPlaying = true;
                } else {
                  this.onMarkerComplete.dispatch(this.currentMarker, this);
                  this.play(this.currentMarker, 0, this.volume, true, true);
                }
              } else if ("" !== this.currentMarker) {
                this.stop();
              }
            } else if (this.loop) {
              this.onLoop.dispatch(this);
              if ("" === this.currentMarker) {
                this.currentTime = 0;
                this.startTime = this.game.time.time;
              }
              this.isPlaying = false;
              this.play(this.currentMarker, 0, this.volume, true, true);
            } else {
              this.stop();
            }
          }
        }
      },
      loopFull: function (a) {
        return this.play(null, 0, a, true);
      },
      play: function (a, b, c, d, e) {
        if (!(undefined !== a && false !== a && null !== a)) {
          a = "";
        }
        if (undefined === e) {
          e = true;
        }
        if (this.isPlaying && !this.allowMultiple && !e && !this.override) {
          return this;
        }
        if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || e)) {
          if (this.usingWebAudio) {
            if (undefined === this._sound.stop) {
              this._sound.noteOff(0);
            } else {
              try {
                this._sound.stop(0);
              } catch (a) {}
            }
            if (this.externalNode) {
              this._sound.disconnect(this.externalNode);
            } else if (this.gainNode) {
              this._sound.disconnect(this.gainNode);
            }
          } else if (this.usingAudioTag) {
            this._sound.pause();
            this._sound.currentTime = 0;
          }
          this.isPlaying = false;
        }
        if ("" === a && Object.keys(this.markers).length > 0) {
          return this;
        }
        if ("" !== a) {
          if (!this.markers[a]) {
            console.warn("Phaser.Sound.play: audio marker " + a + " doesn't exist");
            return this;
          }
          this.currentMarker = a;
          this.position = this.markers[a].start;
          this.volume = this.markers[a].volume;
          this.loop = this.markers[a].loop;
          this.duration = this.markers[a].duration;
          this.durationMS = this.markers[a].durationMS;
          if (undefined !== c) {
            this.volume = c;
          }
          if (undefined !== d) {
            this.loop = d;
          }
          this._tempMarker = a;
          this._tempPosition = this.position;
          this._tempVolume = this.volume;
          this._tempLoop = this.loop;
        } else {
          b = b || 0;
          if (undefined === c) {
            c = this._volume;
          }
          if (undefined === d) {
            d = this.loop;
          }
          this.position = Math.max(0, b);
          this.volume = c;
          this.loop = d;
          this.duration = 0;
          this.durationMS = 0;
          this._tempMarker = a;
          this._tempPosition = b;
          this._tempVolume = c;
          this._tempLoop = d;
        }
        if (this.usingWebAudio) {
          if (this.game.cache.isSoundDecoded(this.key)) {
            this._sound = this.context.createBufferSource();
            if (this.externalNode) {
              this._sound.connect(this.externalNode);
            } else {
              this._sound.connect(this.gainNode);
            }
            this._buffer = this.game.cache.getSoundData(this.key);
            this._sound.buffer = this._buffer;
            if (this.loop && "" === a) {
              this._sound.loop = true;
            }
            if (!(this.loop || "" !== a)) {
              this._sound.onended = this.onEndedHandler.bind(this);
            }
            this.totalDuration = this._sound.buffer.duration;
            if (0 === this.duration) {
              this.duration = this.totalDuration;
              this.durationMS = Math.ceil(1e3 * this.totalDuration);
            }
            if (undefined === this._sound.start) {
              this._sound.noteGrainOn(0, this.position, this.duration);
            } else if (this.loop && "" === a) {
              this._sound.start(0, 0);
            } else {
              this._sound.start(0, this.position, this.duration);
            }
            this.isPlaying = true;
            this.startTime = this.game.time.time;
            this.currentTime = 0;
            this.stopTime = this.startTime + this.durationMS;
            this.onPlay.dispatch(this);
          } else {
            this.pendingPlayback = true;
            if (this.game.cache.getSound(this.key) && false === this.game.cache.getSound(this.key).isDecoding) {
              this.game.sound.decode(this.key, this);
            }
          }
        } else if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
          this.game.cache.reloadSound(this.key);
          this.pendingPlayback = true;
        } else if (this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState)) {
          this._sound.play();
          this.totalDuration = this._sound.duration;
          if (0 === this.duration) {
            this.duration = this.totalDuration;
            this.durationMS = 1e3 * this.totalDuration;
          }
          this._sound.currentTime = this.position;
          this._sound.muted = this._muted;
          if (this._muted || this.game.sound.mute) {
            this._sound.volume = 0;
          } else {
            this._sound.volume = this._volume;
          }
          this.isPlaying = true;
          this.startTime = this.game.time.time;
          this.currentTime = 0;
          this.stopTime = this.startTime + this.durationMS;
          this.onPlay.dispatch(this);
        } else {
          this.pendingPlayback = true;
        }
        return this;
      },
      restart: function (a, b, c, d) {
        a = a || "";
        b = b || 0;
        c = c || 1;
        if (undefined === d) {
          d = false;
        }
        this.play(a, b, c, d, true);
      },
      pause: function () {
        if (this.isPlaying && this._sound) {
          this.paused = true;
          this.pausedPosition = this.currentTime;
          this.pausedTime = this.game.time.time;
          this._tempPause = this._sound.currentTime;
          this.onPause.dispatch(this);
          this.stop();
        }
      },
      resume: function () {
        if (this.paused && this._sound) {
          if (this.usingWebAudio) {
            var a = Math.max(0, this.position + this.pausedPosition / 1e3);
            this._sound = this.context.createBufferSource();
            this._sound.buffer = this._buffer;
            if (this.externalNode) {
              this._sound.connect(this.externalNode);
            } else {
              this._sound.connect(this.gainNode);
            }
            if (this.loop) {
              this._sound.loop = true;
            }
            if (!(this.loop || "" !== this.currentMarker)) {
              this._sound.onended = this.onEndedHandler.bind(this);
            }
            var b = this.duration - this.pausedPosition / 1e3;
            if (undefined === this._sound.start) {
              this._sound.noteGrainOn(0, a, b);
            } else if (this.loop && this.game.device.chrome) {
              if (42 === this.game.device.chromeVersion) {
                this._sound.start(0);
              } else {
                this._sound.start(0, a);
              }
            } else {
              this._sound.start(0, a, b);
            }
          } else {
            this._sound.currentTime = this._tempPause;
            this._sound.play();
          }
          this.isPlaying = true;
          this.paused = false;
          this.startTime += this.game.time.time - this.pausedTime;
          this.onResume.dispatch(this);
        }
      },
      stop: function () {
        if (this.isPlaying && this._sound) {
          if (this.usingWebAudio) {
            if (undefined === this._sound.stop) {
              this._sound.noteOff(0);
            } else {
              try {
                this._sound.stop(0);
              } catch (a) {}
            }
            if (this.externalNode) {
              this._sound.disconnect(this.externalNode);
            } else if (this.gainNode) {
              this._sound.disconnect(this.gainNode);
            }
          } else if (this.usingAudioTag) {
            this._sound.pause();
            this._sound.currentTime = 0;
          }
        }
        this.pendingPlayback = false;
        this.isPlaying = false;
        if (!this.paused) {
          var a = this.currentMarker;
          if ("" !== this.currentMarker) {
            this.onMarkerComplete.dispatch(this.currentMarker, this);
          }
          this.currentMarker = "";
          if (null !== this.fadeTween) {
            this.fadeTween.stop();
          }
          this.onStop.dispatch(this, a);
        }
      },
      fadeIn: function (a, b, c) {
        if (undefined === b) {
          b = false;
        }
        if (undefined === c) {
          c = this.currentMarker;
        }
        if (!this.paused) {
          this.play(c, 0, 0, b);
          this.fadeTo(a, 1);
        }
      },
      fadeOut: function (a) {
        this.fadeTo(a, 0);
      },
      fadeTo: function (a, c) {
        if (this.isPlaying && !this.paused && c !== this.volume) {
          if (undefined === a) {
            a = 1e3;
          }
          if (undefined === c) {
            return void console.warn("Phaser.Sound.fadeTo: No Volume Specified.");
          }
          this.fadeTween = this.game.add.tween(this).to({
            volume: c
          }, a, b.Easing.Linear.None, true);
          this.fadeTween.onComplete.add(this.fadeComplete, this);
        }
      },
      fadeComplete: function () {
        this.onFadeComplete.dispatch(this, this.volume);
        if (0 === this.volume) {
          this.stop();
        }
      },
      updateGlobalVolume: function (a) {
        if (this.usingAudioTag && this._sound) {
          this._sound.volume = a * this._volume;
        }
      },
      destroy: function (a) {
        if (undefined === a) {
          a = true;
        }
        this.stop();
        if (a) {
          this.game.sound.remove(this);
        } else {
          this.markers = {};
          this.context = null;
          this._buffer = null;
          this.externalNode = null;
          this.onDecoded.dispose();
          this.onPlay.dispose();
          this.onPause.dispose();
          this.onResume.dispose();
          this.onLoop.dispose();
          this.onStop.dispose();
          this.onMute.dispose();
          this.onMarkerComplete.dispose();
        }
      }
    };
    b.Sound.prototype.constructor = b.Sound;
    Object.defineProperty(b.Sound.prototype, "isDecoding", {
      get: function () {
        return this.game.cache.getSound(this.key).isDecoding;
      }
    });
    Object.defineProperty(b.Sound.prototype, "isDecoded", {
      get: function () {
        return this.game.cache.isSoundDecoded(this.key);
      }
    });
    Object.defineProperty(b.Sound.prototype, "mute", {
      get: function () {
        return this._muted || this.game.sound.mute;
      },
      set: function (a) {
        if ((a = a || false) !== this._muted) {
          if (a) {
            this._muted = true;
            this._muteVolume = this._tempVolume;
            if (this.usingWebAudio) {
              this.gainNode.gain.value = 0;
            } else if (this.usingAudioTag && this._sound) {
              this._sound.volume = 0;
            }
          } else {
            this._muted = false;
            if (this.usingWebAudio) {
              this.gainNode.gain.value = this._muteVolume;
            } else if (this.usingAudioTag && this._sound) {
              this._sound.volume = this._muteVolume;
            }
          }
          this.onMute.dispatch(this);
        }
      }
    });
    Object.defineProperty(b.Sound.prototype, "volume", {
      get: function () {
        return this._volume;
      },
      set: function (a) {
        if (this.game.device.firefox && this.usingAudioTag) {
          a = this.game.math.clamp(a, 0, 1);
        }
        if (this._muted) {
          return void (this._muteVolume = a);
        }
        this._tempVolume = a;
        this._volume = a;
        if (this.usingWebAudio) {
          this.gainNode.gain.value = a;
        } else if (this.usingAudioTag && this._sound) {
          this._sound.volume = a;
        }
      }
    });
    b.SoundManager = function (a) {
      this.game = a;
      this.onSoundDecode = new b.Signal();
      this.onVolumeChange = new b.Signal();
      this.onMute = new b.Signal();
      this.onUnMute = new b.Signal();
      this.context = null;
      this.usingWebAudio = false;
      this.usingAudioTag = false;
      this.noAudio = false;
      this.connectToMaster = true;
      this.touchLocked = false;
      this.channels = 32;
      this.muteOnPause = true;
      this._codeMuted = false;
      this._muted = false;
      this._unlockSource = null;
      this._volume = 1;
      this._sounds = [];
      this._watchList = new b.ArraySet();
      this._watching = false;
      this._watchCallback = null;
      this._watchContext = null;
    };
    b.SoundManager.prototype = {
      boot: function () {
        if (this.game.device.iOS && false === this.game.device.webAudio) {
          this.channels = 1;
        }
        if (window.PhaserGlobal) {
          if (true === window.PhaserGlobal.disableAudio) {
            this.noAudio = true;
            return void (this.touchLocked = false);
          }
          if (true === window.PhaserGlobal.disableWebAudio) {
            this.usingAudioTag = true;
            return void (this.touchLocked = false);
          }
        }
        if (window.PhaserGlobal && window.PhaserGlobal.audioContext) {
          this.context = window.PhaserGlobal.audioContext;
        } else if (window.AudioContext) {
          try {
            this.context = new window.AudioContext();
          } catch (a) {
            this.context = null;
            this.usingWebAudio = false;
            this.touchLocked = false;
          }
        } else if (window.webkitAudioContext) {
          try {
            this.context = new window.webkitAudioContext();
          } catch (a) {
            this.context = null;
            this.usingWebAudio = false;
            this.touchLocked = false;
          }
        }
        if (null === this.context) {
          if (undefined === window.Audio) {
            return void (this.noAudio = true);
          }
          this.usingAudioTag = true;
        } else {
          this.usingWebAudio = true;
          if (undefined === this.context.createGain) {
            this.masterGain = this.context.createGainNode();
          } else {
            this.masterGain = this.context.createGain();
          }
          this.masterGain.gain.value = 1;
          this.masterGain.connect(this.context.destination);
        }
        if (!this.noAudio) {
          if (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) {
            this.setTouchLock();
          }
        }
      },
      setTouchLock: function () {
        if (!(this.noAudio || window.PhaserGlobal && true === window.PhaserGlobal.disableAudio)) {
          if (this.game.device.iOSVersion > 8) {
            this.game.input.touch.addTouchLockCallback(this.unlock, this, true);
          } else {
            this.game.input.touch.addTouchLockCallback(this.unlock, this);
          }
          this.touchLocked = true;
        }
      },
      unlock: function () {
        if (this.noAudio || !this.touchLocked || null !== this._unlockSource) {
          return true;
        }
        if (this.usingAudioTag) {
          this.touchLocked = false;
          this._unlockSource = null;
        } else if (this.usingWebAudio) {
          var a = this.context.createBuffer(1, 1, 22050);
          this._unlockSource = this.context.createBufferSource();
          this._unlockSource.buffer = a;
          this._unlockSource.connect(this.context.destination);
          if (undefined === this._unlockSource.start) {
            this._unlockSource.noteOn(0);
          } else {
            this._unlockSource.start(0);
          }
        }
        return true;
      },
      stopAll: function () {
        if (!this.noAudio) {
          for (var a = 0; a < this._sounds.length; a++) {
            if (this._sounds[a]) {
              this._sounds[a].stop();
            }
          }
        }
      },
      pauseAll: function () {
        if (!this.noAudio) {
          for (var a = 0; a < this._sounds.length; a++) {
            if (this._sounds[a]) {
              this._sounds[a].pause();
            }
          }
        }
      },
      resumeAll: function () {
        if (!this.noAudio) {
          for (var a = 0; a < this._sounds.length; a++) {
            if (this._sounds[a]) {
              this._sounds[a].resume();
            }
          }
        }
      },
      decode: function (a, b) {
        b = b || null;
        var c = this.game.cache.getSoundData(a);
        if (c && false === this.game.cache.isSoundDecoded(a)) {
          this.game.cache.updateSound(a, "isDecoding", true);
          var d = this;
          try {
            this.context.decodeAudioData(c, function (c) {
              if (c) {
                d.game.cache.decodedSound(a, c);
                d.onSoundDecode.dispatch(a, b);
              }
            });
          } catch (a) {}
        }
      },
      setDecodedCallback: function (a, c, d) {
        if ("string" == typeof a) {
          a = [a];
        }
        this._watchList.reset();
        for (var e = 0; e < a.length; e++) {
          if (a[e] instanceof b.Sound) {
            if (!this.game.cache.isSoundDecoded(a[e].key)) {
              this._watchList.add(a[e].key);
            }
          } else if (!this.game.cache.isSoundDecoded(a[e])) {
            this._watchList.add(a[e]);
          }
        }
        if (0 === this._watchList.total) {
          this._watching = false;
          c.call(d);
        } else {
          this._watching = true;
          this._watchCallback = c;
          this._watchContext = d;
        }
      },
      update: function () {
        if (!this.noAudio) {
          if (!(!this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE)) {
            this.touchLocked = false;
            this._unlockSource = null;
          }
          for (var a = 0; a < this._sounds.length; a++) {
            this._sounds[a].update();
          }
          if (this._watching) {
            for (var b = this._watchList.first; b;) {
              if (this.game.cache.isSoundDecoded(b)) {
                this._watchList.remove(b);
              }
              b = this._watchList.next;
            }
            if (0 === this._watchList.total) {
              this._watching = false;
              this._watchCallback.call(this._watchContext);
            }
          }
        }
      },
      add: function (a, c, d, e) {
        if (undefined === c) {
          c = 1;
        }
        if (undefined === d) {
          d = false;
        }
        if (undefined === e) {
          e = this.connectToMaster;
        }
        var f = new b.Sound(this.game, a, c, d, e);
        this._sounds.push(f);
        return f;
      },
      addSprite: function (a) {
        return new b.AudioSprite(this.game, a);
      },
      remove: function (a) {
        for (var b = this._sounds.length; b--;) {
          if (this._sounds[b] === a) {
            this._sounds[b].destroy(false);
            this._sounds.splice(b, 1);
            return true;
          }
        }
        return false;
      },
      removeByKey: function (a) {
        var b = this._sounds.length;
        for (var c = 0; b--;) {
          if (this._sounds[b].key === a) {
            this._sounds[b].destroy(false);
            this._sounds.splice(b, 1);
            c++;
          }
        }
        return c;
      },
      play: function (a, b, c) {
        if (!this.noAudio) {
          var d = this.add(a, b, c);
          d.play();
          return d;
        }
      },
      setMute: function () {
        if (!this._muted) {
          this._muted = true;
          if (this.usingWebAudio) {
            this._muteVolume = this.masterGain.gain.value;
            this.masterGain.gain.value = 0;
          }
          for (var a = 0; a < this._sounds.length; a++) {
            if (this._sounds[a].usingAudioTag) {
              this._sounds[a].mute = true;
            }
          }
          this.onMute.dispatch();
        }
      },
      unsetMute: function () {
        if (this._muted && !this._codeMuted) {
          this._muted = false;
          if (this.usingWebAudio) {
            this.masterGain.gain.value = this._muteVolume;
          }
          for (var a = 0; a < this._sounds.length; a++) {
            if (this._sounds[a].usingAudioTag) {
              this._sounds[a].mute = false;
            }
          }
          this.onUnMute.dispatch();
        }
      },
      destroy: function () {
        this.stopAll();
        for (var a = 0; a < this._sounds.length; a++) {
          if (this._sounds[a]) {
            this._sounds[a].destroy();
          }
        }
        this._sounds = [];
        this.onSoundDecode.dispose();
        if (this.context) {
          if (window.PhaserGlobal) {
            window.PhaserGlobal.audioContext = this.context;
          } else if (this.context.close) {
            this.context.close();
          }
        }
      }
    };
    b.SoundManager.prototype.constructor = b.SoundManager;
    Object.defineProperty(b.SoundManager.prototype, "mute", {
      get: function () {
        return this._muted;
      },
      set: function (a) {
        if (a = a || false) {
          if (this._muted) {
            return;
          }
          this._codeMuted = true;
          this.setMute();
        } else {
          if (!this._muted) {
            return;
          }
          this._codeMuted = false;
          this.unsetMute();
        }
      }
    });
    Object.defineProperty(b.SoundManager.prototype, "volume", {
      get: function () {
        return this._volume;
      },
      set: function (a) {
        if (a < 0) {
          a = 0;
        } else if (a > 1) {
          a = 1;
        }
        if (this._volume !== a) {
          this._volume = a;
          if (this.usingWebAudio) {
            this.masterGain.gain.value = a;
          } else {
            for (var b = 0; b < this._sounds.length; b++) {
              if (this._sounds[b].usingAudioTag) {
                this._sounds[b].updateGlobalVolume(a);
              }
            }
          }
          this.onVolumeChange.dispatch(a);
        }
      }
    });
    b.ScaleManager = function (a, c, d) {
      this.game = a;
      this.dom = b.DOM;
      this.grid = null;
      this.width = 0;
      this.height = 0;
      this.minWidth = null;
      this.maxWidth = null;
      this.minHeight = null;
      this.maxHeight = null;
      this.offset = new b.Point();
      this.forceLandscape = false;
      this.forcePortrait = false;
      this.incorrectOrientation = false;
      this._pageAlignHorizontally = false;
      this._pageAlignVertically = false;
      this.onOrientationChange = new b.Signal();
      this.enterIncorrectOrientation = new b.Signal();
      this.leaveIncorrectOrientation = new b.Signal();
      this.hasPhaserSetFullScreen = false;
      this.fullScreenTarget = null;
      this._createdFullScreenTarget = null;
      this.onFullScreenInit = new b.Signal();
      this.onFullScreenChange = new b.Signal();
      this.onFullScreenError = new b.Signal();
      this.screenOrientation = this.dom.getScreenOrientation();
      this.scaleFactor = new b.Point(1, 1);
      this.scaleFactorInversed = new b.Point(1, 1);
      this.margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        x: 0,
        y: 0
      };
      this.bounds = new b.Rectangle();
      this.aspectRatio = 0;
      this.sourceAspectRatio = 0;
      this.event = null;
      this.windowConstraints = {
        right: "layout",
        bottom: ""
      };
      this.compatibility = {
        supportsFullScreen: false,
        orientationFallback: null,
        noMargins: false,
        scrollTo: null,
        forceMinimumDocumentHeight: false,
        canExpandParent: true,
        clickTrampoline: ""
      };
      this._scaleMode = b.ScaleManager.NO_SCALE;
      this._fullScreenScaleMode = b.ScaleManager.NO_SCALE;
      this.parentIsWindow = false;
      this.parentNode = null;
      this.parentScaleFactor = new b.Point(1, 1);
      this.trackParentInterval = 2e3;
      this.onSizeChange = new b.Signal();
      this.onResize = null;
      this.onResizeContext = null;
      this._pendingScaleMode = null;
      this._fullScreenRestore = null;
      this._gameSize = new b.Rectangle();
      this._userScaleFactor = new b.Point(1, 1);
      this._userScaleTrim = new b.Point(0, 0);
      this._lastUpdate = 0;
      this._updateThrottle = 0;
      this._updateThrottleReset = 100;
      this._parentBounds = new b.Rectangle();
      this._tempBounds = new b.Rectangle();
      this._lastReportedCanvasSize = new b.Rectangle();
      this._lastReportedGameSize = new b.Rectangle();
      this._booted = false;
      if (a.config) {
        this.parseConfig(a.config);
      }
      this.setupScale(c, d);
    };
    b.ScaleManager.EXACT_FIT = 0;
    b.ScaleManager.NO_SCALE = 1;
    b.ScaleManager.SHOW_ALL = 2;
    b.ScaleManager.RESIZE = 3;
    b.ScaleManager.USER_SCALE = 4;
    b.ScaleManager.prototype = {
      boot: function () {
        var a = this.compatibility;
        a.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS;
        if (!(this.game.device.iPad || this.game.device.webApp || this.game.device.desktop)) {
          if (this.game.device.android && !this.game.device.chrome) {
            a.scrollTo = new b.Point(0, 1);
          } else {
            a.scrollTo = new b.Point(0, 0);
          }
        }
        if (this.game.device.desktop) {
          a.orientationFallback = "screen";
          a.clickTrampoline = "when-not-mouse";
        } else {
          a.orientationFallback = "";
          a.clickTrampoline = "";
        }
        var c = this;
        this._orientationChange = function (a) {
          return c.orientationChange(a);
        };
        this._windowResize = function (a) {
          return c.windowResize(a);
        };
        window.addEventListener("orientationchange", this._orientationChange, false);
        window.addEventListener("resize", this._windowResize, false);
        if (this.compatibility.supportsFullScreen) {
          this._fullScreenChange = function (a) {
            return c.fullScreenChange(a);
          };
          this._fullScreenError = function (a) {
            return c.fullScreenError(a);
          };
          document.addEventListener("webkitfullscreenchange", this._fullScreenChange, false);
          document.addEventListener("mozfullscreenchange", this._fullScreenChange, false);
          document.addEventListener("MSFullscreenChange", this._fullScreenChange, false);
          document.addEventListener("fullscreenchange", this._fullScreenChange, false);
          document.addEventListener("webkitfullscreenerror", this._fullScreenError, false);
          document.addEventListener("mozfullscreenerror", this._fullScreenError, false);
          document.addEventListener("MSFullscreenError", this._fullScreenError, false);
          document.addEventListener("fullscreenerror", this._fullScreenError, false);
        }
        this.game.onResume.add(this._gameResumed, this);
        this.dom.getOffset(this.game.canvas, this.offset);
        this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
        this.setGameSize(this.game.width, this.game.height);
        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
        if (b.FlexGrid) {
          this.grid = new b.FlexGrid(this, this.width, this.height);
        }
        this._booted = true;
        if (null !== this._pendingScaleMode) {
          this.scaleMode = this._pendingScaleMode;
          this._pendingScaleMode = null;
        }
      },
      parseConfig: function (a) {
        if (undefined !== a.scaleMode) {
          if (this._booted) {
            this.scaleMode = a.scaleMode;
          } else {
            this._pendingScaleMode = a.scaleMode;
          }
        }
        if (undefined !== a.fullScreenScaleMode) {
          this.fullScreenScaleMode = a.fullScreenScaleMode;
        }
        if (a.fullScreenTarget) {
          this.fullScreenTarget = a.fullScreenTarget;
        }
      },
      setupScale: function (a, c) {
        var d;
        var e = new b.Rectangle();
        if ("" !== this.game.parent) {
          if ("string" == typeof this.game.parent) {
            d = document.getElementById(this.game.parent);
          } else if (this.game.parent && 1 === this.game.parent.nodeType) {
            d = this.game.parent;
          }
        }
        if (d) {
          this.parentNode = d;
          this.parentIsWindow = false;
          this.getParentBounds(this._parentBounds);
          e.width = this._parentBounds.width;
          e.height = this._parentBounds.height;
          this.offset.set(this._parentBounds.x, this._parentBounds.y);
        } else {
          this.parentNode = null;
          this.parentIsWindow = true;
          e.width = this.dom.visualBounds.width;
          e.height = this.dom.visualBounds.height;
          this.offset.set(0, 0);
        }
        var f = 0;
        var g = 0;
        if ("number" == typeof a) {
          f = a;
        } else {
          this.parentScaleFactor.x = parseInt(a, 10) / 100;
          f = e.width * this.parentScaleFactor.x;
        }
        if ("number" == typeof c) {
          g = c;
        } else {
          this.parentScaleFactor.y = parseInt(c, 10) / 100;
          g = e.height * this.parentScaleFactor.y;
        }
        f = Math.floor(f);
        g = Math.floor(g);
        this._gameSize.setTo(0, 0, f, g);
        this.updateDimensions(f, g, false);
      },
      _gameResumed: function () {
        this.queueUpdate(true);
      },
      setGameSize: function (a, c) {
        this._gameSize.setTo(0, 0, a, c);
        if (this.currentScaleMode !== b.ScaleManager.RESIZE) {
          this.updateDimensions(a, c, true);
        }
        this.queueUpdate(true);
      },
      setUserScale: function (a, b, c, d) {
        this._userScaleFactor.setTo(a, b);
        this._userScaleTrim.setTo(0 | c, 0 | d);
        this.queueUpdate(true);
      },
      setResizeCallback: function (a, b) {
        this.onResize = a;
        this.onResizeContext = b;
      },
      signalSizeChange: function () {
        if (!b.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !b.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
          var a = this.width;
          var c = this.height;
          this._lastReportedCanvasSize.setTo(0, 0, a, c);
          this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height);
          if (this.grid) {
            this.grid.onResize(a, c);
          }
          this.onSizeChange.dispatch(this, a, c);
          if (this.currentScaleMode === b.ScaleManager.RESIZE) {
            this.game.state.resize(a, c);
            this.game.load.resize(a, c);
          }
        }
      },
      setMinMax: function (a, b, c, d) {
        this.minWidth = a;
        this.minHeight = b;
        if (undefined !== c) {
          this.maxWidth = c;
        }
        if (undefined !== d) {
          this.maxHeight = d;
        }
      },
      preUpdate: function () {
        if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
          var a = this._updateThrottle;
          this._updateThrottleReset = a >= 400 ? 0 : 100;
          this.dom.getOffset(this.game.canvas, this.offset);
          var c = this._parentBounds.width;
          var d = this._parentBounds.height;
          var e = this.getParentBounds(this._parentBounds);
          var f = e.width !== c || e.height !== d;
          var g = this.updateOrientationState();
          if (f || g) {
            if (this.onResize) {
              this.onResize.call(this.onResizeContext, this, e);
            }
            this.updateLayout();
            this.signalSizeChange();
          }
          var h = 2 * this._updateThrottle;
          if (this._updateThrottle < a) {
            h = Math.min(a, this._updateThrottleReset);
          }
          this._updateThrottle = b.Math.clamp(h, 25, this.trackParentInterval);
          this._lastUpdate = this.game.time.time;
        }
      },
      pauseUpdate: function () {
        this.preUpdate();
        this._updateThrottle = this.trackParentInterval;
      },
      updateDimensions: function (a, b, c) {
        this.width = a * this.parentScaleFactor.x;
        this.height = b * this.parentScaleFactor.y;
        this.game.width = this.width;
        this.game.height = this.height;
        this.sourceAspectRatio = this.width / this.height;
        this.updateScalingAndBounds();
        if (c) {
          this.game.renderer.resize(this.width, this.height);
          this.game.camera.setSize(this.width, this.height);
          this.game.world.resize(this.width, this.height);
        }
      },
      updateScalingAndBounds: function () {
        this.scaleFactor.x = this.game.width / this.width;
        this.scaleFactor.y = this.game.height / this.height;
        this.scaleFactorInversed.x = this.width / this.game.width;
        this.scaleFactorInversed.y = this.height / this.game.height;
        this.aspectRatio = this.width / this.height;
        if (this.game.canvas) {
          this.dom.getOffset(this.game.canvas, this.offset);
        }
        this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
        if (this.game.input && this.game.input.scale) {
          this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
        }
      },
      forceOrientation: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        this.forceLandscape = a;
        this.forcePortrait = b;
        this.queueUpdate(true);
      },
      classifyOrientation: function (a) {
        return "portrait-primary" === a || "portrait-secondary" === a ? "portrait" : "landscape-primary" === a || "landscape-secondary" === a ? "landscape" : null;
      },
      updateOrientationState: function () {
        var a = this.screenOrientation;
        var b = this.incorrectOrientation;
        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
        this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
        var c = a !== this.screenOrientation;
        var d = b !== this.incorrectOrientation;
        if (d) {
          if (this.incorrectOrientation) {
            this.enterIncorrectOrientation.dispatch();
          } else {
            this.leaveIncorrectOrientation.dispatch();
          }
        }
        if (c || d) {
          this.onOrientationChange.dispatch(this, a, b);
        }
        return c || d;
      },
      orientationChange: function (a) {
        this.event = a;
        this.queueUpdate(true);
      },
      windowResize: function (a) {
        this.event = a;
        this.queueUpdate(true);
      },
      scrollTop: function () {
        var a = this.compatibility.scrollTo;
        if (a) {
          window.scrollTo(a.x, a.y);
        }
      },
      refresh: function () {
        this.scrollTop();
        this.queueUpdate(true);
      },
      updateLayout: function () {
        var a = this.currentScaleMode;
        if (a === b.ScaleManager.RESIZE) {
          return void this.reflowGame();
        }
        this.scrollTop();
        if (this.compatibility.forceMinimumDocumentHeight) {
          document.documentElement.style.minHeight = window.innerHeight + "px";
        }
        if (this.incorrectOrientation) {
          this.setMaximum();
        } else if (a === b.ScaleManager.EXACT_FIT) {
          this.setExactFit();
        } else if (a === b.ScaleManager.SHOW_ALL) {
          if (!this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent) {
            this.setShowAll(true);
            this.resetCanvas();
            this.setShowAll();
          } else {
            this.setShowAll();
          }
        } else if (a === b.ScaleManager.NO_SCALE) {
          this.width = this.game.width;
          this.height = this.game.height;
        } else if (a === b.ScaleManager.USER_SCALE) {
          this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x;
          this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y;
        }
        if (!this.compatibility.canExpandParent && (a === b.ScaleManager.SHOW_ALL || a === b.ScaleManager.USER_SCALE)) {
          var c = this.getParentBounds(this._tempBounds);
          this.width = Math.min(this.width, c.width);
          this.height = Math.min(this.height, c.height);
        }
        this.width = 0 | this.width;
        this.height = 0 | this.height;
        this.reflowCanvas();
      },
      getParentBounds: function (a) {
        var c = a || new b.Rectangle();
        var d = this.boundingParent;
        var e = this.dom.visualBounds;
        var f = this.dom.layoutBounds;
        if (d) {
          var g = d.getBoundingClientRect();
          var h = d.offsetParent ? d.offsetParent.getBoundingClientRect() : d.getBoundingClientRect();
          c.setTo(g.left - h.left, g.top - h.top, g.width, g.height);
          var i = this.windowConstraints;
          if (i.right) {
            var j = "layout" === i.right ? f : e;
            c.right = Math.min(c.right, j.width);
          }
          if (i.bottom) {
            var j = "layout" === i.bottom ? f : e;
            c.bottom = Math.min(c.bottom, j.height);
          }
        } else {
          c.setTo(0, 0, e.width, e.height);
        }
        c.setTo(Math.round(c.x), Math.round(c.y), Math.round(c.width), Math.round(c.height));
        return c;
      },
      alignCanvas: function (a, b) {
        var c = this.getParentBounds(this._tempBounds);
        var d = this.game.canvas;
        var e = this.margin;
        if (a) {
          e.left = e.right = 0;
          var f = d.getBoundingClientRect();
          if (this.width < c.width && !this.incorrectOrientation) {
            var g = f.left - c.x;
            var h = c.width / 2 - this.width / 2;
            h = Math.max(h, 0);
            var i = h - g;
            e.left = Math.round(i);
          }
          d.style.marginLeft = e.left + "px";
          if (0 !== e.left) {
            e.right = -(c.width - f.width - e.left);
            d.style.marginRight = e.right + "px";
          }
        }
        if (b) {
          e.top = e.bottom = 0;
          var f = d.getBoundingClientRect();
          if (this.height < c.height && !this.incorrectOrientation) {
            var g = f.top - c.y;
            var h = c.height / 2 - this.height / 2;
            h = Math.max(h, 0);
            var i = h - g;
            e.top = Math.round(i);
          }
          d.style.marginTop = e.top + "px";
          if (0 !== e.top) {
            e.bottom = -(c.height - f.height - e.top);
            d.style.marginBottom = e.bottom + "px";
          }
        }
        e.x = e.left;
        e.y = e.top;
      },
      reflowGame: function () {
        this.resetCanvas("", "");
        var a = this.getParentBounds(this._tempBounds);
        this.updateDimensions(a.width, a.height, true);
      },
      reflowCanvas: function () {
        if (!this.incorrectOrientation) {
          this.width = b.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width);
          this.height = b.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height);
        }
        this.resetCanvas();
        if (!this.compatibility.noMargins) {
          if (this.isFullScreen && this._createdFullScreenTarget) {
            this.alignCanvas(true, true);
          } else {
            this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically);
          }
        }
        this.updateScalingAndBounds();
      },
      resetCanvas: function (a, b) {
        if (undefined === a) {
          a = this.width + "px";
        }
        if (undefined === b) {
          b = this.height + "px";
        }
        var c = this.game.canvas;
        if (!this.compatibility.noMargins) {
          c.style.marginLeft = "";
          c.style.marginTop = "";
          c.style.marginRight = "";
          c.style.marginBottom = "";
        }
        c.style.width = a;
        c.style.height = b;
      },
      queueUpdate: function (a) {
        if (a) {
          this._parentBounds.width = 0;
          this._parentBounds.height = 0;
        }
        this._updateThrottle = this._updateThrottleReset;
      },
      reset: function (a) {
        if (a && this.grid) {
          this.grid.reset();
        }
      },
      setMaximum: function () {
        this.width = this.dom.visualBounds.width;
        this.height = this.dom.visualBounds.height;
      },
      setShowAll: function (a) {
        var e;
        var b = this.getParentBounds(this._tempBounds);
        var c = b.width;
        var d = b.height;
        e = a ? Math.max(d / this.game.height, c / this.game.width) : Math.min(d / this.game.height, c / this.game.width);
        this.width = Math.round(this.game.width * e);
        this.height = Math.round(this.game.height * e);
      },
      setExactFit: function () {
        var a = this.getParentBounds(this._tempBounds);
        this.width = a.width;
        this.height = a.height;
        if (!this.isFullScreen) {
          if (this.maxWidth) {
            this.width = Math.min(this.width, this.maxWidth);
          }
          if (this.maxHeight) {
            this.height = Math.min(this.height, this.maxHeight);
          }
        }
      },
      createFullScreenTarget: function () {
        var a = document.createElement("div");
        a.style.margin = "0";
        a.style.padding = "0";
        a.style.background = "#000";
        return a;
      },
      startFullScreen: function (a, c) {
        if (this.isFullScreen) {
          return false;
        }
        if (!this.compatibility.supportsFullScreen) {
          var d = this;
          return void setTimeout(function () {
            d.fullScreenError();
          }, 10);
        }
        if ("when-not-mouse" === this.compatibility.clickTrampoline) {
          var e = this.game.input;
          if (e.activePointer && e.activePointer !== e.mousePointer && (c || false !== c)) {
            return void e.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [a, false]);
          }
        }
        if (undefined !== a && this.game.renderType === b.CANVAS) {
          this.game.stage.smoothed = a;
        }
        var f = this.fullScreenTarget;
        if (!f) {
          this.cleanupCreatedTarget();
          this._createdFullScreenTarget = this.createFullScreenTarget();
          f = this._createdFullScreenTarget;
        }
        var g = {
          targetElement: f
        };
        this.hasPhaserSetFullScreen = true;
        this.onFullScreenInit.dispatch(this, g);
        if (this._createdFullScreenTarget) {
          var h = this.game.canvas;
          h.parentNode.insertBefore(f, h);
          f.appendChild(h);
        }
        if (this.game.device.fullscreenKeyboard) {
          f[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);
        } else {
          f[this.game.device.requestFullscreen]();
        }
        return true;
      },
      stopFullScreen: function () {
        return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = false, document[this.game.device.cancelFullscreen](), true);
      },
      cleanupCreatedTarget: function () {
        var a = this._createdFullScreenTarget;
        if (a && a.parentNode) {
          var b = a.parentNode;
          b.insertBefore(this.game.canvas, a);
          b.removeChild(a);
        }
        this._createdFullScreenTarget = null;
      },
      prepScreenMode: function (a) {
        var c = !!this._createdFullScreenTarget;
        var d = this._createdFullScreenTarget || this.fullScreenTarget;
        if (a) {
          if ((c || this.fullScreenScaleMode === b.ScaleManager.EXACT_FIT) && d !== this.game.canvas) {
            this._fullScreenRestore = {
              targetWidth: d.style.width,
              targetHeight: d.style.height
            };
            d.style.width = "100%";
            d.style.height = "100%";
          }
        } else {
          if (this._fullScreenRestore) {
            d.style.width = this._fullScreenRestore.targetWidth;
            d.style.height = this._fullScreenRestore.targetHeight;
            this._fullScreenRestore = null;
          }
          this.updateDimensions(this._gameSize.width, this._gameSize.height, true);
          this.resetCanvas();
        }
      },
      fullScreenChange: function (a) {
        this.event = a;
        if (this.isFullScreen) {
          this.prepScreenMode(true);
          this.updateLayout();
          this.queueUpdate(true);
        } else {
          this.prepScreenMode(false);
          this.cleanupCreatedTarget();
          this.updateLayout();
          this.queueUpdate(true);
        }
        this.onFullScreenChange.dispatch(this, this.width, this.height);
      },
      fullScreenError: function (a) {
        this.event = a;
        this.cleanupCreatedTarget();
        console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API");
        this.onFullScreenError.dispatch(this);
      },
      scaleSprite: function (a, b, c, d) {
        if (undefined === b) {
          b = this.width;
        }
        if (undefined === c) {
          c = this.height;
        }
        if (undefined === d) {
          d = false;
        }
        if (!a || !a.scale) {
          return a;
        }
        a.scale.x = 1;
        a.scale.y = 1;
        if (a.width <= 0 || a.height <= 0 || b <= 0 || c <= 0) {
          return a;
        }
        var f = a.height * b / a.width;
        var g = a.width * c / a.height;
        var i = g > b;
        i = i ? d : !d;
        if (i) {
          a.width = Math.floor(b);
          a.height = Math.floor(f);
        } else {
          a.width = Math.floor(g);
          a.height = Math.floor(c);
        }
        return a;
      },
      destroy: function () {
        this.game.onResume.remove(this._gameResumed, this);
        window.removeEventListener("orientationchange", this._orientationChange, false);
        window.removeEventListener("resize", this._windowResize, false);
        if (this.compatibility.supportsFullScreen) {
          document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, false);
          document.removeEventListener("mozfullscreenchange", this._fullScreenChange, false);
          document.removeEventListener("MSFullscreenChange", this._fullScreenChange, false);
          document.removeEventListener("fullscreenchange", this._fullScreenChange, false);
          document.removeEventListener("webkitfullscreenerror", this._fullScreenError, false);
          document.removeEventListener("mozfullscreenerror", this._fullScreenError, false);
          document.removeEventListener("MSFullscreenError", this._fullScreenError, false);
          document.removeEventListener("fullscreenerror", this._fullScreenError, false);
        }
      }
    };
    b.ScaleManager.prototype.constructor = b.ScaleManager;
    Object.defineProperty(b.ScaleManager.prototype, "boundingParent", {
      get: function () {
        return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null;
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "scaleMode", {
      get: function () {
        return this._scaleMode;
      },
      set: function (a) {
        if (a !== this._scaleMode) {
          if (!this.isFullScreen) {
            this.updateDimensions(this._gameSize.width, this._gameSize.height, true);
            this.queueUpdate(true);
          }
          this._scaleMode = a;
        }
        return this._scaleMode;
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "fullScreenScaleMode", {
      get: function () {
        return this._fullScreenScaleMode;
      },
      set: function (a) {
        if (a !== this._fullScreenScaleMode) {
          if (this.isFullScreen) {
            this.prepScreenMode(false);
            this._fullScreenScaleMode = a;
            this.prepScreenMode(true);
            this.queueUpdate(true);
          } else {
            this._fullScreenScaleMode = a;
          }
        }
        return this._fullScreenScaleMode;
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "currentScaleMode", {
      get: function () {
        return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "pageAlignHorizontally", {
      get: function () {
        return this._pageAlignHorizontally;
      },
      set: function (a) {
        if (a !== this._pageAlignHorizontally) {
          this._pageAlignHorizontally = a;
          this.queueUpdate(true);
        }
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "pageAlignVertically", {
      get: function () {
        return this._pageAlignVertically;
      },
      set: function (a) {
        if (a !== this._pageAlignVertically) {
          this._pageAlignVertically = a;
          this.queueUpdate(true);
        }
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "isFullScreen", {
      get: function () {
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "isPortrait", {
      get: function () {
        return "portrait" === this.classifyOrientation(this.screenOrientation);
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "isLandscape", {
      get: function () {
        return "landscape" === this.classifyOrientation(this.screenOrientation);
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "isGamePortrait", {
      get: function () {
        return this.height > this.width;
      }
    });
    Object.defineProperty(b.ScaleManager.prototype, "isGameLandscape", {
      get: function () {
        return this.width > this.height;
      }
    });
    b.Utils.Debug = function (a) {
      this.game = a;
      this.sprite = null;
      this.bmd = null;
      this.canvas = null;
      this.context = null;
      this.font = "14px Courier";
      this.columnWidth = 100;
      this.lineHeight = 16;
      this.renderShadow = true;
      this.currentX = 0;
      this.currentY = 0;
      this.currentAlpha = 1;
      this.dirty = false;
    };
    b.Utils.Debug.prototype = {
      boot: function () {
        if (this.game.renderType === b.CANVAS) {
          this.context = this.game.context;
        } else {
          this.bmd = new b.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, true);
          this.sprite = this.game.make.image(0, 0, this.bmd);
          this.game.stage.addChild(this.sprite);
          this.game.scale.onSizeChange.add(this.resize, this);
          this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height);
          this.context = this.canvas.getContext("2d");
        }
      },
      resize: function (a, b, c) {
        this.bmd.resize(b, c);
        this.canvas.width = b;
        this.canvas.height = c;
      },
      preUpdate: function () {
        if (this.dirty && this.sprite) {
          this.bmd.clear();
          this.bmd.draw(this.canvas, 0, 0);
          this.context.clearRect(0, 0, this.game.width, this.game.height);
          this.dirty = false;
        }
      },
      reset: function () {
        if (this.context) {
          this.context.clearRect(0, 0, this.game.width, this.game.height);
        }
        if (this.sprite) {
          this.bmd.clear();
        }
      },
      start: function (a, b, c, d) {
        if ("number" != typeof a) {
          a = 0;
        }
        if ("number" != typeof b) {
          b = 0;
        }
        c = c || "rgb(255,255,255)";
        if (undefined === d) {
          d = 0;
        }
        this.currentX = a;
        this.currentY = b;
        this.currentColor = c;
        this.columnWidth = d;
        this.dirty = true;
        this.context.save();
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.strokeStyle = c;
        this.context.fillStyle = c;
        this.context.font = this.font;
        this.context.globalAlpha = this.currentAlpha;
      },
      stop: function () {
        this.context.restore();
      },
      line: function () {
        var a = this.currentX;
        for (var b = 0; b < arguments.length; b++) {
          if (this.renderShadow) {
            this.context.fillStyle = "rgb(0,0,0)";
            this.context.fillText(arguments[b], a + 1, this.currentY + 1);
            this.context.fillStyle = this.currentColor;
          }
          this.context.fillText(arguments[b], a, this.currentY);
          a += this.columnWidth;
        }
        this.currentY += this.lineHeight;
      },
      soundInfo: function (a, b, c, d) {
        this.start(b, c, d);
        this.line("Sound: " + a.key + " Locked: " + a.game.sound.touchLocked);
        this.line("Is Ready?: " + this.game.cache.isSoundReady(a.key) + " Pending Playback: " + a.pendingPlayback);
        this.line("Decoded: " + a.isDecoded + " Decoding: " + a.isDecoding);
        this.line("Total Duration: " + a.totalDuration + " Playing: " + a.isPlaying);
        this.line("Time: " + a.currentTime);
        this.line("Volume: " + a.volume + " Muted: " + a.mute);
        this.line("WebAudio: " + a.usingWebAudio + " Audio: " + a.usingAudioTag);
        if ("" !== a.currentMarker) {
          this.line("Marker: " + a.currentMarker + " Duration: " + a.duration + " (ms: " + a.durationMS + ")");
          this.line("Start: " + a.markers[a.currentMarker].start + " Stop: " + a.markers[a.currentMarker].stop);
          this.line("Position: " + a.position);
        }
        this.stop();
      },
      cameraInfo: function (a, b, c, d) {
        this.start(b, c, d);
        this.line("Camera (" + a.width + " x " + a.height + ")");
        this.line("X: " + a.x + " Y: " + a.y);
        if (a.bounds) {
          this.line("Bounds x: " + a.bounds.x + " Y: " + a.bounds.y + " w: " + a.bounds.width + " h: " + a.bounds.height);
        }
        this.line("View x: " + a.view.x + " Y: " + a.view.y + " w: " + a.view.width + " h: " + a.view.height);
        this.line("Total in view: " + a.totalInView);
        this.stop();
      },
      timer: function (a, b, c, d) {
        this.start(b, c, d);
        this.line("Timer (running: " + a.running + " expired: " + a.expired + ")");
        this.line("Next Tick: " + a.next + " Duration: " + a.duration);
        this.line("Paused: " + a.paused + " Length: " + a.length);
        this.stop();
      },
      pointer: function (a, b, c, d, e) {
        if (null != a) {
          if (undefined === b) {
            b = false;
          }
          c = c || "rgba(0,255,0,0.5)";
          d = d || "rgba(255,0,0,0.5)";
          if (!(true === b && true === a.isUp)) {
            this.start(a.x, a.y - 100, e);
            this.context.beginPath();
            this.context.arc(a.x, a.y, a.circle.radius, 0, 2 * Math.PI);
            if (a.active) {
              this.context.fillStyle = c;
            } else {
              this.context.fillStyle = d;
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(a.positionDown.x, a.positionDown.y);
            this.context.lineTo(a.position.x, a.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + a.id + " Active: " + a.active);
            this.line("World X: " + a.worldX + " World Y: " + a.worldY);
            this.line("Screen X: " + a.x + " Screen Y: " + a.y + " In: " + a.withinGame);
            this.line("Duration: " + a.duration + " ms");
            this.line("is Down: " + a.isDown + " is Up: " + a.isUp);
            this.stop();
          }
        }
      },
      spriteInputInfo: function (a, b, c, d) {
        this.start(b, c, d);
        this.line("Sprite Input: (" + a.width + " x " + a.height + ")");
        this.line("x: " + a.input.pointerX().toFixed(1) + " y: " + a.input.pointerY().toFixed(1));
        this.line("over: " + a.input.pointerOver() + " duration: " + a.input.overDuration().toFixed(0));
        this.line("down: " + a.input.pointerDown() + " duration: " + a.input.downDuration().toFixed(0));
        this.line("just over: " + a.input.justOver() + " just out: " + a.input.justOut());
        this.stop();
      },
      key: function (a, b, c, d) {
        this.start(b, c, d, 150);
        this.line("Key:", a.keyCode, "isDown:", a.isDown);
        this.line("justDown:", a.justDown, "justUp:", a.justUp);
        this.line("Time Down:", a.timeDown.toFixed(0), "duration:", a.duration.toFixed(0));
        this.stop();
      },
      inputInfo: function (a, b, c) {
        this.start(a, b, c);
        this.line("Input");
        this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
        this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
        this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
        this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
        this.stop();
      },
      spriteBounds: function (a, b, c) {
        var d = a.getBounds();
        d.x += this.game.camera.x;
        d.y += this.game.camera.y;
        this.rectangle(d, b, c);
      },
      ropeSegments: function (a, b, c) {
        var e = this;
        a.segments.forEach(function (a) {
          e.rectangle(a, b, c);
        }, this);
      },
      spriteInfo: function (a, b, c, d) {
        this.start(b, c, d);
        this.line("Sprite:  (" + a.width + " x " + a.height + ") anchor: " + a.anchor.x + " x " + a.anchor.y);
        this.line("x: " + a.x.toFixed(1) + " y: " + a.y.toFixed(1));
        this.line("angle: " + a.angle.toFixed(1) + " rotation: " + a.rotation.toFixed(1));
        this.line("visible: " + a.visible + " in camera: " + a.inCamera);
        this.line("bounds x: " + a._bounds.x.toFixed(1) + " y: " + a._bounds.y.toFixed(1) + " w: " + a._bounds.width.toFixed(1) + " h: " + a._bounds.height.toFixed(1));
        this.stop();
      },
      spriteCoords: function (a, b, c, d) {
        this.start(b, c, d, 100);
        if (a.name) {
          this.line(a.name);
        }
        this.line("x:", a.x.toFixed(2), "y:", a.y.toFixed(2));
        this.line("pos x:", a.position.x.toFixed(2), "pos y:", a.position.y.toFixed(2));
        this.line("world x:", a.world.x.toFixed(2), "world y:", a.world.y.toFixed(2));
        this.stop();
      },
      lineInfo: function (a, b, c, d) {
        this.start(b, c, d, 80);
        this.line("start.x:", a.start.x.toFixed(2), "start.y:", a.start.y.toFixed(2));
        this.line("end.x:", a.end.x.toFixed(2), "end.y:", a.end.y.toFixed(2));
        this.line("length:", a.length.toFixed(2), "angle:", a.angle);
        this.stop();
      },
      pixel: function (a, b, c, d) {
        d = d || 2;
        this.start();
        this.context.fillStyle = c;
        this.context.fillRect(a, b, d, d);
        this.stop();
      },
      geom: function (a, c, d, e) {
        if (undefined === d) {
          d = true;
        }
        if (undefined === e) {
          e = 0;
        }
        c = c || "rgba(0,255,0,0.4)";
        this.start();
        this.context.fillStyle = c;
        this.context.strokeStyle = c;
        if (a instanceof b.Rectangle || 1 === e) {
          if (d) {
            this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height);
          } else {
            this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height);
          }
        } else if (a instanceof b.Circle || 2 === e) {
          this.context.beginPath();
          this.context.arc(a.x - this.game.camera.x, a.y - this.game.camera.y, a.radius, 0, 2 * Math.PI, false);
          this.context.closePath();
          if (d) {
            this.context.fill();
          } else {
            this.context.stroke();
          }
        } else if (a instanceof b.Point || 3 === e) {
          this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, 4, 4);
        } else if (a instanceof b.Line || 4 === e) {
          this.context.lineWidth = 1;
          this.context.beginPath();
          this.context.moveTo(a.start.x + .5 - this.game.camera.x, a.start.y + .5 - this.game.camera.y);
          this.context.lineTo(a.end.x + .5 - this.game.camera.x, a.end.y + .5 - this.game.camera.y);
          this.context.closePath();
          this.context.stroke();
        }
        this.stop();
      },
      rectangle: function (a, b, c) {
        if (undefined === c) {
          c = true;
        }
        b = b || "rgba(0, 255, 0, 0.4)";
        this.start();
        if (c) {
          this.context.fillStyle = b;
          this.context.fillRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height);
        } else {
          this.context.strokeStyle = b;
          this.context.strokeRect(a.x - this.game.camera.x, a.y - this.game.camera.y, a.width, a.height);
        }
        this.stop();
      },
      text: function (a, b, c, d, e) {
        d = d || "rgb(255,255,255)";
        e = e || "16px Courier";
        this.start();
        this.context.font = e;
        if (this.renderShadow) {
          this.context.fillStyle = "rgb(0,0,0)";
          this.context.fillText(a, b + 1, c + 1);
        }
        this.context.fillStyle = d;
        this.context.fillText(a, b, c);
        this.stop();
      },
      quadTree: function (a, b) {
        b = b || "rgba(255,0,0,0.3)";
        this.start();
        var c = a.bounds;
        if (0 === a.nodes.length) {
          this.context.strokeStyle = b;
          this.context.strokeRect(c.x, c.y, c.width, c.height);
          this.text("size: " + a.objects.length, c.x + 4, c.y + 16, "rgb(0,200,0)", "12px Courier");
          this.context.strokeStyle = "rgb(0,255,0)";
          for (var d = 0; d < a.objects.length; d++) {
            this.context.strokeRect(a.objects[d].x, a.objects[d].y, a.objects[d].width, a.objects[d].height);
          }
        } else {
          for (var d = 0; d < a.nodes.length; d++) {
            this.quadTree(a.nodes[d]);
          }
        }
        this.stop();
      },
      body: function (a, c, d) {
        if (a.body) {
          this.start();
          if (a.body.type === b.Physics.ARCADE) {
            b.Physics.Arcade.Body.render(this.context, a.body, c, d);
          } else if (a.body.type === b.Physics.NINJA) {
            b.Physics.Ninja.Body.render(this.context, a.body, c, d);
          } else if (a.body.type === b.Physics.BOX2D) {
            b.Physics.Box2D.renderBody(this.context, a.body, c);
          }
          this.stop();
        }
      },
      bodyInfo: function (a, c, d, e) {
        if (a.body) {
          this.start(c, d, e, 210);
          if (a.body.type === b.Physics.ARCADE) {
            b.Physics.Arcade.Body.renderBodyInfo(this, a.body);
          } else if (a.body.type === b.Physics.BOX2D) {
            this.game.physics.box2d.renderBodyInfo(this, a.body);
          }
          this.stop();
        }
      },
      box2dWorld: function () {
        this.start();
        this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);
        this.game.physics.box2d.renderDebugDraw(this.context);
        this.stop();
      },
      box2dBody: function (a, c) {
        this.start();
        b.Physics.Box2D.renderBody(this.context, a, c);
        this.stop();
      },
      displayList: function (a) {
        if (undefined === a) {
          a = this.game.world;
        }
        if (a.hasOwnProperty("renderOrderID")) {
          console.log("[" + a.renderOrderID + "]", a);
        } else {
          console.log("[]", a);
        }
        if (a.children && a.children.length > 0) {
          for (var b = 0; b < a.children.length; b++) {
            this.game.debug.displayList(a.children[b]);
          }
        }
      },
      destroy: function () {
        PIXI.CanvasPool.remove(this);
      }
    };
    b.Utils.Debug.prototype.constructor = b.Utils.Debug;
    b.DOM = {
      getOffset: function (a, c) {
        c = c || new b.Point();
        var d = a.getBoundingClientRect();
        var e = b.DOM.scrollY;
        var f = b.DOM.scrollX;
        var g = document.documentElement.clientTop;
        var h = document.documentElement.clientLeft;
        c.x = d.left + f - h;
        c.y = d.top + e - g;
        return c;
      },
      getBounds: function (a, b) {
        if (undefined === b) {
          b = 0;
        }
        return !(!(a = a && !a.nodeType ? a[0] : a) || 1 !== a.nodeType) && this.calibrate(a.getBoundingClientRect(), b);
      },
      calibrate: function (a, b) {
        b = +b || 0;
        var c = {
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        c.width = (c.right = a.right + b) - (c.left = a.left - b);
        c.height = (c.bottom = a.bottom + b) - (c.top = a.top - b);
        return c;
      },
      getAspectRatio: function (a) {
        a = null == a ? this.visualBounds : 1 === a.nodeType ? this.getBounds(a) : a;
        var b = a.width;
        var c = a.height;
        if ("function" == typeof b) {
          b = b.call(a);
        }
        if ("function" == typeof c) {
          c = c.call(a);
        }
        return b / c;
      },
      inLayoutViewport: function (a, b) {
        var c = this.getBounds(a, b);
        return !!c && c.bottom >= 0 && c.right >= 0 && c.top <= this.layoutBounds.width && c.left <= this.layoutBounds.height;
      },
      getScreenOrientation: function (a) {
        var b = window.screen;
        var c = b.orientation || b.mozOrientation || b.msOrientation;
        if (c && "string" == typeof c.type) {
          return c.type;
        }
        if ("string" == typeof c) {
          return c;
        }
        if ("screen" === a) {
          return b.height > b.width ? "portrait-primary" : "landscape-primary";
        }
        if ("viewport" === a) {
          return this.visualBounds.height > this.visualBounds.width ? "portrait-primary" : "landscape-primary";
        }
        if ("window.orientation" === a && "number" == typeof window.orientation) {
          return 0 === window.orientation || 180 === window.orientation ? "portrait-primary" : "landscape-primary";
        }
        if (window.matchMedia) {
          if (window.matchMedia("(orientation: portrait)").matches) {
            return "portrait-primary";
          }
          if (window.matchMedia("(orientation: landscape)").matches) {
            return "landscape-primary";
          }
        }
        return this.visualBounds.height > this.visualBounds.width ? "portrait-primary" : "landscape-primary";
      },
      visualBounds: new b.Rectangle(),
      layoutBounds: new b.Rectangle(),
      documentBounds: new b.Rectangle()
    };
    b.Device.whenReady(function (a) {
      var c = window && "pageXOffset" in window ? function () {
        return window.pageXOffset;
      } : function () {
        return document.documentElement.scrollLeft;
      };
      var d = window && "pageYOffset" in window ? function () {
        return window.pageYOffset;
      } : function () {
        return document.documentElement.scrollTop;
      };
      Object.defineProperty(b.DOM, "scrollX", {
        get: c
      });
      Object.defineProperty(b.DOM, "scrollY", {
        get: d
      });
      Object.defineProperty(b.DOM.visualBounds, "x", {
        get: c
      });
      Object.defineProperty(b.DOM.visualBounds, "y", {
        get: d
      });
      Object.defineProperty(b.DOM.layoutBounds, "x", {
        value: 0
      });
      Object.defineProperty(b.DOM.layoutBounds, "y", {
        value: 0
      });
      if (a.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
        var f = function () {
          return Math.max(window.innerWidth, document.documentElement.clientWidth);
        };
        var g = function () {
          return Math.max(window.innerHeight, document.documentElement.clientHeight);
        };
        Object.defineProperty(b.DOM.visualBounds, "width", {
          get: f
        });
        Object.defineProperty(b.DOM.visualBounds, "height", {
          get: g
        });
        Object.defineProperty(b.DOM.layoutBounds, "width", {
          get: f
        });
        Object.defineProperty(b.DOM.layoutBounds, "height", {
          get: g
        });
      } else {
        Object.defineProperty(b.DOM.visualBounds, "width", {
          get: function () {
            return window.innerWidth;
          }
        });
        Object.defineProperty(b.DOM.visualBounds, "height", {
          get: function () {
            return window.innerHeight;
          }
        });
        Object.defineProperty(b.DOM.layoutBounds, "width", {
          get: function () {
            var a = document.documentElement.clientWidth;
            var b = window.innerWidth;
            return a < b ? b : a;
          }
        });
        Object.defineProperty(b.DOM.layoutBounds, "height", {
          get: function () {
            var a = document.documentElement.clientHeight;
            var b = window.innerHeight;
            return a < b ? b : a;
          }
        });
      }
      Object.defineProperty(b.DOM.documentBounds, "x", {
        value: 0
      });
      Object.defineProperty(b.DOM.documentBounds, "y", {
        value: 0
      });
      Object.defineProperty(b.DOM.documentBounds, "width", {
        get: function () {
          var a = document.documentElement;
          return Math.max(a.clientWidth, a.offsetWidth, a.scrollWidth);
        }
      });
      Object.defineProperty(b.DOM.documentBounds, "height", {
        get: function () {
          var a = document.documentElement;
          return Math.max(a.clientHeight, a.offsetHeight, a.scrollHeight);
        }
      });
    }, null, true);
    b.ArraySet = function (a) {
      this.position = 0;
      this.list = a || [];
    };
    b.ArraySet.prototype = {
      add: function (a) {
        if (!this.exists(a)) {
          this.list.push(a);
        }
        return a;
      },
      getIndex: function (a) {
        return this.list.indexOf(a);
      },
      getByKey: function (a, b) {
        for (var c = this.list.length; c--;) {
          if (this.list[c][a] === b) {
            return this.list[c];
          }
        }
        return null;
      },
      exists: function (a) {
        return this.list.indexOf(a) > -1;
      },
      reset: function () {
        this.list.length = 0;
      },
      remove: function (a) {
        var b = this.list.indexOf(a);
        if (b > -1) {
          this.list.splice(b, 1);
          return a;
        }
      },
      setAll: function (a, b) {
        for (var c = this.list.length; c--;) {
          if (this.list[c]) {
            this.list[c][a] = b;
          }
        }
      },
      callAll: function (a) {
        var b = Array.prototype.slice.call(arguments, 1);
        for (var c = this.list.length; c--;) {
          if (this.list[c] && this.list[c][a]) {
            this.list[c][a].apply(this.list[c], b);
          }
        }
      },
      removeAll: function (a) {
        if (undefined === a) {
          a = false;
        }
        for (var b = this.list.length; b--;) {
          if (this.list[b]) {
            var c = this.remove(this.list[b]);
            if (a) {
              c.destroy();
            }
          }
        }
        this.position = 0;
        this.list = [];
      }
    };
    Object.defineProperty(b.ArraySet.prototype, "total", {
      get: function () {
        return this.list.length;
      }
    });
    Object.defineProperty(b.ArraySet.prototype, "first", {
      get: function () {
        this.position = 0;
        return this.list.length > 0 ? this.list[0] : null;
      }
    });
    Object.defineProperty(b.ArraySet.prototype, "next", {
      get: function () {
        return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
      }
    });
    b.ArraySet.prototype.constructor = b.ArraySet;
    b.ArrayUtils = {
      getRandomItem: function (a, b, c) {
        if (null === a) {
          return null;
        }
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = a.length;
        }
        var d = b + Math.floor(Math.random() * c);
        return undefined === a[d] ? null : a[d];
      },
      removeRandomItem: function (a, b, c) {
        if (null == a) {
          return null;
        }
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = a.length;
        }
        var d = b + Math.floor(Math.random() * c);
        if (d < a.length) {
          var e = a.splice(d, 1);
          return undefined === e[0] ? null : e[0];
        }
        return null;
      },
      shuffle: function (a) {
        for (var b = a.length - 1; b > 0; b--) {
          var c = Math.floor(Math.random() * (b + 1));
          var d = a[b];
          a[b] = a[c];
          a[c] = d;
        }
        return a;
      },
      transposeMatrix: function (a) {
        var b = a.length;
        var c = a[0].length;
        var d = new Array(c);
        for (var e = 0; e < c; e++) {
          d[e] = new Array(b);
          for (var f = b - 1; f > -1; f--) {
            d[e][f] = a[f][e];
          }
        }
        return d;
      },
      rotateMatrix: function (a, c) {
        if ("string" != typeof c) {
          c = (c % 360 + 360) % 360;
        }
        if (90 === c || -270 === c || "rotateLeft" === c) {
          a = b.ArrayUtils.transposeMatrix(a);
          a = a.reverse();
        } else if (-90 === c || 270 === c || "rotateRight" === c) {
          a = a.reverse();
          a = b.ArrayUtils.transposeMatrix(a);
        } else if (180 === Math.abs(c) || "rotate180" === c) {
          for (var d = 0; d < a.length; d++) {
            a[d].reverse();
          }
          a = a.reverse();
        }
        return a;
      },
      findClosest: function (a, b) {
        if (!b.length) {
          return NaN;
        }
        if (1 === b.length || a < b[0]) {
          return b[0];
        }
        for (var c = 1; b[c] < a;) {
          c++;
        }
        var d = b[c - 1];
        var e = c < b.length ? b[c] : Number.POSITIVE_INFINITY;
        return e - a <= a - d ? e : d;
      },
      rotateRight: function (a) {
        var b = a.pop();
        a.unshift(b);
        return b;
      },
      rotateLeft: function (a) {
        var b = a.shift();
        a.push(b);
        return b;
      },
      rotate: function (a) {
        var b = a.shift();
        a.push(b);
        return b;
      },
      numberArray: function (a, b) {
        var c = [];
        for (var d = a; d <= b; d++) {
          c.push(d);
        }
        return c;
      },
      numberArrayStep: function (a, c, d) {
        if (!(undefined !== a && null !== a)) {
          a = 0;
        }
        if (!(undefined !== a && null !== a)) {
          c = a;
          a = 0;
        }
        if (undefined === d) {
          d = 1;
        }
        var e = [];
        var f = Math.max(b.Math.roundAwayFromZero((a - a) / (d || 1)), 0);
        for (var g = 0; g < f; g++) {
          e.push(a);
          a += d;
        }
        return e;
      }
    };
    b.LinkedList = function () {
      this.next = null;
      this.prev = null;
      this.first = null;
      this.last = null;
      this.total = 0;
    };
    b.LinkedList.prototype = {
      add: function (a) {
        return 0 === this.total && null === this.first && null === this.last ? (this.first = a, this.last = a, this.next = a, a.prev = this, this.total++, a) : (this.last.next = a, a.prev = this.last, this.last = a, this.total++, a);
      },
      reset: function () {
        this.first = null;
        this.last = null;
        this.next = null;
        this.prev = null;
        this.total = 0;
      },
      remove: function (a) {
        if (1 === this.total) {
          this.reset();
          return void (a.next = a.prev = null);
        }
        if (a === this.first) {
          this.first = this.first.next;
        } else if (a === this.last) {
          this.last = this.last.prev;
        }
        if (a.prev) {
          a.prev.next = a.next;
        }
        if (a.next) {
          a.next.prev = a.prev;
        }
        a.next = a.prev = null;
        if (null === this.first) {
          this.last = null;
        }
        this.total--;
      },
      callAll: function (a) {
        if (this.first && this.last) {
          var b = this.first;
          do {
            if (b && b[a]) {
              b[a].call(b);
            }
            b = b.next;
          } while (b !== this.last.next);
        }
      }
    };
    b.LinkedList.prototype.constructor = b.LinkedList;
    b.Create = function (a) {
      this.game = a;
      this.bmd = null;
      this.canvas = null;
      this.ctx = null;
      this.palettes = [{
        0: "#000",
        1: "#9D9D9D",
        2: "#FFF",
        3: "#BE2633",
        4: "#E06F8B",
        5: "#493C2B",
        6: "#A46422",
        7: "#EB8931",
        8: "#F7E26B",
        9: "#2F484E",
        A: "#44891A",
        B: "#A3CE27",
        C: "#1B2632",
        D: "#005784",
        E: "#31A2F2",
        F: "#B2DCEF"
      }, {
        0: "#000",
        1: "#191028",
        2: "#46af45",
        3: "#a1d685",
        4: "#453e78",
        5: "#7664fe",
        6: "#833129",
        7: "#9ec2e8",
        8: "#dc534b",
        9: "#e18d79",
        A: "#d6b97b",
        B: "#e9d8a1",
        C: "#216c4b",
        D: "#d365c8",
        E: "#afaab9",
        F: "#f5f4eb"
      }, {
        0: "#000",
        1: "#2234d1",
        2: "#0c7e45",
        3: "#44aacc",
        4: "#8a3622",
        5: "#5c2e78",
        6: "#aa5c3d",
        7: "#b5b5b5",
        8: "#5e606e",
        9: "#4c81fb",
        A: "#6cd947",
        B: "#7be2f9",
        C: "#eb8a60",
        D: "#e23d69",
        E: "#ffd93f",
        F: "#fff"
      }, {
        0: "#000",
        1: "#fff",
        2: "#8b4131",
        3: "#7bbdc5",
        4: "#8b41ac",
        5: "#6aac41",
        6: "#3931a4",
        7: "#d5de73",
        8: "#945a20",
        9: "#5a4100",
        A: "#bd736a",
        B: "#525252",
        C: "#838383",
        D: "#acee8b",
        E: "#7b73de",
        F: "#acacac"
      }, {
        0: "#000",
        1: "#191028",
        2: "#46af45",
        3: "#a1d685",
        4: "#453e78",
        5: "#7664fe",
        6: "#833129",
        7: "#9ec2e8",
        8: "#dc534b",
        9: "#e18d79",
        A: "#d6b97b",
        B: "#e9d8a1",
        C: "#216c4b",
        D: "#d365c8",
        E: "#afaab9",
        F: "#fff"
      }];
    };
    b.Create.PALETTE_ARNE = 0;
    b.Create.PALETTE_JMP = 1;
    b.Create.PALETTE_CGA = 2;
    b.Create.PALETTE_C64 = 3;
    b.Create.PALETTE_JAPANESE_MACHINE = 4;
    b.Create.prototype = {
      texture: function (a, b, c, d, e) {
        if (undefined === c) {
          c = 8;
        }
        if (undefined === c) {
          d = c;
        }
        if (undefined === e) {
          e = 0;
        }
        var f = b[0].length * c;
        var g = b.length * c;
        if (null === this.bmd) {
          this.bmd = this.game.make.bitmapData();
          this.canvas = this.bmd.canvas;
          this.ctx = this.bmd.context;
        }
        this.bmd.resize(f, g);
        this.bmd.clear();
        for (var h = 0; h < b.length; h++) {
          var i = b[h];
          for (var j = 0; j < i.length; j++) {
            var k = i[j];
            if ("." !== k && " " !== k) {
              this.ctx.fillStyle = this.palettes[e][k];
              this.ctx.fillRect(j * c, h * c, c, c);
            }
          }
        }
        return this.bmd.generateTexture(a);
      },
      grid: function (a, b, c, d, e, f) {
        if (null === this.bmd) {
          this.bmd = this.game.make.bitmapData();
          this.canvas = this.bmd.canvas;
          this.ctx = this.bmd.context;
        }
        this.bmd.resize(b, c);
        this.ctx.fillStyle = f;
        for (var g = 0; g < c; g += e) {
          this.ctx.fillRect(0, g, b, 1);
        }
        for (var h = 0; h < b; h += d) {
          this.ctx.fillRect(h, 0, 1, c);
        }
        return this.bmd.generateTexture(a);
      }
    };
    b.Create.prototype.constructor = b.Create;
    b.FlexGrid = function (a, c, d) {
      this.game = a.game;
      this.manager = a;
      this.width = c;
      this.height = d;
      this.boundsCustom = new b.Rectangle(0, 0, c, d);
      this.boundsFluid = new b.Rectangle(0, 0, c, d);
      this.boundsFull = new b.Rectangle(0, 0, c, d);
      this.boundsNone = new b.Rectangle(0, 0, c, d);
      this.positionCustom = new b.Point(0, 0);
      this.positionFluid = new b.Point(0, 0);
      this.positionFull = new b.Point(0, 0);
      this.positionNone = new b.Point(0, 0);
      this.scaleCustom = new b.Point(1, 1);
      this.scaleFluid = new b.Point(1, 1);
      this.scaleFluidInversed = new b.Point(1, 1);
      this.scaleFull = new b.Point(1, 1);
      this.scaleNone = new b.Point(1, 1);
      this.customWidth = 0;
      this.customHeight = 0;
      this.customOffsetX = 0;
      this.customOffsetY = 0;
      this.ratioH = c / d;
      this.ratioV = d / c;
      this.multiplier = 0;
      this.layers = [];
    };
    b.FlexGrid.prototype = {
      setSize: function (a, c) {
        this.width = a;
        this.height = c;
        this.ratioH = a / c;
        this.ratioV = c / a;
        this.scaleNone = new b.Point(1, 1);
        this.boundsNone.width = this.width;
        this.boundsNone.height = this.height;
        this.refresh();
      },
      createCustomLayer: function (a, c, d, e) {
        if (undefined === e) {
          e = true;
        }
        this.customWidth = a;
        this.customHeight = c;
        this.boundsCustom.width = a;
        this.boundsCustom.height = c;
        var f = new b.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
        if (e) {
          this.game.world.add(f);
        }
        this.layers.push(f);
        if (undefined !== d && null !== typeof d) {
          f.addMultiple(d);
        }
        return f;
      },
      createFluidLayer: function (a, c) {
        if (undefined === c) {
          c = true;
        }
        var d = new b.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
        if (c) {
          this.game.world.add(d);
        }
        this.layers.push(d);
        if (undefined !== a && null !== typeof a) {
          d.addMultiple(a);
        }
        return d;
      },
      createFullLayer: function (a) {
        var c = new b.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
        this.game.world.add(c);
        this.layers.push(c);
        if (undefined !== a) {
          c.addMultiple(a);
        }
        return c;
      },
      createFixedLayer: function (a) {
        var c = new b.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
        this.game.world.add(c);
        this.layers.push(c);
        if (undefined !== a) {
          c.addMultiple(a);
        }
        return c;
      },
      reset: function () {
        for (var a = this.layers.length; a--;) {
          if (!this.layers[a].persist) {
            this.layers[a].position = null;
            this.layers[a].scale = null;
            this.layers.slice(a, 1);
          }
        }
      },
      onResize: function (a, b) {
        this.ratioH = a / b;
        this.ratioV = b / a;
        this.refresh(a, b);
      },
      refresh: function () {
        this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width);
        this.boundsFluid.width = Math.round(this.width * this.multiplier);
        this.boundsFluid.height = Math.round(this.height * this.multiplier);
        this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height);
        this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height);
        this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height);
        this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x);
        this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y);
        this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
        this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
        this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y);
        this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
      },
      fitSprite: function (a) {
        this.manager.scaleSprite(a);
        a.x = this.manager.bounds.centerX;
        a.y = this.manager.bounds.centerY;
      },
      debug: function () {
        this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16);
        this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", false);
      }
    };
    b.FlexGrid.prototype.constructor = b.FlexGrid;
    b.FlexLayer = function (a, c, d, e) {
      b.Group.call(this, a.game, null, "__flexLayer" + a.game.rnd.uuid(), false);
      this.manager = a.manager;
      this.grid = a;
      this.persist = false;
      this.position = c;
      this.bounds = d;
      this.scale = e;
      this.topLeft = d.topLeft;
      this.topMiddle = new b.Point(d.halfWidth, 0);
      this.topRight = d.topRight;
      this.bottomLeft = d.bottomLeft;
      this.bottomMiddle = new b.Point(d.halfWidth, d.bottom);
      this.bottomRight = d.bottomRight;
    };
    b.FlexLayer.prototype = Object.create(b.Group.prototype);
    b.FlexLayer.prototype.constructor = b.FlexLayer;
    b.FlexLayer.prototype.resize = function () {};
    b.FlexLayer.prototype.debug = function () {
      this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16);
      this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", false);
      this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9");
      this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9");
      this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
    };
    b.Color = {
      packPixel: function (a, c, d, e) {
        return b.Device.LITTLE_ENDIAN ? (e << 24 | d << 16 | c << 8 | a) >>> 0 : (a << 24 | c << 16 | d << 8 | e) >>> 0;
      },
      unpackPixel: function (a, c, d, e) {
        if (!(undefined !== c && null !== c)) {
          c = b.Color.createColor();
        }
        if (!(undefined !== d && null !== d)) {
          d = false;
        }
        if (!(undefined !== e && null !== e)) {
          e = false;
        }
        if (b.Device.LITTLE_ENDIAN) {
          c.a = (4278190080 & a) >>> 24;
          c.b = (16711680 & a) >>> 16;
          c.g = (65280 & a) >>> 8;
          c.r = 255 & a;
        } else {
          c.r = (4278190080 & a) >>> 24;
          c.g = (16711680 & a) >>> 16;
          c.b = (65280 & a) >>> 8;
          c.a = 255 & a;
        }
        c.color = a;
        c.rgba = "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a / 255 + ")";
        if (d) {
          b.Color.RGBtoHSL(c.r, c.g, c.b, c);
        }
        if (e) {
          b.Color.RGBtoHSV(c.r, c.g, c.b, c);
        }
        return c;
      },
      fromRGBA: function (a, c) {
        if (!c) {
          c = b.Color.createColor();
        }
        c.r = (4278190080 & a) >>> 24;
        c.g = (16711680 & a) >>> 16;
        c.b = (65280 & a) >>> 8;
        c.a = 255 & a;
        c.rgba = "rgba(" + c.r + "," + c.g + "," + c.b + "," + c.a + ")";
        return c;
      },
      toRGBA: function (a, b, c, d) {
        return a << 24 | b << 16 | c << 8 | d;
      },
      toABGR: function (a, b, c, d) {
        return (d << 24 | c << 16 | b << 8 | a) >>> 0;
      },
      RGBtoHSL: function (a, c, d, e) {
        if (!e) {
          e = b.Color.createColor(a, c, d, 1);
        }
        a /= 255;
        c /= 255;
        d /= 255;
        var f = Math.min(a, c, d);
        var g = Math.max(a, c, d);
        e.h = 0;
        e.s = 0;
        e.l = (g + f) / 2;
        if (g !== f) {
          var h = g - f;
          e.s = e.l > .5 ? h / (2 - g - f) : h / (g + f);
          if (g === a) {
            e.h = (c - d) / h + (c < d ? 6 : 0);
          } else if (g === c) {
            e.h = (d - a) / h + 2;
          } else if (g === d) {
            e.h = (a - c) / h + 4;
          }
          e.h /= 6;
        }
        return e;
      },
      HSLtoRGB: function (a, c, d, e) {
        if (e) {
          e.r = d;
          e.g = d;
          e.b = d;
        } else {
          e = b.Color.createColor(d, d, d);
        }
        if (0 !== c) {
          var f = d < .5 ? d * (1 + c) : d + c - d * c;
          var g = 2 * d - f;
          e.r = b.Color.hueToColor(g, f, a + 0.3333333333333333);
          e.g = b.Color.hueToColor(g, f, a);
          e.b = b.Color.hueToColor(g, f, a - 0.3333333333333333);
        }
        e.r = Math.floor(255 * e.r | 0);
        e.g = Math.floor(255 * e.g | 0);
        e.b = Math.floor(255 * e.b | 0);
        b.Color.updateColor(e);
        return e;
      },
      RGBtoHSV: function (a, c, d, e) {
        if (!e) {
          e = b.Color.createColor(a, c, d, 255);
        }
        a /= 255;
        c /= 255;
        d /= 255;
        var f = Math.min(a, c, d);
        var g = Math.max(a, c, d);
        var h = g - f;
        e.h = 0;
        e.s = 0 === g ? 0 : h / g;
        e.v = g;
        if (g !== f) {
          if (g === a) {
            e.h = (c - d) / h + (c < d ? 6 : 0);
          } else if (g === c) {
            e.h = (d - a) / h + 2;
          } else if (g === d) {
            e.h = (a - c) / h + 4;
          }
          e.h /= 6;
        }
        return e;
      },
      HSVtoRGB: function (a, c, d, e) {
        if (undefined === e) {
          e = b.Color.createColor(0, 0, 0, 1, a, c, 0, d);
        }
        var f;
        var g;
        var h;
        var i = Math.floor(6 * a);
        var j = 6 * a - i;
        var k = d * (1 - c);
        var l = d * (1 - j * c);
        var m = d * (1 - (1 - j) * c);
        switch (i % 6) {
          case 0:
            f = d;
            g = m;
            h = k;
            break;
          case 1:
            f = l;
            g = d;
            h = k;
            break;
          case 2:
            f = k;
            g = d;
            h = m;
            break;
          case 3:
            f = k;
            g = l;
            h = d;
            break;
          case 4:
            f = m;
            g = k;
            h = d;
            break;
          case 5:
            f = d;
            g = k;
            h = l;
        }
        e.r = Math.floor(255 * f);
        e.g = Math.floor(255 * g);
        e.b = Math.floor(255 * h);
        b.Color.updateColor(e);
        return e;
      },
      hueToColor: function (a, b, c) {
        if (c < 0) {
          c += 1;
        }
        if (c > 1) {
          c -= 1;
        }
        return c < 0.16666666666666666 ? a + 6 * (b - a) * c : c < .5 ? b : c < 0.6666666666666666 ? a + (b - a) * (0.6666666666666666 - c) * 6 : a;
      },
      createColor: function (a, c, d, e, f, g, h, i) {
        var j = {
          r: a || 0,
          g: c || 0,
          b: d || 0,
          a: e || 1,
          h: f || 0,
          s: g || 0,
          l: h || 0,
          v: i || 0,
          color: 0,
          color32: 0,
          rgba: ""
        };
        return b.Color.updateColor(j);
      },
      updateColor: function (a) {
        a.rgba = "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + a.a.toString() + ")";
        a.color = b.Color.getColor(a.r, a.g, a.b);
        a.color32 = b.Color.getColor32(255 * a.a, a.r, a.g, a.b);
        return a;
      },
      getColor32: function (a, b, c, d) {
        return a << 24 | b << 16 | c << 8 | d;
      },
      getColor: function (a, b, c) {
        return a << 16 | b << 8 | c;
      },
      RGBtoString: function (a, c, d, e, f) {
        if (undefined === e) {
          e = 255;
        }
        if (undefined === f) {
          f = "#";
        }
        return "#" === f ? "#" + (16777216 + (a << 16) + (c << 8) + d).toString(16).slice(1) : "0x" + b.Color.componentToHex(e) + b.Color.componentToHex(a) + b.Color.componentToHex(c) + b.Color.componentToHex(d);
      },
      hexToRGB: function (a) {
        var c = b.Color.hexToColor(a);
        if (c) {
          return b.Color.getColor32(c.a, c.r, c.g, c.b);
        }
      },
      hexToColor: function (a, c) {
        a = a.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (a, b, c, d) {
          return b + b + c + c + d + d;
        });
        var d = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
        if (d) {
          var e = parseInt(d[1], 16);
          var f = parseInt(d[2], 16);
          var g = parseInt(d[3], 16);
          if (c) {
            c.r = e;
            c.g = f;
            c.b = g;
          } else {
            c = b.Color.createColor(e, f, g);
          }
        }
        return c;
      },
      webToColor: function (a, c) {
        if (!c) {
          c = b.Color.createColor();
        }
        var d = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(a);
        if (d) {
          c.r = parseInt(d[1], 10);
          c.g = parseInt(d[2], 10);
          c.b = parseInt(d[3], 10);
          c.a = undefined !== d[4] ? parseFloat(d[4]) : 1;
          b.Color.updateColor(c);
        }
        return c;
      },
      valueToColor: function (a, c) {
        if (!c) {
          c = b.Color.createColor();
        }
        if ("string" == typeof a) {
          return 0 === a.indexOf("rgb") ? b.Color.webToColor(a, c) : (c.a = 1, b.Color.hexToColor(a, c));
        }
        if ("number" == typeof a) {
          var d = b.Color.getRGB(a);
          c.r = d.r;
          c.g = d.g;
          c.b = d.b;
          c.a = d.a / 255;
          return c;
        }
        return c;
      },
      componentToHex: function (a) {
        var b = a.toString(16);
        return 1 === b.length ? "0" + b : b;
      },
      HSVColorWheel: function (a, c) {
        if (undefined === a) {
          a = 1;
        }
        if (undefined === c) {
          c = 1;
        }
        var d = [];
        for (var e = 0; e <= 359; e++) {
          d.push(b.Color.HSVtoRGB(e / 359, a, c));
        }
        return d;
      },
      HSLColorWheel: function (a, c) {
        if (undefined === a) {
          a = .5;
        }
        if (undefined === c) {
          c = .5;
        }
        var d = [];
        for (var e = 0; e <= 359; e++) {
          d.push(b.Color.HSLtoRGB(e / 359, a, c));
        }
        return d;
      },
      interpolateColor: function (a, c, d, e, f) {
        if (undefined === f) {
          f = 255;
        }
        var g = b.Color.getRGB(a);
        var h = b.Color.getRGB(c);
        var i = (h.red - g.red) * e / d + g.red;
        var j = (h.green - g.green) * e / d + g.green;
        var k = (h.blue - g.blue) * e / d + g.blue;
        return b.Color.getColor32(f, i, j, k);
      },
      interpolateColorWithRGB: function (a, c, d, e, f, g) {
        var h = b.Color.getRGB(a);
        var i = (c - h.red) * g / f + h.red;
        var j = (d - h.green) * g / f + h.green;
        var k = (e - h.blue) * g / f + h.blue;
        return b.Color.getColor(i, j, k);
      },
      interpolateRGB: function (a, c, d, e, f, g, h, i) {
        var j = (e - a) * i / h + a;
        var k = (f - c) * i / h + c;
        var l = (g - d) * i / h + d;
        return b.Color.getColor(j, k, l);
      },
      getRandomColor: function (a, c, d) {
        if (undefined === a) {
          a = 0;
        }
        if (undefined === c) {
          c = 255;
        }
        if (undefined === d) {
          d = 255;
        }
        if (c > 255 || a > c) {
          return b.Color.getColor(255, 255, 255);
        }
        var e = a + Math.round(Math.random() * (c - a));
        var f = a + Math.round(Math.random() * (c - a));
        var g = a + Math.round(Math.random() * (c - a));
        return b.Color.getColor32(d, e, f, g);
      },
      getRGB: function (a) {
        return a > 16777215 ? {
          alpha: a >>> 24,
          red: a >> 16 & 255,
          green: a >> 8 & 255,
          blue: 255 & a,
          a: a >>> 24,
          r: a >> 16 & 255,
          g: a >> 8 & 255,
          b: 255 & a
        } : {
          alpha: 255,
          red: a >> 16 & 255,
          green: a >> 8 & 255,
          blue: 255 & a,
          a: 255,
          r: a >> 16 & 255,
          g: a >> 8 & 255,
          b: 255 & a
        };
      },
      getWebRGB: function (a) {
        if ("object" == typeof a) {
          return "rgba(" + a.r.toString() + "," + a.g.toString() + "," + a.b.toString() + "," + (a.a / 255).toString() + ")";
        }
        var c = b.Color.getRGB(a);
        return "rgba(" + c.r.toString() + "," + c.g.toString() + "," + c.b.toString() + "," + (c.a / 255).toString() + ")";
      },
      getAlpha: function (a) {
        return a >>> 24;
      },
      getAlphaFloat: function (a) {
        return (a >>> 24) / 255;
      },
      getRed: function (a) {
        return a >> 16 & 255;
      },
      getGreen: function (a) {
        return a >> 8 & 255;
      },
      getBlue: function (a) {
        return 255 & a;
      },
      blendNormal: function (a) {
        return a;
      },
      blendLighten: function (a, b) {
        return b > a ? b : a;
      },
      blendDarken: function (a, b) {
        return b > a ? a : b;
      },
      blendMultiply: function (a, b) {
        return a * b / 255;
      },
      blendAverage: function (a, b) {
        return (a + b) / 2;
      },
      blendAdd: function (a, b) {
        return Math.min(255, a + b);
      },
      blendSubtract: function (a, b) {
        return Math.max(0, a + b - 255);
      },
      blendDifference: function (a, b) {
        return Math.abs(a - b);
      },
      blendNegation: function (a, b) {
        return 255 - Math.abs(255 - a - b);
      },
      blendScreen: function (a, b) {
        return 255 - ((255 - a) * (255 - b) >> 8);
      },
      blendExclusion: function (a, b) {
        return a + b - 2 * a * b / 255;
      },
      blendOverlay: function (a, b) {
        return b < 128 ? 2 * a * b / 255 : 255 - 2 * (255 - a) * (255 - b) / 255;
      },
      blendSoftLight: function (a, b) {
        return b < 128 ? 2 * (64 + (a >> 1)) * (b / 255) : 255 - 2 * (255 - (64 + (a >> 1))) * (255 - b) / 255;
      },
      blendHardLight: function (a, c) {
        return b.Color.blendOverlay(c, a);
      },
      blendColorDodge: function (a, b) {
        return 255 === b ? b : Math.min(255, (a << 8) / (255 - b));
      },
      blendColorBurn: function (a, b) {
        return 0 === b ? b : Math.max(0, 255 - (255 - a << 8) / b);
      },
      blendLinearDodge: function (a, c) {
        return b.Color.blendAdd(a, c);
      },
      blendLinearBurn: function (a, c) {
        return b.Color.blendSubtract(a, c);
      },
      blendLinearLight: function (a, c) {
        return c < 128 ? b.Color.blendLinearBurn(a, 2 * c) : b.Color.blendLinearDodge(a, 2 * (c - 128));
      },
      blendVividLight: function (a, c) {
        return c < 128 ? b.Color.blendColorBurn(a, 2 * c) : b.Color.blendColorDodge(a, 2 * (c - 128));
      },
      blendPinLight: function (a, c) {
        return c < 128 ? b.Color.blendDarken(a, 2 * c) : b.Color.blendLighten(a, 2 * (c - 128));
      },
      blendHardMix: function (a, c) {
        return b.Color.blendVividLight(a, c) < 128 ? 0 : 255;
      },
      blendReflect: function (a, b) {
        return 255 === b ? b : Math.min(255, a * a / (255 - b));
      },
      blendGlow: function (a, c) {
        return b.Color.blendReflect(c, a);
      },
      blendPhoenix: function (a, b) {
        return Math.min(a, b) - Math.max(a, b) + 255;
      }
    };
    b.Physics = function (a, b) {
      b = b || {};
      this.game = a;
      this.config = b;
      this.arcade = null;
      this.p2 = null;
      this.ninja = null;
      this.box2d = null;
      this.chipmunk = null;
      this.matter = null;
      this.parseConfig();
    };
    b.Physics.ARCADE = 0;
    b.Physics.P2JS = 1;
    b.Physics.NINJA = 2;
    b.Physics.BOX2D = 3;
    b.Physics.CHIPMUNK = 4;
    b.Physics.MATTERJS = 5;
    b.Physics.prototype = {
      parseConfig: function () {
        if (!(this.config.hasOwnProperty("arcade") && true !== this.config.arcade || !b.Physics.hasOwnProperty("Arcade"))) {
          this.arcade = new b.Physics.Arcade(this.game);
        }
        if (this.config.hasOwnProperty("ninja") && true === this.config.ninja && b.Physics.hasOwnProperty("Ninja")) {
          this.ninja = new b.Physics.Ninja(this.game);
        }
        if (this.config.hasOwnProperty("p2") && true === this.config.p2 && b.Physics.hasOwnProperty("P2")) {
          this.p2 = new b.Physics.P2(this.game, this.config);
        }
        if (this.config.hasOwnProperty("box2d") && true === this.config.box2d && b.Physics.hasOwnProperty("BOX2D")) {
          this.box2d = new b.Physics.BOX2D(this.game, this.config);
        }
        if (this.config.hasOwnProperty("matter") && true === this.config.matter && b.Physics.hasOwnProperty("Matter")) {
          this.matter = new b.Physics.Matter(this.game, this.config);
        }
      },
      startSystem: function (a) {
        if (a === b.Physics.ARCADE) {
          this.arcade = new b.Physics.Arcade(this.game);
        } else if (a === b.Physics.P2JS) {
          if (null === this.p2) {
            this.p2 = new b.Physics.P2(this.game, this.config);
          } else {
            this.p2.reset();
          }
        } else if (a === b.Physics.NINJA) {
          this.ninja = new b.Physics.Ninja(this.game);
        } else if (a === b.Physics.BOX2D) {
          if (null === this.box2d) {
            this.box2d = new b.Physics.Box2D(this.game, this.config);
          } else {
            this.box2d.reset();
          }
        } else if (a === b.Physics.MATTERJS) {
          if (null === this.matter) {
            this.matter = new b.Physics.Matter(this.game, this.config);
          } else {
            this.matter.reset();
          }
        }
      },
      enable: function (a, c, d) {
        if (undefined === c) {
          c = b.Physics.ARCADE;
        }
        if (undefined === d) {
          d = false;
        }
        if (c === b.Physics.ARCADE) {
          this.arcade.enable(a);
        } else if (c === b.Physics.P2JS && this.p2) {
          this.p2.enable(a, d);
        } else if (c === b.Physics.NINJA && this.ninja) {
          this.ninja.enableAABB(a);
        } else if (c === b.Physics.BOX2D && this.box2d) {
          this.box2d.enable(a);
        } else if (c === b.Physics.MATTERJS && this.matter) {
          this.matter.enable(a);
        } else {
          console.warn(a.key + " is attempting to enable a physics body using an unknown physics system.");
        }
      },
      preUpdate: function () {
        if (this.p2) {
          this.p2.preUpdate();
        }
        if (this.box2d) {
          this.box2d.preUpdate();
        }
        if (this.matter) {
          this.matter.preUpdate();
        }
      },
      update: function () {
        if (this.p2) {
          this.p2.update();
        }
        if (this.box2d) {
          this.box2d.update();
        }
        if (this.matter) {
          this.matter.update();
        }
      },
      setBoundsToWorld: function () {
        if (this.arcade) {
          this.arcade.setBoundsToWorld();
        }
        if (this.ninja) {
          this.ninja.setBoundsToWorld();
        }
        if (this.p2) {
          this.p2.setBoundsToWorld();
        }
        if (this.box2d) {
          this.box2d.setBoundsToWorld();
        }
        if (this.matter) {
          this.matter.setBoundsToWorld();
        }
      },
      clear: function () {
        if (this.p2) {
          this.p2.clear();
        }
        if (this.box2d) {
          this.box2d.clear();
        }
        if (this.matter) {
          this.matter.clear();
        }
      },
      reset: function () {
        if (this.p2) {
          this.p2.reset();
        }
        if (this.box2d) {
          this.box2d.reset();
        }
        if (this.matter) {
          this.matter.reset();
        }
      },
      destroy: function () {
        if (this.p2) {
          this.p2.destroy();
        }
        if (this.box2d) {
          this.box2d.destroy();
        }
        if (this.matter) {
          this.matter.destroy();
        }
        this.arcade = null;
        this.ninja = null;
        this.p2 = null;
        this.box2d = null;
        this.matter = null;
      }
    };
    b.Physics.prototype.constructor = b.Physics;
    b.Physics.Arcade = function (a) {
      this.game = a;
      this.gravity = new b.Point();
      this.bounds = new b.Rectangle(0, 0, a.world.width, a.world.height);
      this.checkCollision = {
        up: true,
        down: true,
        left: true,
        right: true
      };
      this.maxObjects = 10;
      this.maxLevels = 4;
      this.OVERLAP_BIAS = 4;
      this.forceX = false;
      this.sortDirection = b.Physics.Arcade.LEFT_RIGHT;
      this.skipQuadTree = true;
      this.isPaused = false;
      this.quadTree = new b.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
      this._total = 0;
      this.setBoundsToWorld();
    };
    b.Physics.Arcade.prototype.constructor = b.Physics.Arcade;
    b.Physics.Arcade.SORT_NONE = 0;
    b.Physics.Arcade.LEFT_RIGHT = 1;
    b.Physics.Arcade.RIGHT_LEFT = 2;
    b.Physics.Arcade.TOP_BOTTOM = 3;
    b.Physics.Arcade.BOTTOM_TOP = 4;
    b.Physics.Arcade.prototype = {
      setBounds: function (a, b, c, d) {
        this.bounds.setTo(a, b, c, d);
      },
      setBoundsToWorld: function () {
        this.bounds.copyFrom(this.game.world.bounds);
      },
      enable: function (a, c) {
        if (undefined === c) {
          c = true;
        }
        var d = 1;
        if (Array.isArray(a)) {
          for (d = a.length; d--;) {
            if (a[d] instanceof b.Group) {
              this.enable(a[d].children, c);
            } else {
              this.enableBody(a[d]);
              if (c && a[d].hasOwnProperty("children") && a[d].children.length > 0) {
                this.enable(a[d], true);
              }
            }
          }
        } else if (a instanceof b.Group) {
          this.enable(a.children, c);
        } else {
          this.enableBody(a);
          if (c && a.hasOwnProperty("children") && a.children.length > 0) {
            this.enable(a.children, true);
          }
        }
      },
      enableBody: function (a) {
        if (a.hasOwnProperty("body") && null === a.body) {
          a.body = new b.Physics.Arcade.Body(a);
          if (a.parent && a.parent instanceof b.Group) {
            a.parent.addToHash(a);
          }
        }
      },
      updateMotion: function (a) {
        var b = this.computeVelocity(0, a, a.angularVelocity, a.angularAcceleration, a.angularDrag, a.maxAngular) - a.angularVelocity;
        a.angularVelocity += b;
        a.rotation += a.angularVelocity * this.game.time.physicsElapsed;
        a.velocity.x = this.computeVelocity(1, a, a.velocity.x, a.acceleration.x, a.drag.x, a.maxVelocity.x);
        a.velocity.y = this.computeVelocity(2, a, a.velocity.y, a.acceleration.y, a.drag.y, a.maxVelocity.y);
      },
      computeVelocity: function (a, b, c, d, e, f) {
        if (undefined === f) {
          f = 1e4;
        }
        if (1 === a && b.allowGravity) {
          c += (this.gravity.x + b.gravity.x) * this.game.time.physicsElapsed;
        } else if (2 === a && b.allowGravity) {
          c += (this.gravity.y + b.gravity.y) * this.game.time.physicsElapsed;
        }
        if (d) {
          c += d * this.game.time.physicsElapsed;
        } else if (e) {
          e *= this.game.time.physicsElapsed;
          if (c - e > 0) {
            c -= e;
          } else if (c + e < 0) {
            c += e;
          } else {
            c = 0;
          }
        }
        if (c > f) {
          c = f;
        } else if (c < -f) {
          c = -f;
        }
        return c;
      },
      overlap: function (a, b, c, d, e) {
        c = c || null;
        d = d || null;
        e = e || c;
        this._total = 0;
        if (!Array.isArray(a) && Array.isArray(b)) {
          for (var f = 0; f < b.length; f++) {
            this.collideHandler(a, b[f], c, d, e, true);
          }
        } else if (Array.isArray(a) && !Array.isArray(b)) {
          for (var f = 0; f < a.length; f++) {
            this.collideHandler(a[f], b, c, d, e, true);
          }
        } else if (Array.isArray(a) && Array.isArray(b)) {
          for (var f = 0; f < a.length; f++) {
            for (var g = 0; g < b.length; g++) {
              this.collideHandler(a[f], b[g], c, d, e, true);
            }
          }
        } else {
          this.collideHandler(a, b, c, d, e, true);
        }
        return this._total > 0;
      },
      collide: function (a, b, c, d, e) {
        c = c || null;
        d = d || null;
        e = e || c;
        this._total = 0;
        if (!Array.isArray(a) && Array.isArray(b)) {
          for (var f = 0; f < b.length; f++) {
            this.collideHandler(a, b[f], c, d, e, false);
          }
        } else if (Array.isArray(a) && !Array.isArray(b)) {
          for (var f = 0; f < a.length; f++) {
            this.collideHandler(a[f], b, c, d, e, false);
          }
        } else if (Array.isArray(a) && Array.isArray(b)) {
          for (var f = 0; f < a.length; f++) {
            for (var g = 0; g < b.length; g++) {
              this.collideHandler(a[f], b[g], c, d, e, false);
            }
          }
        } else {
          this.collideHandler(a, b, c, d, e, false);
        }
        return this._total > 0;
      },
      sortLeftRight: function (a, b) {
        return a.body && b.body ? a.body.x - b.body.x : 0;
      },
      sortRightLeft: function (a, b) {
        return a.body && b.body ? b.body.x - a.body.x : 0;
      },
      sortTopBottom: function (a, b) {
        return a.body && b.body ? a.body.y - b.body.y : 0;
      },
      sortBottomTop: function (a, b) {
        return a.body && b.body ? b.body.y - a.body.y : 0;
      },
      sort: function (a, c) {
        if (null !== a.physicsSortDirection) {
          c = a.physicsSortDirection;
        } else if (undefined === c) {
          c = this.sortDirection;
        }
        if (c === b.Physics.Arcade.LEFT_RIGHT) {
          a.hash.sort(this.sortLeftRight);
        } else if (c === b.Physics.Arcade.RIGHT_LEFT) {
          a.hash.sort(this.sortRightLeft);
        } else if (c === b.Physics.Arcade.TOP_BOTTOM) {
          a.hash.sort(this.sortTopBottom);
        } else if (c === b.Physics.Arcade.BOTTOM_TOP) {
          a.hash.sort(this.sortBottomTop);
        }
      },
      collideHandler: function (a, c, d, e, f, g) {
        if (undefined === c && a.physicsType === b.GROUP) {
          this.sort(a);
          return void this.collideGroupVsSelf(a, d, e, f, g);
        }
        if (a && c && a.exists && c.exists) {
          if (this.sortDirection !== b.Physics.Arcade.SORT_NONE) {
            if (a.physicsType === b.GROUP) {
              this.sort(a);
            }
            if (c.physicsType === b.GROUP) {
              this.sort(c);
            }
          }
          if (a.physicsType === b.SPRITE) {
            if (c.physicsType === b.SPRITE) {
              this.collideSpriteVsSprite(a, c, d, e, f, g);
            } else if (c.physicsType === b.GROUP) {
              this.collideSpriteVsGroup(a, c, d, e, f, g);
            } else if (c.physicsType === b.TILEMAPLAYER) {
              this.collideSpriteVsTilemapLayer(a, c, d, e, f, g);
            }
          } else if (a.physicsType === b.GROUP) {
            if (c.physicsType === b.SPRITE) {
              this.collideSpriteVsGroup(c, a, d, e, f, g);
            } else if (c.physicsType === b.GROUP) {
              this.collideGroupVsGroup(a, c, d, e, f, g);
            } else if (c.physicsType === b.TILEMAPLAYER) {
              this.collideGroupVsTilemapLayer(a, c, d, e, f, g);
            }
          } else if (a.physicsType === b.TILEMAPLAYER) {
            if (c.physicsType === b.SPRITE) {
              this.collideSpriteVsTilemapLayer(c, a, d, e, f, g);
            } else if (c.physicsType === b.GROUP) {
              this.collideGroupVsTilemapLayer(c, a, d, e, f, g);
            }
          }
        }
      },
      collideSpriteVsSprite: function (a, b, c, d, e, f) {
        return !(!a.body || !b.body) && (this.separate(a.body, b.body, d, e, f) && (c && c.call(e, a, b), this._total++), true);
      },
      collideSpriteVsGroup: function (a, c, d, e, f, g) {
        if (0 !== c.length && a.body) {
          if (this.skipQuadTree || a.body.skipQuadTree) {
            var h = {};
            for (var i = 0; i < c.hash.length; i++) {
              var j = c.hash[i];
              if (j && j.exists && j.body) {
                h = j.body.getBounds(h);
                if (this.sortDirection === b.Physics.Arcade.LEFT_RIGHT) {
                  if (a.body.right < h.x) {
                    break;
                  }
                  if (h.right < a.body.x) {
                    continue;
                  }
                } else if (this.sortDirection === b.Physics.Arcade.RIGHT_LEFT) {
                  if (a.body.x > h.right) {
                    break;
                  }
                  if (h.x > a.body.right) {
                    continue;
                  }
                } else if (this.sortDirection === b.Physics.Arcade.TOP_BOTTOM) {
                  if (a.body.bottom < h.y) {
                    break;
                  }
                  if (h.bottom < a.body.y) {
                    continue;
                  }
                } else if (this.sortDirection === b.Physics.Arcade.BOTTOM_TOP) {
                  if (a.body.y > h.bottom) {
                    break;
                  }
                  if (h.y > a.body.bottom) {
                    continue;
                  }
                }
                this.collideSpriteVsSprite(a, j, d, e, f, g);
              }
            }
          } else {
            this.quadTree.clear();
            this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
            this.quadTree.populate(c);
            var k = this.quadTree.retrieve(a);
            for (var i = 0; i < k.length; i++) {
              if (this.separate(a.body, k[i], e, f, g)) {
                if (d) {
                  d.call(f, a, k[i].sprite);
                }
                this._total++;
              }
            }
          }
        }
      },
      collideGroupVsSelf: function (a, c, d, e, f) {
        if (0 !== a.length) {
          for (var g = 0; g < a.hash.length; g++) {
            var h = {};
            var i = a.hash[g];
            if (i && i.exists && i.body) {
              h = i.body.getBounds(h);
              for (var j = g + 1; j < a.hash.length; j++) {
                var k = {};
                var l = a.hash[j];
                if (l && l.exists && l.body) {
                  k = l.body.getBounds(k);
                  if (this.sortDirection === b.Physics.Arcade.LEFT_RIGHT) {
                    if (h.right < k.x) {
                      break;
                    }
                    if (k.right < h.x) {
                      continue;
                    }
                  } else if (this.sortDirection === b.Physics.Arcade.RIGHT_LEFT) {
                    if (h.x > k.right) {
                      continue;
                    }
                    if (k.x > h.right) {
                      break;
                    }
                  } else if (this.sortDirection === b.Physics.Arcade.TOP_BOTTOM) {
                    if (h.bottom < k.y) {
                      continue;
                    }
                    if (k.bottom < h.y) {
                      break;
                    }
                  } else if (this.sortDirection === b.Physics.Arcade.BOTTOM_TOP) {
                    if (h.y > k.bottom) {
                      continue;
                    }
                    if (k.y > i.body.bottom) {
                      break;
                    }
                  }
                  this.collideSpriteVsSprite(i, l, c, d, e, f);
                }
              }
            }
          }
        }
      },
      collideGroupVsGroup: function (a, c, d, e, f, g) {
        if (0 !== a.length && 0 !== c.length) {
          for (var h = 0; h < a.children.length; h++) {
            if (a.children[h].exists) {
              if (a.children[h].physicsType === b.GROUP) {
                this.collideGroupVsGroup(a.children[h], c, d, e, f, g);
              } else {
                this.collideSpriteVsGroup(a.children[h], c, d, e, f, g);
              }
            }
          }
        }
      },
      separate: function (a, b, c, d, e) {
        if (!a.enable || !b.enable || a.checkCollision.none || b.checkCollision.none || !this.intersects(a, b)) {
          return false;
        }
        if (c && false === c.call(d, a.sprite, b.sprite)) {
          return false;
        }
        if (a.isCircle && b.isCircle) {
          return this.separateCircle(a, b, e);
        }
        if (a.isCircle !== b.isCircle) {
          var f = a.isCircle ? b : a;
          var g = a.isCircle ? a : b;
          var h = {
            x: f.x,
            y: f.y,
            right: f.right,
            bottom: f.bottom
          };
          var i = {
            x: g.x + g.radius,
            y: g.y + g.radius
          };
          if ((i.y < h.y || i.y > h.bottom) && (i.x < h.x || i.x > h.right)) {
            return this.separateCircle(a, b, e);
          }
        }
        var j = false;
        var k = false;
        if (this.forceX || Math.abs(this.gravity.y + a.gravity.y) < Math.abs(this.gravity.x + a.gravity.x)) {
          j = this.separateX(a, b, e);
          if (this.intersects(a, b)) {
            k = this.separateY(a, b, e);
          }
        } else {
          k = this.separateY(a, b, e);
          if (this.intersects(a, b)) {
            j = this.separateX(a, b, e);
          }
        }
        var l = j || k;
        if (l) {
          if (e) {
            if (a.onOverlap) {
              a.onOverlap.dispatch(a.sprite, b.sprite);
            }
            if (b.onOverlap) {
              b.onOverlap.dispatch(b.sprite, a.sprite);
            }
          } else {
            if (a.onCollide) {
              a.onCollide.dispatch(a.sprite, b.sprite);
            }
            if (b.onCollide) {
              b.onCollide.dispatch(b.sprite, a.sprite);
            }
          }
        }
        return l;
      },
      intersects: function (a, c) {
        return a !== c && (a.isCircle ? c.isCircle ? b.Math.distance(a.center.x, a.center.y, c.center.x, c.center.y) <= a.radius + c.radius : this.circleBodyIntersects(a, c) : c.isCircle ? this.circleBodyIntersects(c, a) : !(a.right <= c.position.x) && !(a.bottom <= c.position.y) && !(a.position.x >= c.right) && !(a.position.y >= c.bottom));
      },
      circleBodyIntersects: function (a, c) {
        var d = b.Math.clamp(a.center.x, c.left, c.right);
        var e = b.Math.clamp(a.center.y, c.top, c.bottom);
        return (a.center.x - d) * (a.center.x - d) + (a.center.y - e) * (a.center.y - e) <= a.radius * a.radius;
      },
      separateCircle: function (a, c, d) {
        this.getOverlapX(a, c);
        this.getOverlapY(a, c);
        var e = c.center.x - a.center.x;
        var f = c.center.y - a.center.y;
        var g = Math.atan2(f, e);
        var h = 0;
        if (a.isCircle !== c.isCircle) {
          var i = {
            x: c.isCircle ? a.position.x : c.position.x,
            y: c.isCircle ? a.position.y : c.position.y,
            right: c.isCircle ? a.right : c.right,
            bottom: c.isCircle ? a.bottom : c.bottom
          };
          var j = {
            x: a.isCircle ? a.position.x + a.radius : c.position.x + c.radius,
            y: a.isCircle ? a.position.y + a.radius : c.position.y + c.radius,
            radius: a.isCircle ? a.radius : c.radius
          };
          if (j.y < i.y) {
            if (j.x < i.x) {
              h = b.Math.distance(j.x, j.y, i.x, i.y) - j.radius;
            } else if (j.x > i.right) {
              h = b.Math.distance(j.x, j.y, i.right, i.y) - j.radius;
            }
          } else if (j.y > i.bottom) {
            if (j.x < i.x) {
              h = b.Math.distance(j.x, j.y, i.x, i.bottom) - j.radius;
            } else if (j.x > i.right) {
              h = b.Math.distance(j.x, j.y, i.right, i.bottom) - j.radius;
            }
          }
          h *= -1;
        } else {
          h = a.radius + c.radius - b.Math.distance(a.center.x, a.center.y, c.center.x, c.center.y);
        }
        if (d || 0 === h || a.immovable && c.immovable || a.customSeparateX || c.customSeparateX) {
          if (0 !== h) {
            if (a.onOverlap) {
              a.onOverlap.dispatch(a.sprite, c.sprite);
            }
            if (c.onOverlap) {
              c.onOverlap.dispatch(c.sprite, a.sprite);
            }
          }
          return 0 !== h;
        }
        var k = {
          x: a.velocity.x * Math.cos(g) + a.velocity.y * Math.sin(g),
          y: a.velocity.x * Math.sin(g) - a.velocity.y * Math.cos(g)
        };
        var l = {
          x: c.velocity.x * Math.cos(g) + c.velocity.y * Math.sin(g),
          y: c.velocity.x * Math.sin(g) - c.velocity.y * Math.cos(g)
        };
        var m = ((a.mass - c.mass) * k.x + 2 * c.mass * l.x) / (a.mass + c.mass);
        var n = (2 * a.mass * k.x + (c.mass - a.mass) * l.x) / (a.mass + c.mass);
        if (!a.immovable) {
          a.velocity.x = (m * Math.cos(g) - k.y * Math.sin(g)) * a.bounce.x;
          a.velocity.y = (k.y * Math.cos(g) + m * Math.sin(g)) * a.bounce.y;
        }
        if (!c.immovable) {
          c.velocity.x = (n * Math.cos(g) - l.y * Math.sin(g)) * c.bounce.x;
          c.velocity.y = (l.y * Math.cos(g) + n * Math.sin(g)) * c.bounce.y;
        }
        if (Math.abs(g) < Math.PI / 2) {
          if (a.velocity.x > 0 && !a.immovable && c.velocity.x > a.velocity.x) {
            a.velocity.x *= -1;
          } else if (c.velocity.x < 0 && !c.immovable && a.velocity.x < c.velocity.x) {
            c.velocity.x *= -1;
          } else if (a.velocity.y > 0 && !a.immovable && c.velocity.y > a.velocity.y) {
            a.velocity.y *= -1;
          } else if (c.velocity.y < 0 && !c.immovable && a.velocity.y < c.velocity.y) {
            c.velocity.y *= -1;
          }
        } else if (Math.abs(g) > Math.PI / 2) {
          if (a.velocity.x < 0 && !a.immovable && c.velocity.x < a.velocity.x) {
            a.velocity.x *= -1;
          } else if (c.velocity.x > 0 && !c.immovable && a.velocity.x > c.velocity.x) {
            c.velocity.x *= -1;
          } else if (a.velocity.y < 0 && !a.immovable && c.velocity.y < a.velocity.y) {
            a.velocity.y *= -1;
          } else if (c.velocity.y > 0 && !c.immovable && a.velocity.x > c.velocity.y) {
            c.velocity.y *= -1;
          }
        }
        if (!a.immovable) {
          a.x += a.velocity.x * this.game.time.physicsElapsed - h * Math.cos(g);
          a.y += a.velocity.y * this.game.time.physicsElapsed - h * Math.sin(g);
        }
        if (!c.immovable) {
          c.x += c.velocity.x * this.game.time.physicsElapsed + h * Math.cos(g);
          c.y += c.velocity.y * this.game.time.physicsElapsed + h * Math.sin(g);
        }
        if (a.onCollide) {
          a.onCollide.dispatch(a.sprite, c.sprite);
        }
        if (c.onCollide) {
          c.onCollide.dispatch(c.sprite, a.sprite);
        }
        return true;
      },
      getOverlapX: function (a, b, c) {
        var d = 0;
        var e = a.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
        if (0 === a.deltaX() && 0 === b.deltaX()) {
          a.embedded = true;
          b.embedded = true;
        } else if (a.deltaX() > b.deltaX()) {
          d = a.right - b.x;
          if (d > e && !c || false === a.checkCollision.right || false === b.checkCollision.left) {
            d = 0;
          } else {
            a.touching.none = false;
            a.touching.right = true;
            b.touching.none = false;
            b.touching.left = true;
          }
        } else if (a.deltaX() < b.deltaX()) {
          d = a.x - b.width - b.x;
          if (-d > e && !c || false === a.checkCollision.left || false === b.checkCollision.right) {
            d = 0;
          } else {
            a.touching.none = false;
            a.touching.left = true;
            b.touching.none = false;
            b.touching.right = true;
          }
        }
        a.overlapX = d;
        b.overlapX = d;
        return d;
      },
      getOverlapY: function (a, b, c) {
        var d = 0;
        var e = a.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
        if (0 === a.deltaY() && 0 === b.deltaY()) {
          a.embedded = true;
          b.embedded = true;
        } else if (a.deltaY() > b.deltaY()) {
          d = a.bottom - b.y;
          if (d > e && !c || false === a.checkCollision.down || false === b.checkCollision.up) {
            d = 0;
          } else {
            a.touching.none = false;
            a.touching.down = true;
            b.touching.none = false;
            b.touching.up = true;
          }
        } else if (a.deltaY() < b.deltaY()) {
          d = a.y - b.bottom;
          if (-d > e && !c || false === a.checkCollision.up || false === b.checkCollision.down) {
            d = 0;
          } else {
            a.touching.none = false;
            a.touching.up = true;
            b.touching.none = false;
            b.touching.down = true;
          }
        }
        a.overlapY = d;
        b.overlapY = d;
        return d;
      },
      separateX: function (a, b, c) {
        var d = this.getOverlapX(a, b, c);
        if (c || 0 === d || a.immovable && b.immovable || a.customSeparateX || b.customSeparateX) {
          return 0 !== d || a.embedded && b.embedded;
        }
        var e = a.velocity.x;
        var f = b.velocity.x;
        if (a.immovable || b.immovable) {
          if (a.immovable) {
            b.x += d;
            b.velocity.x = e - f * b.bounce.x;
            if (a.moves) {
              b.y += (a.y - a.prev.y) * a.friction.y;
            }
          } else {
            a.x -= d;
            a.velocity.x = f - e * a.bounce.x;
            if (b.moves) {
              a.y += (b.y - b.prev.y) * b.friction.y;
            }
          }
        } else {
          d *= .5;
          a.x -= d;
          b.x += d;
          var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1);
          var h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1);
          var i = .5 * (g + h);
          g -= i;
          h -= i;
          a.velocity.x = i + g * a.bounce.x;
          b.velocity.x = i + h * b.bounce.x;
        }
        return true;
      },
      separateY: function (a, b, c) {
        var d = this.getOverlapY(a, b, c);
        if (c || 0 === d || a.immovable && b.immovable || a.customSeparateY || b.customSeparateY) {
          return 0 !== d || a.embedded && b.embedded;
        }
        var e = a.velocity.y;
        var f = b.velocity.y;
        if (a.immovable || b.immovable) {
          if (a.immovable) {
            b.y += d;
            b.velocity.y = e - f * b.bounce.y;
            if (a.moves) {
              b.x += (a.x - a.prev.x) * a.friction.x;
            }
          } else {
            a.y -= d;
            a.velocity.y = f - e * a.bounce.y;
            if (b.moves) {
              a.x += (b.x - b.prev.x) * b.friction.x;
            }
          }
        } else {
          d *= .5;
          a.y -= d;
          b.y += d;
          var g = Math.sqrt(f * f * b.mass / a.mass) * (f > 0 ? 1 : -1);
          var h = Math.sqrt(e * e * a.mass / b.mass) * (e > 0 ? 1 : -1);
          var i = .5 * (g + h);
          g -= i;
          h -= i;
          a.velocity.y = i + g * a.bounce.y;
          b.velocity.y = i + h * b.bounce.y;
        }
        return true;
      },
      getObjectsUnderPointer: function (a, b, c, d) {
        if (0 !== b.length && a.exists) {
          return this.getObjectsAtLocation(a.x, a.y, b, c, d, a);
        }
      },
      getObjectsAtLocation: function (a, c, d, e, f, g) {
        this.quadTree.clear();
        this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this.quadTree.populate(d);
        var h = new b.Rectangle(a, c, 1, 1);
        var i = [];
        var j = this.quadTree.retrieve(h);
        for (var k = 0; k < j.length; k++) {
          if (j[k].hitTest(a, c)) {
            if (e) {
              e.call(f, g, j[k].sprite);
            }
            i.push(j[k].sprite);
          }
        }
        return i;
      },
      moveToObject: function (a, b, c, d) {
        if (undefined === c) {
          c = 60;
        }
        if (undefined === d) {
          d = 0;
        }
        var e = Math.atan2(b.y - a.y, b.x - a.x);
        if (d > 0) {
          c = this.distanceBetween(a, b) / (d / 1e3);
        }
        a.body.velocity.x = Math.cos(e) * c;
        a.body.velocity.y = Math.sin(e) * c;
        return e;
      },
      moveToPointer: function (a, b, c, d) {
        if (undefined === b) {
          b = 60;
        }
        c = c || this.game.input.activePointer;
        if (undefined === d) {
          d = 0;
        }
        var e = this.angleToPointer(a, c);
        if (d > 0) {
          b = this.distanceToPointer(a, c) / (d / 1e3);
        }
        a.body.velocity.x = Math.cos(e) * b;
        a.body.velocity.y = Math.sin(e) * b;
        return e;
      },
      moveToXY: function (a, b, c, d, e) {
        if (undefined === d) {
          d = 60;
        }
        if (undefined === e) {
          e = 0;
        }
        var f = Math.atan2(c - a.y, b - a.x);
        if (e > 0) {
          d = this.distanceToXY(a, b, c) / (e / 1e3);
        }
        a.body.velocity.x = Math.cos(f) * d;
        a.body.velocity.y = Math.sin(f) * d;
        return f;
      },
      velocityFromAngle: function (a, c, d) {
        if (undefined === c) {
          c = 60;
        }
        d = d || new b.Point();
        return d.setTo(Math.cos(this.game.math.degToRad(a)) * c, Math.sin(this.game.math.degToRad(a)) * c);
      },
      velocityFromRotation: function (a, c, d) {
        if (undefined === c) {
          c = 60;
        }
        d = d || new b.Point();
        return d.setTo(Math.cos(a) * c, Math.sin(a) * c);
      },
      accelerationFromRotation: function (a, c, d) {
        if (undefined === c) {
          c = 60;
        }
        d = d || new b.Point();
        return d.setTo(Math.cos(a) * c, Math.sin(a) * c);
      },
      accelerateToObject: function (a, b, c, d, e) {
        if (undefined === c) {
          c = 60;
        }
        if (undefined === d) {
          d = 1e3;
        }
        if (undefined === e) {
          e = 1e3;
        }
        var f = this.angleBetween(a, b);
        a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c);
        a.body.maxVelocity.setTo(d, e);
        return f;
      },
      accelerateToPointer: function (a, b, c, d, e) {
        if (undefined === c) {
          c = 60;
        }
        if (undefined === b) {
          b = this.game.input.activePointer;
        }
        if (undefined === d) {
          d = 1e3;
        }
        if (undefined === e) {
          e = 1e3;
        }
        var f = this.angleToPointer(a, b);
        a.body.acceleration.setTo(Math.cos(f) * c, Math.sin(f) * c);
        a.body.maxVelocity.setTo(d, e);
        return f;
      },
      accelerateToXY: function (a, b, c, d, e, f) {
        if (undefined === d) {
          d = 60;
        }
        if (undefined === e) {
          e = 1e3;
        }
        if (undefined === f) {
          f = 1e3;
        }
        var g = this.angleToXY(a, b, c);
        a.body.acceleration.setTo(Math.cos(g) * d, Math.sin(g) * d);
        a.body.maxVelocity.setTo(e, f);
        return g;
      },
      distanceBetween: function (a, b, c) {
        if (undefined === c) {
          c = false;
        }
        var d = c ? a.world.x - b.world.x : a.x - b.x;
        var e = c ? a.world.y - b.world.y : a.y - b.y;
        return Math.sqrt(d * d + e * e);
      },
      distanceToXY: function (a, b, c, d) {
        if (undefined === d) {
          d = false;
        }
        var e = d ? a.world.x - b : a.x - b;
        var f = d ? a.world.y - c : a.y - c;
        return Math.sqrt(e * e + f * f);
      },
      distanceToPointer: function (a, b, c) {
        if (undefined === b) {
          b = this.game.input.activePointer;
        }
        if (undefined === c) {
          c = false;
        }
        var d = c ? a.world.x - b.worldX : a.x - b.worldX;
        var e = c ? a.world.y - b.worldY : a.y - b.worldY;
        return Math.sqrt(d * d + e * e);
      },
      angleBetween: function (a, b, c) {
        if (undefined === c) {
          c = false;
        }
        return c ? Math.atan2(b.world.y - a.world.y, b.world.x - a.world.x) : Math.atan2(b.y - a.y, b.x - a.x);
      },
      angleBetweenCenters: function (a, b) {
        var c = b.centerX - a.centerX;
        var d = b.centerY - a.centerY;
        return Math.atan2(d, c);
      },
      angleToXY: function (a, b, c, d) {
        if (undefined === d) {
          d = false;
        }
        return d ? Math.atan2(c - a.world.y, b - a.world.x) : Math.atan2(c - a.y, b - a.x);
      },
      angleToPointer: function (a, b, c) {
        if (undefined === b) {
          b = this.game.input.activePointer;
        }
        if (undefined === c) {
          c = false;
        }
        return c ? Math.atan2(b.worldY - a.world.y, b.worldX - a.world.x) : Math.atan2(b.worldY - a.y, b.worldX - a.x);
      },
      worldAngleToPointer: function (a, b) {
        return this.angleToPointer(a, b, true);
      }
    };
    b.Physics.Arcade.Body = function (a) {
      this.sprite = a;
      this.game = a.game;
      this.type = b.Physics.ARCADE;
      this.enable = true;
      this.isCircle = false;
      this.radius = 0;
      this.offset = new b.Point();
      this.position = new b.Point(a.x, a.y);
      this.prev = new b.Point(this.position.x, this.position.y);
      this.allowRotation = true;
      this.rotation = a.angle;
      this.preRotation = a.angle;
      this.width = a.width;
      this.height = a.height;
      this.sourceWidth = a.width;
      this.sourceHeight = a.height;
      if (a.texture) {
        this.sourceWidth = a.texture.frame.width;
        this.sourceHeight = a.texture.frame.height;
      }
      this.halfWidth = Math.abs(a.width / 2);
      this.halfHeight = Math.abs(a.height / 2);
      this.center = new b.Point(a.x + this.halfWidth, a.y + this.halfHeight);
      this.velocity = new b.Point();
      this.newVelocity = new b.Point();
      this.deltaMax = new b.Point();
      this.acceleration = new b.Point();
      this.drag = new b.Point();
      this.allowGravity = true;
      this.gravity = new b.Point();
      this.bounce = new b.Point();
      this.worldBounce = null;
      this.onWorldBounds = null;
      this.onCollide = null;
      this.onOverlap = null;
      this.maxVelocity = new b.Point(1e4, 1e4);
      this.friction = new b.Point(1, 0);
      this.angularVelocity = 0;
      this.angularAcceleration = 0;
      this.angularDrag = 0;
      this.maxAngular = 1e3;
      this.mass = 1;
      this.angle = 0;
      this.speed = 0;
      this.facing = b.NONE;
      this.immovable = false;
      this.moves = true;
      this.customSeparateX = false;
      this.customSeparateY = false;
      this.overlapX = 0;
      this.overlapY = 0;
      this.overlapR = 0;
      this.embedded = false;
      this.collideWorldBounds = false;
      this.checkCollision = {
        none: false,
        any: true,
        up: true,
        down: true,
        left: true,
        right: true
      };
      this.touching = {
        none: true,
        up: false,
        down: false,
        left: false,
        right: false
      };
      this.wasTouching = {
        none: true,
        up: false,
        down: false,
        left: false,
        right: false
      };
      this.blocked = {
        up: false,
        down: false,
        left: false,
        right: false
      };
      this.tilePadding = new b.Point();
      this.dirty = false;
      this.skipQuadTree = false;
      this.syncBounds = false;
      this.isMoving = false;
      this.stopVelocityOnCollide = true;
      this.moveTimer = 0;
      this.moveDistance = 0;
      this.moveDuration = 0;
      this.moveTarget = null;
      this.moveEnd = null;
      this.onMoveComplete = new b.Signal();
      this.movementCallback = null;
      this.movementCallbackContext = null;
      this._reset = true;
      this._sx = a.scale.x;
      this._sy = a.scale.y;
      this._dx = 0;
      this._dy = 0;
    };
    b.Physics.Arcade.Body.prototype = {
      updateBounds: function () {
        if (this.syncBounds) {
          var a = this.sprite.getBounds();
          a.ceilAll();
          if (!(a.width === this.width && a.height === this.height)) {
            this.width = a.width;
            this.height = a.height;
            this._reset = true;
          }
        } else {
          var b = Math.abs(this.sprite.scale.x);
          var c = Math.abs(this.sprite.scale.y);
          if (!(b === this._sx && c === this._sy)) {
            this.width = this.sourceWidth * b;
            this.height = this.sourceHeight * c;
            this._sx = b;
            this._sy = c;
            this._reset = true;
          }
        }
        if (this._reset) {
          this.halfWidth = Math.floor(this.width / 2);
          this.halfHeight = Math.floor(this.height / 2);
          this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        }
      },
      preUpdate: function () {
        if (this.enable && !this.game.physics.arcade.isPaused) {
          this.dirty = true;
          this.wasTouching.none = this.touching.none;
          this.wasTouching.up = this.touching.up;
          this.wasTouching.down = this.touching.down;
          this.wasTouching.left = this.touching.left;
          this.wasTouching.right = this.touching.right;
          this.touching.none = true;
          this.touching.up = false;
          this.touching.down = false;
          this.touching.left = false;
          this.touching.right = false;
          this.blocked.up = false;
          this.blocked.down = false;
          this.blocked.left = false;
          this.blocked.right = false;
          this.embedded = false;
          this.updateBounds();
          this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x;
          this.position.x -= this.sprite.scale.x < 0 ? this.width : 0;
          this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y;
          this.position.y -= this.sprite.scale.y < 0 ? this.height : 0;
          this.rotation = this.sprite.angle;
          this.preRotation = this.rotation;
          if (this._reset || this.sprite.fresh) {
            this.prev.x = this.position.x;
            this.prev.y = this.position.y;
          }
          if (this.moves) {
            this.game.physics.arcade.updateMotion(this);
            this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);
            this.position.x += this.newVelocity.x;
            this.position.y += this.newVelocity.y;
            if (!(this.position.x === this.prev.x && this.position.y === this.prev.y)) {
              this.angle = Math.atan2(this.velocity.y, this.velocity.x);
            }
            this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {
              this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);
            }
          }
          this._dx = this.deltaX();
          this._dy = this.deltaY();
          this._reset = false;
        }
      },
      updateMovement: function () {
        var a = 0;
        var b = 0 !== this.overlapX || 0 !== this.overlapY;
        if (this.moveDuration > 0) {
          this.moveTimer += this.game.time.elapsedMS;
          a = this.moveTimer / this.moveDuration;
        } else {
          this.moveTarget.end.set(this.position.x, this.position.y);
          a = this.moveTarget.length / this.moveDistance;
        }
        if (this.movementCallback) {
          var c = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, a);
        }
        return !(b || a >= 1 || undefined !== c && true !== c) || (this.stopMovement(a >= 1 || this.stopVelocityOnCollide && b), false);
      },
      stopMovement: function (a) {
        if (this.isMoving) {
          this.isMoving = false;
          if (a) {
            this.velocity.set(0);
          }
          this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY);
        }
      },
      postUpdate: function () {
        if (this.enable && this.dirty) {
          if (this.isMoving) {
            this.updateMovement();
          }
          this.dirty = false;
          if (this.deltaX() < 0) {
            this.facing = b.LEFT;
          } else if (this.deltaX() > 0) {
            this.facing = b.RIGHT;
          }
          if (this.deltaY() < 0) {
            this.facing = b.UP;
          } else if (this.deltaY() > 0) {
            this.facing = b.DOWN;
          }
          if (this.moves) {
            this._dx = this.deltaX();
            this._dy = this.deltaY();
            if (0 !== this.deltaMax.x && 0 !== this._dx) {
              if (this._dx < 0 && this._dx < -this.deltaMax.x) {
                this._dx = -this.deltaMax.x;
              } else if (this._dx > 0 && this._dx > this.deltaMax.x) {
                this._dx = this.deltaMax.x;
              }
            }
            if (0 !== this.deltaMax.y && 0 !== this._dy) {
              if (this._dy < 0 && this._dy < -this.deltaMax.y) {
                this._dy = -this.deltaMax.y;
              } else if (this._dy > 0 && this._dy > this.deltaMax.y) {
                this._dy = this.deltaMax.y;
              }
            }
            this.sprite.position.x += this._dx;
            this.sprite.position.y += this._dy;
            this._reset = true;
          }
          this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
          if (this.allowRotation) {
            this.sprite.angle += this.deltaZ();
          }
          this.prev.x = this.position.x;
          this.prev.y = this.position.y;
        }
      },
      checkWorldBounds: function () {
        var a = this.position;
        var b = this.game.physics.arcade.bounds;
        var c = this.game.physics.arcade.checkCollision;
        var d = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;
        var e = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
        if (this.isCircle) {
          var f = {
            x: this.center.x - this.radius,
            y: this.center.y - this.radius,
            right: this.center.x + this.radius,
            bottom: this.center.y + this.radius
          };
          if (f.x < b.x && c.left) {
            a.x = b.x - this.halfWidth + this.radius;
            this.velocity.x *= d;
            this.blocked.left = true;
          } else if (f.right > b.right && c.right) {
            a.x = b.right - this.halfWidth - this.radius;
            this.velocity.x *= d;
            this.blocked.right = true;
          }
          if (f.y < b.y && c.up) {
            a.y = b.y - this.halfHeight + this.radius;
            this.velocity.y *= e;
            this.blocked.up = true;
          } else if (f.bottom > b.bottom && c.down) {
            a.y = b.bottom - this.halfHeight - this.radius;
            this.velocity.y *= e;
            this.blocked.down = true;
          }
        } else {
          if (a.x < b.x && c.left) {
            a.x = b.x;
            this.velocity.x *= d;
            this.blocked.left = true;
          } else if (this.right > b.right && c.right) {
            a.x = b.right - this.width;
            this.velocity.x *= d;
            this.blocked.right = true;
          }
          if (a.y < b.y && c.up) {
            a.y = b.y;
            this.velocity.y *= e;
            this.blocked.up = true;
          } else if (this.bottom > b.bottom && c.down) {
            a.y = b.bottom - this.height;
            this.velocity.y *= e;
            this.blocked.down = true;
          }
        }
        return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right;
      },
      moveFrom: function (a, b, c) {
        if (undefined === b) {
          b = this.speed;
        }
        if (0 === b) {
          return false;
        }
        var d;
        if (undefined === c) {
          d = this.angle;
          c = this.game.math.radToDeg(d);
        } else {
          d = this.game.math.degToRad(c);
        }
        this.moveTimer = 0;
        this.moveDuration = a;
        if (0 === c || 180 === c) {
          this.velocity.set(Math.cos(d) * b, 0);
        } else if (90 === c || 270 === c) {
          this.velocity.set(0, Math.sin(d) * b);
        } else {
          this.velocity.set(Math.cos(d) * b, Math.sin(d) * b);
        }
        this.isMoving = true;
        return true;
      },
      moveTo: function (a, c, d) {
        var e = c / (a / 1e3);
        if (0 === e) {
          return false;
        }
        var f;
        if (undefined === d) {
          f = this.angle;
          d = this.game.math.radToDeg(f);
        } else {
          f = this.game.math.degToRad(d);
        }
        c = Math.abs(c);
        this.moveDuration = 0;
        this.moveDistance = c;
        if (null === this.moveTarget) {
          this.moveTarget = new b.Line();
          this.moveEnd = new b.Point();
        }
        this.moveTarget.fromAngle(this.x, this.y, f, c);
        this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y);
        this.moveTarget.setTo(this.x, this.y, this.x, this.y);
        if (0 === d || 180 === d) {
          this.velocity.set(Math.cos(f) * e, 0);
        } else if (90 === d || 270 === d) {
          this.velocity.set(0, Math.sin(f) * e);
        } else {
          this.velocity.set(Math.cos(f) * e, Math.sin(f) * e);
        }
        this.isMoving = true;
        return true;
      },
      setSize: function (a, b, c, d) {
        if (undefined === c) {
          c = this.offset.x;
        }
        if (undefined === d) {
          d = this.offset.y;
        }
        this.sourceWidth = a;
        this.sourceHeight = b;
        this.width = this.sourceWidth * this._sx;
        this.height = this.sourceHeight * this._sy;
        this.halfWidth = Math.floor(this.width / 2);
        this.halfHeight = Math.floor(this.height / 2);
        this.offset.setTo(c, d);
        this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        this.isCircle = false;
        this.radius = 0;
      },
      setCircle: function (a, b, c) {
        if (undefined === b) {
          b = this.offset.x;
        }
        if (undefined === c) {
          c = this.offset.y;
        }
        if (a > 0) {
          this.isCircle = true;
          this.radius = a;
          this.sourceWidth = 2 * a;
          this.sourceHeight = 2 * a;
          this.width = this.sourceWidth * this._sx;
          this.height = this.sourceHeight * this._sy;
          this.halfWidth = Math.floor(this.width / 2);
          this.halfHeight = Math.floor(this.height / 2);
          this.offset.setTo(b, c);
          this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
        } else {
          this.isCircle = false;
        }
      },
      reset: function (a, b) {
        this.velocity.set(0);
        this.acceleration.set(0);
        this.speed = 0;
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.position.x = a - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x;
        this.position.x -= this.sprite.scale.x < 0 ? this.width : 0;
        this.position.y = b - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y;
        this.position.y -= this.sprite.scale.y < 0 ? this.height : 0;
        this.prev.x = this.position.x;
        this.prev.y = this.position.y;
        this.rotation = this.sprite.angle;
        this.preRotation = this.rotation;
        this._sx = this.sprite.scale.x;
        this._sy = this.sprite.scale.y;
        this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);
      },
      getBounds: function (a) {
        if (this.isCircle) {
          a.x = this.center.x - this.radius;
          a.y = this.center.y - this.radius;
          a.right = this.center.x + this.radius;
          a.bottom = this.center.y + this.radius;
        } else {
          a.x = this.x;
          a.y = this.y;
          a.right = this.right;
          a.bottom = this.bottom;
        }
        return a;
      },
      hitTest: function (a, c) {
        return this.isCircle ? b.Circle.contains(this, a, c) : b.Rectangle.contains(this, a, c);
      },
      onFloor: function () {
        return this.blocked.down;
      },
      onCeiling: function () {
        return this.blocked.up;
      },
      onWall: function () {
        return this.blocked.left || this.blocked.right;
      },
      deltaAbsX: function () {
        return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();
      },
      deltaAbsY: function () {
        return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();
      },
      deltaX: function () {
        return this.position.x - this.prev.x;
      },
      deltaY: function () {
        return this.position.y - this.prev.y;
      },
      deltaZ: function () {
        return this.rotation - this.preRotation;
      },
      destroy: function () {
        if (this.sprite.parent && this.sprite.parent instanceof b.Group) {
          this.sprite.parent.removeFromHash(this.sprite);
        }
        this.sprite.body = null;
        this.sprite = null;
      }
    };
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "left", {
      get: function () {
        return this.position.x;
      }
    });
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "right", {
      get: function () {
        return this.position.x + this.width;
      }
    });
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "top", {
      get: function () {
        return this.position.y;
      }
    });
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "bottom", {
      get: function () {
        return this.position.y + this.height;
      }
    });
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "x", {
      get: function () {
        return this.position.x;
      },
      set: function (a) {
        this.position.x = a;
      }
    });
    Object.defineProperty(b.Physics.Arcade.Body.prototype, "y", {
      get: function () {
        return this.position.y;
      },
      set: function (a) {
        this.position.y = a;
      }
    });
    b.Physics.Arcade.Body.render = function (a, b, c, d) {
      if (undefined === d) {
        d = true;
      }
      c = c || "rgba(0,255,0,0.4)";
      a.fillStyle = c;
      a.strokeStyle = c;
      if (b.isCircle) {
        a.beginPath();
        a.arc(b.center.x - b.game.camera.x, b.center.y - b.game.camera.y, b.radius, 0, 2 * Math.PI);
        if (d) {
          a.fill();
        } else {
          a.stroke();
        }
      } else if (d) {
        a.fillRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height);
      } else {
        a.strokeRect(b.position.x - b.game.camera.x, b.position.y - b.game.camera.y, b.width, b.height);
      }
    };
    b.Physics.Arcade.Body.renderBodyInfo = function (a, b) {
      a.line("x: " + b.x.toFixed(2), "y: " + b.y.toFixed(2), "width: " + b.width, "height: " + b.height);
      a.line("velocity x: " + b.velocity.x.toFixed(2), "y: " + b.velocity.y.toFixed(2), "deltaX: " + b._dx.toFixed(2), "deltaY: " + b._dy.toFixed(2));
      a.line("acceleration x: " + b.acceleration.x.toFixed(2), "y: " + b.acceleration.y.toFixed(2), "speed: " + b.speed.toFixed(2), "angle: " + b.angle.toFixed(2));
      a.line("gravity x: " + b.gravity.x, "y: " + b.gravity.y, "bounce x: " + b.bounce.x.toFixed(2), "y: " + b.bounce.y.toFixed(2));
      a.line("touching left: " + b.touching.left, "right: " + b.touching.right, "up: " + b.touching.up, "down: " + b.touching.down);
      a.line("blocked left: " + b.blocked.left, "right: " + b.blocked.right, "up: " + b.blocked.up, "down: " + b.blocked.down);
    };
    b.Physics.Arcade.Body.prototype.constructor = b.Physics.Arcade.Body;
    b.Physics.Arcade.TilemapCollision = function () {};
    b.Physics.Arcade.TilemapCollision.prototype = {
      TILE_BIAS: 16,
      collideSpriteVsTilemapLayer: function (a, b, c, d, e, f) {
        if (a.body) {
          var g = b.getTiles(a.body.position.x - a.body.tilePadding.x, a.body.position.y - a.body.tilePadding.y, a.body.width + a.body.tilePadding.x, a.body.height + a.body.tilePadding.y, false, false);
          if (0 !== g.length) {
            for (var h = 0; h < g.length; h++) {
              if (d) {
                if (d.call(e, a, g[h]) && this.separateTile(h, a.body, g[h], b, f)) {
                  this._total++;
                  if (c) {
                    c.call(e, a, g[h]);
                  }
                }
              } else if (this.separateTile(h, a.body, g[h], b, f)) {
                this._total++;
                if (c) {
                  c.call(e, a, g[h]);
                }
              }
            }
          }
        }
      },
      collideGroupVsTilemapLayer: function (a, b, c, d, e, f) {
        if (0 !== a.length) {
          for (var g = 0; g < a.children.length; g++) {
            if (a.children[g].exists) {
              this.collideSpriteVsTilemapLayer(a.children[g], b, c, d, e, f);
            }
          }
        }
      },
      separateTile: function (a, b, c, d, e) {
        if (!b.enable) {
          return false;
        }
        var f = d.fixedToCamera ? 0 : d.position.x;
        var g = d.fixedToCamera ? 0 : d.position.y;
        if (!c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) {
          return false;
        }
        if (e) {
          return true;
        }
        if (c.collisionCallback && !c.collisionCallback.call(c.collisionCallbackContext, b.sprite, c)) {
          return false;
        }
        if (undefined !== c.layer.callbacks && c.layer.callbacks[c.index] && !c.layer.callbacks[c.index].callback.call(c.layer.callbacks[c.index].callbackContext, b.sprite, c)) {
          return false;
        }
        if (!(c.faceLeft || c.faceRight || c.faceTop || c.faceBottom)) {
          return false;
        }
        var h = 0;
        var i = 0;
        var j = 0;
        var k = 1;
        if (b.deltaAbsX() > b.deltaAbsY()) {
          j = -1;
        } else if (b.deltaAbsX() < b.deltaAbsY()) {
          k = -1;
        }
        if (0 !== b.deltaX() && 0 !== b.deltaY() && (c.faceLeft || c.faceRight) && (c.faceTop || c.faceBottom)) {
          j = Math.min(Math.abs(b.position.x - f - c.right), Math.abs(b.right - f - c.left));
          k = Math.min(Math.abs(b.position.y - g - c.bottom), Math.abs(b.bottom - g - c.top));
        }
        if (j < k) {
          if ((c.faceLeft || c.faceRight) && 0 !== (h = this.tileCheckX(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) {
            return true;
          }
          if (c.faceTop || c.faceBottom) {
            i = this.tileCheckY(b, c, d);
          }
        } else {
          if ((c.faceTop || c.faceBottom) && 0 !== (i = this.tileCheckY(b, c, d)) && !c.intersects(b.position.x - f, b.position.y - g, b.right - f, b.bottom - g)) {
            return true;
          }
          if (c.faceLeft || c.faceRight) {
            h = this.tileCheckX(b, c, d);
          }
        }
        return 0 !== h || 0 !== i;
      },
      tileCheckX: function (a, b, c) {
        var d = 0;
        var e = c.fixedToCamera ? 0 : c.position.x;
        if (a.deltaX() < 0 && !a.blocked.left && b.collideRight && a.checkCollision.left) {
          if (b.faceRight && a.x - e < b.right && (d = a.x - e - b.right) < -this.TILE_BIAS) {
            d = 0;
          }
        } else if (a.deltaX() > 0 && !a.blocked.right && b.collideLeft && a.checkCollision.right && b.faceLeft && a.right - e > b.left && (d = a.right - e - b.left) > this.TILE_BIAS) {
          d = 0;
        }
        if (0 !== d) {
          if (a.customSeparateX) {
            a.overlapX = d;
          } else {
            this.processTileSeparationX(a, d);
          }
        }
        return d;
      },
      tileCheckY: function (a, b, c) {
        var d = 0;
        var e = c.fixedToCamera ? 0 : c.position.y;
        if (a.deltaY() < 0 && !a.blocked.up && b.collideDown && a.checkCollision.up) {
          if (b.faceBottom && a.y - e < b.bottom && (d = a.y - e - b.bottom) < -this.TILE_BIAS) {
            d = 0;
          }
        } else if (a.deltaY() > 0 && !a.blocked.down && b.collideUp && a.checkCollision.down && b.faceTop && a.bottom - e > b.top && (d = a.bottom - e - b.top) > this.TILE_BIAS) {
          d = 0;
        }
        if (0 !== d) {
          if (a.customSeparateY) {
            a.overlapY = d;
          } else {
            this.processTileSeparationY(a, d);
          }
        }
        return d;
      },
      processTileSeparationX: function (a, b) {
        if (b < 0) {
          a.blocked.left = true;
        } else if (b > 0) {
          a.blocked.right = true;
        }
        a.position.x -= b;
        if (0 === a.bounce.x) {
          a.velocity.x = 0;
        } else {
          a.velocity.x = -a.velocity.x * a.bounce.x;
        }
      },
      processTileSeparationY: function (a, b) {
        if (b < 0) {
          a.blocked.up = true;
        } else if (b > 0) {
          a.blocked.down = true;
        }
        a.position.y -= b;
        if (0 === a.bounce.y) {
          a.velocity.y = 0;
        } else {
          a.velocity.y = -a.velocity.y * a.bounce.y;
        }
      }
    };
    b.Utils.mixinPrototype(b.Physics.Arcade.prototype, b.Physics.Arcade.TilemapCollision.prototype);
    p2.Body.prototype.parent = null;
    p2.Spring.prototype.parent = null;
    b.Physics.P2 = function (a, c) {
      this.game = a;
      if (undefined === c) {
        c = {
          gravity: [0, 0],
          broadphase: new p2.SAPBroadphase()
        };
      } else {
        if (!c.hasOwnProperty("gravity")) {
          c.gravity = [0, 0];
        }
        if (!c.hasOwnProperty("broadphase")) {
          c.broadphase = new p2.SAPBroadphase();
        }
      }
      this.config = c;
      this.world = new p2.World(this.config);
      this.frameRate = 0.016666666666666666;
      this.useElapsedTime = false;
      this.paused = false;
      this.materials = [];
      this.gravity = new b.Physics.P2.InversePointProxy(this, this.world.gravity);
      this.walls = {
        left: null,
        right: null,
        top: null,
        bottom: null
      };
      this.onBodyAdded = new b.Signal();
      this.onBodyRemoved = new b.Signal();
      this.onSpringAdded = new b.Signal();
      this.onSpringRemoved = new b.Signal();
      this.onConstraintAdded = new b.Signal();
      this.onConstraintRemoved = new b.Signal();
      this.onContactMaterialAdded = new b.Signal();
      this.onContactMaterialRemoved = new b.Signal();
      this.postBroadphaseCallback = null;
      this.callbackContext = null;
      this.onBeginContact = new b.Signal();
      this.onEndContact = new b.Signal();
      if (c.hasOwnProperty("mpx") && c.hasOwnProperty("pxm") && c.hasOwnProperty("mpxi") && c.hasOwnProperty("pxmi")) {
        this.mpx = c.mpx;
        this.mpxi = c.mpxi;
        this.pxm = c.pxm;
        this.pxmi = c.pxmi;
      }
      this.world.on("beginContact", this.beginContactHandler, this);
      this.world.on("endContact", this.endContactHandler, this);
      this.collisionGroups = [];
      this.nothingCollisionGroup = new b.Physics.P2.CollisionGroup(1);
      this.boundsCollisionGroup = new b.Physics.P2.CollisionGroup(2);
      this.everythingCollisionGroup = new b.Physics.P2.CollisionGroup(2147483648);
      this.boundsCollidesWith = [];
      this._toRemove = [];
      this._collisionGroupID = 2;
      this._boundsLeft = true;
      this._boundsRight = true;
      this._boundsTop = true;
      this._boundsBottom = true;
      this._boundsOwnGroup = false;
      this.setBoundsToWorld(true, true, true, true, false);
    };
    b.Physics.P2.prototype = {
      removeBodyNextStep: function (a) {
        this._toRemove.push(a);
      },
      preUpdate: function () {
        for (var a = this._toRemove.length; a--;) {
          this.removeBody(this._toRemove[a]);
        }
        this._toRemove.length = 0;
      },
      enable: function (a, c, d) {
        if (undefined === c) {
          c = false;
        }
        if (undefined === d) {
          d = true;
        }
        var e = 1;
        if (Array.isArray(a)) {
          for (e = a.length; e--;) {
            if (a[e] instanceof b.Group) {
              this.enable(a[e].children, c, d);
            } else {
              this.enableBody(a[e], c);
              if (d && a[e].hasOwnProperty("children") && a[e].children.length > 0) {
                this.enable(a[e], c, true);
              }
            }
          }
        } else if (a instanceof b.Group) {
          this.enable(a.children, c, d);
        } else {
          this.enableBody(a, c);
          if (d && a.hasOwnProperty("children") && a.children.length > 0) {
            this.enable(a.children, c, true);
          }
        }
      },
      enableBody: function (a, c) {
        if (a.hasOwnProperty("body") && null === a.body) {
          a.body = new b.Physics.P2.Body(this.game, a, a.x, a.y, 1);
          a.body.debug = c;
          if (undefined !== a.anchor) {
            a.anchor.set(.5);
          }
        }
      },
      setImpactEvents: function (a) {
        if (a) {
          this.world.on("impact", this.impactHandler, this);
        } else {
          this.world.off("impact", this.impactHandler, this);
        }
      },
      setPostBroadphaseCallback: function (a, b) {
        this.postBroadphaseCallback = a;
        this.callbackContext = b;
        if (null !== a) {
          this.world.on("postBroadphase", this.postBroadphaseHandler, this);
        } else {
          this.world.off("postBroadphase", this.postBroadphaseHandler, this);
        }
      },
      postBroadphaseHandler: function (a) {
        if (this.postBroadphaseCallback && 0 !== a.pairs.length) {
          for (var b = a.pairs.length - 2; b >= 0; b -= 2) {
            if (a.pairs[b].parent && a.pairs[b + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, a.pairs[b].parent, a.pairs[b + 1].parent)) {
              a.pairs.splice(b, 2);
            }
          }
        }
      },
      impactHandler: function (a) {
        if (a.bodyA.parent && a.bodyB.parent) {
          var b = a.bodyA.parent;
          var c = a.bodyB.parent;
          if (b._bodyCallbacks[a.bodyB.id]) {
            b._bodyCallbacks[a.bodyB.id].call(b._bodyCallbackContext[a.bodyB.id], b, c, a.shapeA, a.shapeB);
          }
          if (c._bodyCallbacks[a.bodyA.id]) {
            c._bodyCallbacks[a.bodyA.id].call(c._bodyCallbackContext[a.bodyA.id], c, b, a.shapeB, a.shapeA);
          }
          if (b._groupCallbacks[a.shapeB.collisionGroup]) {
            b._groupCallbacks[a.shapeB.collisionGroup].call(b._groupCallbackContext[a.shapeB.collisionGroup], b, c, a.shapeA, a.shapeB);
          }
          if (c._groupCallbacks[a.shapeA.collisionGroup]) {
            c._groupCallbacks[a.shapeA.collisionGroup].call(c._groupCallbackContext[a.shapeA.collisionGroup], c, b, a.shapeB, a.shapeA);
          }
        }
      },
      beginContactHandler: function (a) {
        if (a.bodyA && a.bodyB) {
          this.onBeginContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB, a.contactEquations);
          if (a.bodyA.parent) {
            a.bodyA.parent.onBeginContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB, a.contactEquations);
          }
          if (a.bodyB.parent) {
            a.bodyB.parent.onBeginContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA, a.contactEquations);
          }
        }
      },
      endContactHandler: function (a) {
        if (a.bodyA && a.bodyB) {
          this.onEndContact.dispatch(a.bodyA, a.bodyB, a.shapeA, a.shapeB);
          if (a.bodyA.parent) {
            a.bodyA.parent.onEndContact.dispatch(a.bodyB.parent, a.bodyB, a.shapeA, a.shapeB);
          }
          if (a.bodyB.parent) {
            a.bodyB.parent.onEndContact.dispatch(a.bodyA.parent, a.bodyA, a.shapeB, a.shapeA);
          }
        }
      },
      setBoundsToWorld: function (a, b, c, d, e) {
        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, a, b, c, d, e);
      },
      setWorldMaterial: function (a, b, c, d, e) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          c = true;
        }
        if (undefined === d) {
          d = true;
        }
        if (undefined === e) {
          e = true;
        }
        if (b && this.walls.left) {
          this.walls.left.shapes[0].material = a;
        }
        if (c && this.walls.right) {
          this.walls.right.shapes[0].material = a;
        }
        if (d && this.walls.top) {
          this.walls.top.shapes[0].material = a;
        }
        if (e && this.walls.bottom) {
          this.walls.bottom.shapes[0].material = a;
        }
      },
      updateBoundsCollisionGroup: function (a) {
        if (undefined === a) {
          a = true;
        }
        var b = a ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
        if (this.walls.left) {
          this.walls.left.shapes[0].collisionGroup = b;
        }
        if (this.walls.right) {
          this.walls.right.shapes[0].collisionGroup = b;
        }
        if (this.walls.top) {
          this.walls.top.shapes[0].collisionGroup = b;
        }
        if (this.walls.bottom) {
          this.walls.bottom.shapes[0].collisionGroup = b;
        }
        this._boundsOwnGroup = a;
      },
      setBounds: function (a, b, c, d, e, f, g, h, i) {
        if (undefined === e) {
          e = this._boundsLeft;
        }
        if (undefined === f) {
          f = this._boundsRight;
        }
        if (undefined === g) {
          g = this._boundsTop;
        }
        if (undefined === h) {
          h = this._boundsBottom;
        }
        if (undefined === i) {
          i = this._boundsOwnGroup;
        }
        this.setupWall(e, "left", a, b, 1.5707963267948966, i);
        this.setupWall(f, "right", a + c, b, -1.5707963267948966, i);
        this.setupWall(g, "top", a, b, -3.141592653589793, i);
        this.setupWall(h, "bottom", a, b + d, 0, i);
        this._boundsLeft = e;
        this._boundsRight = f;
        this._boundsTop = g;
        this._boundsBottom = h;
        this._boundsOwnGroup = i;
      },
      setupWall: function (a, b, c, d, e, f) {
        if (a) {
          if (this.walls[b]) {
            this.walls[b].position = [this.pxmi(c), this.pxmi(d)];
          } else {
            this.walls[b] = new p2.Body({
              mass: 0,
              position: [this.pxmi(c), this.pxmi(d)],
              angle: e
            });
            this.walls[b].addShape(new p2.Plane());
            this.world.addBody(this.walls[b]);
          }
          if (f) {
            this.walls[b].shapes[0].collisionGroup = this.boundsCollisionGroup.mask;
          }
        } else if (this.walls[b]) {
          this.world.removeBody(this.walls[b]);
          this.walls[b] = null;
        }
      },
      pause: function () {
        this.paused = true;
      },
      resume: function () {
        this.paused = false;
      },
      update: function () {
        if (!this.paused) {
          if (this.useElapsedTime) {
            this.world.step(this.game.time.physicsElapsed);
          } else {
            this.world.step(this.frameRate);
          }
        }
      },
      reset: function () {
        this.world.on("beginContact", this.beginContactHandler, this);
        this.world.on("endContact", this.endContactHandler, this);
        this.nothingCollisionGroup = new b.Physics.P2.CollisionGroup(1);
        this.boundsCollisionGroup = new b.Physics.P2.CollisionGroup(2);
        this.everythingCollisionGroup = new b.Physics.P2.CollisionGroup(2147483648);
        this._collisionGroupID = 2;
        this.setBoundsToWorld(true, true, true, true, false);
      },
      clear: function () {
        this.world.time = 0;
        this.world.fixedStepTime = 0;
        if (this.world.solver && this.world.solver.equations.length) {
          this.world.solver.removeAllEquations();
        }
        var a = this.world.constraints;
        for (var b = a.length - 1; b >= 0; b--) {
          this.world.removeConstraint(a[b]);
        }
        var c = this.world.bodies;
        for (var b = c.length - 1; b >= 0; b--) {
          this.world.removeBody(c[b]);
        }
        var d = this.world.springs;
        for (var b = d.length - 1; b >= 0; b--) {
          this.world.removeSpring(d[b]);
        }
        var e = this.world.contactMaterials;
        for (var b = e.length - 1; b >= 0; b--) {
          this.world.removeContactMaterial(e[b]);
        }
        this.world.off("beginContact", this.beginContactHandler, this);
        this.world.off("endContact", this.endContactHandler, this);
        this.postBroadphaseCallback = null;
        this.callbackContext = null;
        this.impactCallback = null;
        this.collisionGroups = [];
        this._toRemove = [];
        this.boundsCollidesWith = [];
        this.walls = {
          left: null,
          right: null,
          top: null,
          bottom: null
        };
      },
      destroy: function () {
        this.clear();
        this.game = null;
      },
      addBody: function (a) {
        return !a.data.world && (this.world.addBody(a.data), this.onBodyAdded.dispatch(a), true);
      },
      removeBody: function (a) {
        if (a.data.world === this.world) {
          this.world.removeBody(a.data);
          this.onBodyRemoved.dispatch(a);
        }
        return a;
      },
      addSpring: function (a) {
        if (a instanceof b.Physics.P2.Spring || a instanceof b.Physics.P2.RotationalSpring) {
          this.world.addSpring(a.data);
        } else {
          this.world.addSpring(a);
        }
        this.onSpringAdded.dispatch(a);
        return a;
      },
      removeSpring: function (a) {
        if (a instanceof b.Physics.P2.Spring || a instanceof b.Physics.P2.RotationalSpring) {
          this.world.removeSpring(a.data);
        } else {
          this.world.removeSpring(a);
        }
        this.onSpringRemoved.dispatch(a);
        return a;
      },
      createDistanceConstraint: function (a, c, d, e, f, g) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addConstraint(new b.Physics.P2.DistanceConstraint(this, a, c, d, e, f, g));
        }
        console.warn("Cannot create Constraint, invalid body objects given");
      },
      createGearConstraint: function (a, c, d, e) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addConstraint(new b.Physics.P2.GearConstraint(this, a, c, d, e));
        }
        console.warn("Cannot create Constraint, invalid body objects given");
      },
      createRevoluteConstraint: function (a, c, d, e, f, g) {
        a = this.getBody(a);
        d = this.getBody(d);
        if (a && d) {
          return this.addConstraint(new b.Physics.P2.RevoluteConstraint(this, a, c, d, e, f, g));
        }
        console.warn("Cannot create Constraint, invalid body objects given");
      },
      createLockConstraint: function (a, c, d, e, f) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addConstraint(new b.Physics.P2.LockConstraint(this, a, c, d, e, f));
        }
        console.warn("Cannot create Constraint, invalid body objects given");
      },
      createPrismaticConstraint: function (a, c, d, e, f, g, h) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addConstraint(new b.Physics.P2.PrismaticConstraint(this, a, c, d, e, f, g, h));
        }
        console.warn("Cannot create Constraint, invalid body objects given");
      },
      addConstraint: function (a) {
        this.world.addConstraint(a);
        this.onConstraintAdded.dispatch(a);
        return a;
      },
      removeConstraint: function (a) {
        this.world.removeConstraint(a);
        this.onConstraintRemoved.dispatch(a);
        return a;
      },
      addContactMaterial: function (a) {
        this.world.addContactMaterial(a);
        this.onContactMaterialAdded.dispatch(a);
        return a;
      },
      removeContactMaterial: function (a) {
        this.world.removeContactMaterial(a);
        this.onContactMaterialRemoved.dispatch(a);
        return a;
      },
      getContactMaterial: function (a, b) {
        return this.world.getContactMaterial(a, b);
      },
      setMaterial: function (a, b) {
        for (var c = b.length; c--;) {
          b[c].setMaterial(a);
        }
      },
      createMaterial: function (a, c) {
        a = a || "";
        var d = new b.Physics.P2.Material(a);
        this.materials.push(d);
        if (undefined !== c) {
          c.setMaterial(d);
        }
        return d;
      },
      createContactMaterial: function (a, c, d) {
        if (undefined === a) {
          a = this.createMaterial();
        }
        if (undefined === c) {
          c = this.createMaterial();
        }
        var e = new b.Physics.P2.ContactMaterial(a, c, d);
        return this.addContactMaterial(e);
      },
      getBodies: function () {
        var a = [];
        for (var b = this.world.bodies.length; b--;) {
          a.push(this.world.bodies[b].parent);
        }
        return a;
      },
      getBody: function (a) {
        return a instanceof p2.Body ? a : a instanceof b.Physics.P2.Body ? a.data : a.body && a.body.type === b.Physics.P2JS ? a.body.data : null;
      },
      getSprings: function () {
        var a = [];
        for (var b = this.world.springs.length; b--;) {
          a.push(this.world.springs[b].parent);
        }
        return a;
      },
      getConstraints: function () {
        var a = [];
        for (var b = this.world.constraints.length; b--;) {
          a.push(this.world.constraints[b]);
        }
        return a;
      },
      hitTest: function (a, c, d, e) {
        if (undefined === c) {
          c = this.world.bodies;
        }
        if (undefined === d) {
          d = 5;
        }
        if (undefined === e) {
          e = false;
        }
        var f = [this.pxmi(a.x), this.pxmi(a.y)];
        var g = [];
        for (var h = c.length; h--;) {
          if (c[h] instanceof b.Physics.P2.Body && (!e || c[h].data.type !== p2.Body.STATIC)) {
            g.push(c[h].data);
          } else if (c[h] instanceof p2.Body && c[h].parent && (!e || c[h].type !== p2.Body.STATIC)) {
            g.push(c[h]);
          } else if (c[h] instanceof b.Sprite && c[h].hasOwnProperty("body") && (!e || c[h].body.data.type !== p2.Body.STATIC)) {
            g.push(c[h].body.data);
          }
        }
        return this.world.hitTest(f, g, d);
      },
      toJSON: function () {
        return this.world.toJSON();
      },
      createCollisionGroup: function (a) {
        var c = Math.pow(2, this._collisionGroupID);
        if (this.walls.left) {
          this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | c;
        }
        if (this.walls.right) {
          this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | c;
        }
        if (this.walls.top) {
          this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | c;
        }
        if (this.walls.bottom) {
          this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | c;
        }
        this._collisionGroupID++;
        var d = new b.Physics.P2.CollisionGroup(c);
        this.collisionGroups.push(d);
        if (a) {
          this.setCollisionGroup(a, d);
        }
        return d;
      },
      setCollisionGroup: function (a, c) {
        if (a instanceof b.Group) {
          for (var d = 0; d < a.total; d++) {
            if (a.children[d].body && a.children[d].body.type === b.Physics.P2JS) {
              a.children[d].body.setCollisionGroup(c);
            }
          }
        } else {
          a.body.setCollisionGroup(c);
        }
      },
      createSpring: function (a, c, d, e, f, g, h, i, j) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addSpring(new b.Physics.P2.Spring(this, a, c, d, e, f, g, h, i, j));
        }
        console.warn("Cannot create Spring, invalid body objects given");
      },
      createRotationalSpring: function (a, c, d, e, f) {
        a = this.getBody(a);
        c = this.getBody(c);
        if (a && c) {
          return this.addSpring(new b.Physics.P2.RotationalSpring(this, a, c, d, e, f));
        }
        console.warn("Cannot create Rotational Spring, invalid body objects given");
      },
      createBody: function (a, c, d, e, f, g) {
        if (undefined === e) {
          e = false;
        }
        var h = new b.Physics.P2.Body(this.game, null, a, c, d);
        if (g) {
          if (!h.addPolygon(f, g)) {
            return false;
          }
        }
        if (e) {
          this.world.addBody(h.data);
        }
        return h;
      },
      createParticle: function (a, c, d, e, f, g) {
        if (undefined === e) {
          e = false;
        }
        var h = new b.Physics.P2.Body(this.game, null, a, c, d);
        if (g) {
          if (!h.addPolygon(f, g)) {
            return false;
          }
        }
        if (e) {
          this.world.addBody(h.data);
        }
        return h;
      },
      convertCollisionObjects: function (a, b, c) {
        if (undefined === c) {
          c = true;
        }
        var d = [];
        var e = 0;
        for (var f = a.collision[b].length; e < f; e++) {
          var g = a.collision[b][e];
          var h = this.createBody(g.x, g.y, 0, c, {}, g.polyline);
          if (h) {
            d.push(h);
          }
        }
        return d;
      },
      clearTilemapLayerBodies: function (a, b) {
        b = a.getLayer(b);
        for (var c = a.layers[b].bodies.length; c--;) {
          a.layers[b].bodies[c].destroy();
        }
        a.layers[b].bodies.length = 0;
      },
      convertTilemap: function (a, b, c, d) {
        b = a.getLayer(b);
        if (undefined === c) {
          c = true;
        }
        if (undefined === d) {
          d = true;
        }
        this.clearTilemapLayerBodies(a, b);
        var e = 0;
        var f = 0;
        var g = 0;
        var h = 0;
        for (var i = a.layers[b].height; h < i; h++) {
          e = 0;
          var j = 0;
          for (var k = a.layers[b].width; j < k; j++) {
            var l = a.layers[b].data[h][j];
            if (l && l.index > -1 && l.collides) {
              if (d) {
                var m = a.getTileRight(b, j, h);
                if (0 === e) {
                  f = l.x * l.width;
                  g = l.y * l.height;
                  e = l.width;
                }
                if (m && m.collides) {
                  e += l.width;
                } else {
                  var n = this.createBody(f, g, 0, false);
                  n.addRectangle(e, l.height, e / 2, l.height / 2, 0);
                  if (c) {
                    this.addBody(n);
                  }
                  a.layers[b].bodies.push(n);
                  e = 0;
                }
              } else {
                var n = this.createBody(l.x * l.width, l.y * l.height, 0, false);
                n.addRectangle(l.width, l.height, l.width / 2, l.height / 2, 0);
                if (c) {
                  this.addBody(n);
                }
                a.layers[b].bodies.push(n);
              }
            }
          }
        }
        return a.layers[b].bodies;
      },
      mpx: function (a) {
        return a *= 20;
      },
      pxm: function (a) {
        return .05 * a;
      },
      mpxi: function (a) {
        return a *= -20;
      },
      pxmi: function (a) {
        return -.05 * a;
      }
    };
    Object.defineProperty(b.Physics.P2.prototype, "friction", {
      get: function () {
        return this.world.defaultContactMaterial.friction;
      },
      set: function (a) {
        this.world.defaultContactMaterial.friction = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "restitution", {
      get: function () {
        return this.world.defaultContactMaterial.restitution;
      },
      set: function (a) {
        this.world.defaultContactMaterial.restitution = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "contactMaterial", {
      get: function () {
        return this.world.defaultContactMaterial;
      },
      set: function (a) {
        this.world.defaultContactMaterial = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "applySpringForces", {
      get: function () {
        return this.world.applySpringForces;
      },
      set: function (a) {
        this.world.applySpringForces = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "applyDamping", {
      get: function () {
        return this.world.applyDamping;
      },
      set: function (a) {
        this.world.applyDamping = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "applyGravity", {
      get: function () {
        return this.world.applyGravity;
      },
      set: function (a) {
        this.world.applyGravity = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "solveConstraints", {
      get: function () {
        return this.world.solveConstraints;
      },
      set: function (a) {
        this.world.solveConstraints = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "time", {
      get: function () {
        return this.world.time;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "emitImpactEvent", {
      get: function () {
        return this.world.emitImpactEvent;
      },
      set: function (a) {
        this.world.emitImpactEvent = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "sleepMode", {
      get: function () {
        return this.world.sleepMode;
      },
      set: function (a) {
        this.world.sleepMode = a;
      }
    });
    Object.defineProperty(b.Physics.P2.prototype, "total", {
      get: function () {
        return this.world.bodies.length;
      }
    });
    b.Physics.P2.FixtureList = function (a) {
      if (!Array.isArray(a)) {
        a = [a];
      }
      this.rawList = a;
      this.init();
      this.parse(this.rawList);
    };
    b.Physics.P2.FixtureList.prototype = {
      init: function () {
        this.namedFixtures = {};
        this.groupedFixtures = [];
        this.allFixtures = [];
      },
      setCategory: function (a, b) {
        var c = function (b) {
          b.collisionGroup = a;
        };
        this.getFixtures(b).forEach(c);
      },
      setMask: function (a, b) {
        var c = function (b) {
          b.collisionMask = a;
        };
        this.getFixtures(b).forEach(c);
      },
      setSensor: function (a, b) {
        var c = function (b) {
          b.sensor = a;
        };
        this.getFixtures(b).forEach(c);
      },
      setMaterial: function (a, b) {
        var c = function (b) {
          b.material = a;
        };
        this.getFixtures(b).forEach(c);
      },
      getFixtures: function (a) {
        var b = [];
        if (a) {
          if (!(a instanceof Array)) {
            a = [a];
          }
          var c = this;
          a.forEach(function (a) {
            if (c.namedFixtures[a]) {
              b.push(c.namedFixtures[a]);
            }
          });
          return this.flatten(b);
        }
        return this.allFixtures;
      },
      getFixtureByKey: function (a) {
        return this.namedFixtures[a];
      },
      getGroup: function (a) {
        return this.groupedFixtures[a];
      },
      parse: function () {
        var a;
        var b;
        var c;
        var d;
        c = this.rawList;
        d = [];
        for (a in c) {
          b = c[a];
          if (isNaN(a - 0)) {
            this.namedFixtures[a] = this.flatten(b);
          } else {
            this.groupedFixtures[a] = this.groupedFixtures[a] || [];
            this.groupedFixtures[a] = this.groupedFixtures[a].concat(b);
          }
          d.push(this.allFixtures = this.flatten(this.groupedFixtures));
        }
      },
      flatten: function (a) {
        var b;
        var c;
        b = [];
        c = arguments.callee;
        a.forEach(function (a) {
          return Array.prototype.push.apply(b, Array.isArray(a) ? c(a) : [a]);
        });
        return b;
      }
    };
    b.Physics.P2.PointProxy = function (a, b) {
      this.world = a;
      this.destination = b;
    };
    b.Physics.P2.PointProxy.prototype.constructor = b.Physics.P2.PointProxy;
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "x", {
      get: function () {
        return this.world.mpx(this.destination[0]);
      },
      set: function (a) {
        this.destination[0] = this.world.pxm(a);
      }
    });
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "y", {
      get: function () {
        return this.world.mpx(this.destination[1]);
      },
      set: function (a) {
        this.destination[1] = this.world.pxm(a);
      }
    });
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "mx", {
      get: function () {
        return this.destination[0];
      },
      set: function (a) {
        this.destination[0] = a;
      }
    });
    Object.defineProperty(b.Physics.P2.PointProxy.prototype, "my", {
      get: function () {
        return this.destination[1];
      },
      set: function (a) {
        this.destination[1] = a;
      }
    });
    b.Physics.P2.InversePointProxy = function (a, b) {
      this.world = a;
      this.destination = b;
    };
    b.Physics.P2.InversePointProxy.prototype.constructor = b.Physics.P2.InversePointProxy;
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "x", {
      get: function () {
        return this.world.mpxi(this.destination[0]);
      },
      set: function (a) {
        this.destination[0] = this.world.pxmi(a);
      }
    });
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "y", {
      get: function () {
        return this.world.mpxi(this.destination[1]);
      },
      set: function (a) {
        this.destination[1] = this.world.pxmi(a);
      }
    });
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "mx", {
      get: function () {
        return this.destination[0];
      },
      set: function (a) {
        this.destination[0] = -a;
      }
    });
    Object.defineProperty(b.Physics.P2.InversePointProxy.prototype, "my", {
      get: function () {
        return this.destination[1];
      },
      set: function (a) {
        this.destination[1] = -a;
      }
    });
    b.Physics.P2.Body = function (a, c, d, e, f) {
      c = c || null;
      d = d || 0;
      e = e || 0;
      if (undefined === f) {
        f = 1;
      }
      this.game = a;
      this.world = a.physics.p2;
      this.sprite = c;
      this.type = b.Physics.P2JS;
      this.offset = new b.Point();
      this.data = new p2.Body({
        position: [this.world.pxmi(d), this.world.pxmi(e)],
        mass: f
      });
      this.data.parent = this;
      this.velocity = new b.Physics.P2.InversePointProxy(this.world, this.data.velocity);
      this.force = new b.Physics.P2.InversePointProxy(this.world, this.data.force);
      this.gravity = new b.Point();
      this.onBeginContact = new b.Signal();
      this.onEndContact = new b.Signal();
      this.collidesWith = [];
      this.removeNextStep = false;
      this.debugBody = null;
      this.dirty = false;
      this._collideWorldBounds = true;
      this._bodyCallbacks = {};
      this._bodyCallbackContext = {};
      this._groupCallbacks = {};
      this._groupCallbackContext = {};
      this._reset = false;
      if (c) {
        this.setRectangleFromSprite(c);
        if (c.exists) {
          this.game.physics.p2.addBody(this);
        }
      }
    };
    b.Physics.P2.Body.prototype = {
      createBodyCallback: function (a, b, c) {
        var d = -1;
        if (a.id) {
          d = a.id;
        } else if (a.body) {
          d = a.body.id;
        }
        if (d > -1) {
          if (null === b) {
            delete this._bodyCallbacks[d];
            delete this._bodyCallbackContext[d];
          } else {
            this._bodyCallbacks[d] = b;
            this._bodyCallbackContext[d] = c;
          }
        }
      },
      createGroupCallback: function (a, b, c) {
        if (null === b) {
          delete this._groupCallbacks[a.mask];
          delete this._groupCallbackContext[a.mask];
        } else {
          this._groupCallbacks[a.mask] = b;
          this._groupCallbackContext[a.mask] = c;
        }
      },
      getCollisionMask: function () {
        var a = 0;
        if (this._collideWorldBounds) {
          a = this.game.physics.p2.boundsCollisionGroup.mask;
        }
        for (var b = 0; b < this.collidesWith.length; b++) {
          a |= this.collidesWith[b].mask;
        }
        return a;
      },
      updateCollisionMask: function (a) {
        var b = this.getCollisionMask();
        if (undefined === a) {
          for (var c = this.data.shapes.length - 1; c >= 0; c--) {
            this.data.shapes[c].collisionMask = b;
          }
        } else {
          a.collisionMask = b;
        }
      },
      setCollisionGroup: function (a, b) {
        var c = this.getCollisionMask();
        if (undefined === b) {
          for (var d = this.data.shapes.length - 1; d >= 0; d--) {
            this.data.shapes[d].collisionGroup = a.mask;
            this.data.shapes[d].collisionMask = c;
          }
        } else {
          b.collisionGroup = a.mask;
          b.collisionMask = c;
        }
      },
      clearCollision: function (a, b, c) {
        if (undefined === a) {
          a = true;
        }
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          for (var d = this.data.shapes.length - 1; d >= 0; d--) {
            if (a) {
              this.data.shapes[d].collisionGroup = null;
            }
            if (b) {
              this.data.shapes[d].collisionMask = null;
            }
          }
        } else {
          if (a) {
            c.collisionGroup = null;
          }
          if (b) {
            c.collisionMask = null;
          }
        }
        if (a) {
          this.collidesWith.length = 0;
        }
      },
      removeCollisionGroup: function (a, b, c) {
        if (undefined === b) {
          b = true;
        }
        var d;
        if (Array.isArray(a)) {
          for (var e = 0; e < a.length; e++) {
            if ((d = this.collidesWith.indexOf(a[e])) > -1) {
              this.collidesWith.splice(d, 1);
              if (b) {
                delete this._groupCallbacks[a.mask];
                delete this._groupCallbackContext[a.mask];
              }
            }
          }
        } else if ((d = this.collidesWith.indexOf(a)) > -1) {
          this.collidesWith.splice(d, 1);
          if (b) {
            delete this._groupCallbacks[a.mask];
            delete this._groupCallbackContext[a.mask];
          }
        }
        var f = this.getCollisionMask();
        if (undefined === c) {
          for (var e = this.data.shapes.length - 1; e >= 0; e--) {
            this.data.shapes[e].collisionMask = f;
          }
        } else {
          c.collisionMask = f;
        }
      },
      collides: function (a, b, c, d) {
        if (Array.isArray(a)) {
          for (var e = 0; e < a.length; e++) {
            if (-1 === this.collidesWith.indexOf(a[e])) {
              this.collidesWith.push(a[e]);
              if (b) {
                this.createGroupCallback(a[e], b, c);
              }
            }
          }
        } else if (-1 === this.collidesWith.indexOf(a)) {
          this.collidesWith.push(a);
          if (b) {
            this.createGroupCallback(a, b, c);
          }
        }
        var f = this.getCollisionMask();
        if (undefined === d) {
          for (var e = this.data.shapes.length - 1; e >= 0; e--) {
            this.data.shapes[e].collisionMask = f;
          }
        } else {
          d.collisionMask = f;
        }
      },
      adjustCenterOfMass: function () {
        this.data.adjustCenterOfMass();
        this.shapeChanged();
      },
      getVelocityAtPoint: function (a, b) {
        return this.data.getVelocityAtPoint(a, b);
      },
      applyDamping: function (a) {
        this.data.applyDamping(a);
      },
      applyImpulse: function (a, b, c) {
        this.data.applyImpulse(a, [this.world.pxmi(b), this.world.pxmi(c)]);
      },
      applyImpulseLocal: function (a, b, c) {
        this.data.applyImpulseLocal(a, [this.world.pxmi(b), this.world.pxmi(c)]);
      },
      applyForce: function (a, b, c) {
        this.data.applyForce(a, [this.world.pxmi(b), this.world.pxmi(c)]);
      },
      setZeroForce: function () {
        this.data.setZeroForce();
      },
      setZeroRotation: function () {
        this.data.angularVelocity = 0;
      },
      setZeroVelocity: function () {
        this.data.velocity[0] = 0;
        this.data.velocity[1] = 0;
      },
      setZeroDamping: function () {
        this.data.damping = 0;
        this.data.angularDamping = 0;
      },
      toLocalFrame: function (a, b) {
        return this.data.toLocalFrame(a, b);
      },
      toWorldFrame: function (a, b) {
        return this.data.toWorldFrame(a, b);
      },
      rotateLeft: function (a) {
        this.data.angularVelocity = this.world.pxm(-a);
      },
      rotateRight: function (a) {
        this.data.angularVelocity = this.world.pxm(a);
      },
      moveForward: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = b * Math.cos(c);
        this.data.velocity[1] = b * Math.sin(c);
      },
      moveBackward: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle + Math.PI / 2;
        this.data.velocity[0] = -b * Math.cos(c);
        this.data.velocity[1] = -b * Math.sin(c);
      },
      thrust: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle + Math.PI / 2;
        this.data.force[0] += b * Math.cos(c);
        this.data.force[1] += b * Math.sin(c);
      },
      thrustLeft: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle;
        this.data.force[0] += b * Math.cos(c);
        this.data.force[1] += b * Math.sin(c);
      },
      thrustRight: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle;
        this.data.force[0] -= b * Math.cos(c);
        this.data.force[1] -= b * Math.sin(c);
      },
      reverse: function (a) {
        var b = this.world.pxmi(-a);
        var c = this.data.angle + Math.PI / 2;
        this.data.force[0] -= b * Math.cos(c);
        this.data.force[1] -= b * Math.sin(c);
      },
      moveLeft: function (a) {
        this.data.velocity[0] = this.world.pxmi(-a);
      },
      moveRight: function (a) {
        this.data.velocity[0] = this.world.pxmi(a);
      },
      moveUp: function (a) {
        this.data.velocity[1] = this.world.pxmi(-a);
      },
      moveDown: function (a) {
        this.data.velocity[1] = this.world.pxmi(a);
      },
      preUpdate: function () {
        this.dirty = true;
        if (this.removeNextStep) {
          this.removeFromWorld();
          this.removeNextStep = false;
        }
      },
      postUpdate: function () {
        this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x;
        this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y;
        if (!this.fixedRotation) {
          this.sprite.rotation = this.data.angle;
        }
        if (this.debugBody) {
          this.debugBody.updateSpriteTransform();
        }
        this.dirty = false;
      },
      reset: function (a, b, c, d) {
        if (undefined === c) {
          c = false;
        }
        if (undefined === d) {
          d = false;
        }
        this.setZeroForce();
        this.setZeroVelocity();
        this.setZeroRotation();
        if (c) {
          this.setZeroDamping();
        }
        if (d) {
          this.mass = 1;
        }
        this.x = a;
        this.y = b;
      },
      addToWorld: function () {
        if (this.game.physics.p2._toRemove) {
          for (var a = 0; a < this.game.physics.p2._toRemove.length; a++) {
            if (this.game.physics.p2._toRemove[a] === this) {
              this.game.physics.p2._toRemove.splice(a, 1);
            }
          }
        }
        if (this.data.world !== this.game.physics.p2.world) {
          this.game.physics.p2.addBody(this);
        }
      },
      removeFromWorld: function () {
        if (this.data.world === this.game.physics.p2.world) {
          this.game.physics.p2.removeBodyNextStep(this);
        }
      },
      destroy: function () {
        this.removeFromWorld();
        this.clearShapes();
        this._bodyCallbacks = {};
        this._bodyCallbackContext = {};
        this._groupCallbacks = {};
        this._groupCallbackContext = {};
        if (this.debugBody) {
          this.debugBody.destroy(true, true);
        }
        this.debugBody = null;
        if (this.sprite) {
          this.sprite.body = null;
          this.sprite = null;
        }
      },
      clearShapes: function () {
        for (var a = this.data.shapes.length; a--;) {
          this.data.removeShape(this.data.shapes[a]);
        }
        this.shapeChanged();
      },
      addShape: function (a, b, c, d) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = 0;
        }
        if (undefined === d) {
          d = 0;
        }
        this.data.addShape(a, [this.world.pxmi(b), this.world.pxmi(c)], d);
        this.shapeChanged();
        return a;
      },
      addCircle: function (a, b, c, d) {
        var e = new p2.Circle({
          radius: this.world.pxm(a)
        });
        return this.addShape(e, b, c, d);
      },
      addRectangle: function (a, b, c, d, e) {
        var f = new p2.Box({
          width: this.world.pxm(a),
          height: this.world.pxm(b)
        });
        return this.addShape(f, c, d, e);
      },
      addPlane: function (a, b, c) {
        var d = new p2.Plane();
        return this.addShape(d, a, b, c);
      },
      addParticle: function (a, b, c) {
        var d = new p2.Particle();
        return this.addShape(d, a, b, c);
      },
      addLine: function (a, b, c, d) {
        var e = new p2.Line({
          length: this.world.pxm(a)
        });
        return this.addShape(e, b, c, d);
      },
      addCapsule: function (a, b, c, d, e) {
        var f = new p2.Capsule({
          length: this.world.pxm(a),
          radius: this.world.pxm(b)
        });
        return this.addShape(f, c, d, e);
      },
      addPolygon: function (a, b) {
        a = a || {};
        if (!Array.isArray(b)) {
          b = Array.prototype.slice.call(arguments, 1);
        }
        var c = [];
        if (1 === b.length && Array.isArray(b[0])) {
          c = b[0].slice(0);
        } else if (Array.isArray(b[0])) {
          c = b.slice();
        } else if ("number" == typeof b[0]) {
          var d = 0;
          for (var e = b.length; d < e; d += 2) {
            c.push([b[d], b[d + 1]]);
          }
        }
        var f = c.length - 1;
        if (c[f][0] === c[0][0] && c[f][1] === c[0][1]) {
          c.pop();
        }
        for (var g = 0; g < c.length; g++) {
          c[g][0] = this.world.pxmi(c[g][0]);
          c[g][1] = this.world.pxmi(c[g][1]);
        }
        var h = this.data.fromPolygon(c, a);
        this.shapeChanged();
        return h;
      },
      removeShape: function (a) {
        var b = this.data.removeShape(a);
        this.shapeChanged();
        return b;
      },
      setCircle: function (a, b, c, d) {
        this.clearShapes();
        return this.addCircle(a, b, c, d);
      },
      setRectangle: function (a, b, c, d, e) {
        if (undefined === a) {
          a = 16;
        }
        if (undefined === b) {
          b = 16;
        }
        this.clearShapes();
        return this.addRectangle(a, b, c, d, e);
      },
      setRectangleFromSprite: function (a) {
        if (undefined === a) {
          a = this.sprite;
        }
        this.clearShapes();
        return this.addRectangle(a.width, a.height, 0, 0, a.rotation);
      },
      setMaterial: function (a, b) {
        if (undefined === b) {
          for (var c = this.data.shapes.length - 1; c >= 0; c--) {
            this.data.shapes[c].material = a;
          }
        } else {
          b.material = a;
        }
      },
      shapeChanged: function () {
        if (this.debugBody) {
          this.debugBody.draw();
        }
      },
      addPhaserPolygon: function (a, b) {
        var c = this.game.cache.getPhysicsData(a, b);
        var d = [];
        for (var e = 0; e < c.length; e++) {
          var f = c[e];
          var g = this.addFixture(f);
          d[f.filter.group] = d[f.filter.group] || [];
          d[f.filter.group] = d[f.filter.group].concat(g);
          if (f.fixtureKey) {
            d[f.fixtureKey] = g;
          }
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return d;
      },
      addFixture: function (a) {
        var b = [];
        if (a.circle) {
          var c = new p2.Circle({
            radius: this.world.pxm(a.circle.radius)
          });
          c.collisionGroup = a.filter.categoryBits;
          c.collisionMask = a.filter.maskBits;
          c.sensor = a.isSensor;
          var d = p2.vec2.create();
          d[0] = this.world.pxmi(a.circle.position[0] - this.sprite.width / 2);
          d[1] = this.world.pxmi(a.circle.position[1] - this.sprite.height / 2);
          this.data.addShape(c, d);
          b.push(c);
        } else {
          var e = a.polygons;
          var f = p2.vec2.create();
          for (var g = 0; g < e.length; g++) {
            var h = e[g];
            var i = [];
            for (var j = 0; j < h.length; j += 2) {
              i.push([this.world.pxmi(h[j]), this.world.pxmi(h[j + 1])]);
            }
            var c = new p2.Convex({
              vertices: i
            });
            for (var k = 0; k !== c.vertices.length; k++) {
              var l = c.vertices[k];
              p2.vec2.sub(l, l, c.centerOfMass);
            }
            p2.vec2.scale(f, c.centerOfMass, 1);
            f[0] -= this.world.pxmi(this.sprite.width / 2);
            f[1] -= this.world.pxmi(this.sprite.height / 2);
            c.updateTriangles();
            c.updateCenterOfMass();
            c.updateBoundingRadius();
            c.collisionGroup = a.filter.categoryBits;
            c.collisionMask = a.filter.maskBits;
            c.sensor = a.isSensor;
            this.data.addShape(c, f);
            b.push(c);
          }
        }
        return b;
      },
      loadPolygon: function (a, b) {
        if (null === a) {
          var c = b;
        } else {
          var c = this.game.cache.getPhysicsData(a, b);
        }
        var d = p2.vec2.create();
        for (var e = 0; e < c.length; e++) {
          var f = [];
          for (var g = 0; g < c[e].shape.length; g += 2) {
            f.push([this.world.pxmi(c[e].shape[g]), this.world.pxmi(c[e].shape[g + 1])]);
          }
          var h = new p2.Convex({
            vertices: f
          });
          for (var i = 0; i !== h.vertices.length; i++) {
            var j = h.vertices[i];
            p2.vec2.sub(j, j, h.centerOfMass);
          }
          p2.vec2.scale(d, h.centerOfMass, 1);
          d[0] -= this.world.pxmi(this.sprite.width / 2);
          d[1] -= this.world.pxmi(this.sprite.height / 2);
          h.updateTriangles();
          h.updateCenterOfMass();
          h.updateBoundingRadius();
          this.data.addShape(h, d);
        }
        this.data.aabbNeedsUpdate = true;
        this.shapeChanged();
        return true;
      }
    };
    b.Physics.P2.Body.prototype.constructor = b.Physics.P2.Body;
    b.Physics.P2.Body.DYNAMIC = 1;
    b.Physics.P2.Body.STATIC = 2;
    b.Physics.P2.Body.KINEMATIC = 4;
    Object.defineProperty(b.Physics.P2.Body.prototype, "static", {
      get: function () {
        return this.data.type === b.Physics.P2.Body.STATIC;
      },
      set: function (a) {
        if (a && this.data.type !== b.Physics.P2.Body.STATIC) {
          this.data.type = b.Physics.P2.Body.STATIC;
          this.mass = 0;
        } else if (!(a || this.data.type !== b.Physics.P2.Body.STATIC)) {
          this.data.type = b.Physics.P2.Body.DYNAMIC;
          this.mass = 1;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "dynamic", {
      get: function () {
        return this.data.type === b.Physics.P2.Body.DYNAMIC;
      },
      set: function (a) {
        if (a && this.data.type !== b.Physics.P2.Body.DYNAMIC) {
          this.data.type = b.Physics.P2.Body.DYNAMIC;
          this.mass = 1;
        } else if (!(a || this.data.type !== b.Physics.P2.Body.DYNAMIC)) {
          this.data.type = b.Physics.P2.Body.STATIC;
          this.mass = 0;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "kinematic", {
      get: function () {
        return this.data.type === b.Physics.P2.Body.KINEMATIC;
      },
      set: function (a) {
        if (a && this.data.type !== b.Physics.P2.Body.KINEMATIC) {
          this.data.type = b.Physics.P2.Body.KINEMATIC;
          this.mass = 4;
        } else if (!(a || this.data.type !== b.Physics.P2.Body.KINEMATIC)) {
          this.data.type = b.Physics.P2.Body.STATIC;
          this.mass = 0;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "allowSleep", {
      get: function () {
        return this.data.allowSleep;
      },
      set: function (a) {
        if (a !== this.data.allowSleep) {
          this.data.allowSleep = a;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "angle", {
      get: function () {
        return b.Math.wrapAngle(b.Math.radToDeg(this.data.angle));
      },
      set: function (a) {
        this.data.angle = b.Math.degToRad(b.Math.wrapAngle(a));
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularDamping", {
      get: function () {
        return this.data.angularDamping;
      },
      set: function (a) {
        this.data.angularDamping = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularForce", {
      get: function () {
        return this.data.angularForce;
      },
      set: function (a) {
        this.data.angularForce = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "angularVelocity", {
      get: function () {
        return this.data.angularVelocity;
      },
      set: function (a) {
        this.data.angularVelocity = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "damping", {
      get: function () {
        return this.data.damping;
      },
      set: function (a) {
        this.data.damping = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "fixedRotation", {
      get: function () {
        return this.data.fixedRotation;
      },
      set: function (a) {
        if (a !== this.data.fixedRotation) {
          this.data.fixedRotation = a;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "inertia", {
      get: function () {
        return this.data.inertia;
      },
      set: function (a) {
        this.data.inertia = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "mass", {
      get: function () {
        return this.data.mass;
      },
      set: function (a) {
        if (a !== this.data.mass) {
          this.data.mass = a;
          this.data.updateMassProperties();
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "motionState", {
      get: function () {
        return this.data.type;
      },
      set: function (a) {
        if (a !== this.data.type) {
          this.data.type = a;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "rotation", {
      get: function () {
        return this.data.angle;
      },
      set: function (a) {
        this.data.angle = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "sleepSpeedLimit", {
      get: function () {
        return this.data.sleepSpeedLimit;
      },
      set: function (a) {
        this.data.sleepSpeedLimit = a;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "x", {
      get: function () {
        return this.world.mpxi(this.data.position[0]);
      },
      set: function (a) {
        this.data.position[0] = this.world.pxmi(a);
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "y", {
      get: function () {
        return this.world.mpxi(this.data.position[1]);
      },
      set: function (a) {
        this.data.position[1] = this.world.pxmi(a);
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "id", {
      get: function () {
        return this.data.id;
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "debug", {
      get: function () {
        return null !== this.debugBody;
      },
      set: function (a) {
        if (a && !this.debugBody) {
          this.debugBody = new b.Physics.P2.BodyDebug(this.game, this.data);
        } else if (!a && this.debugBody) {
          this.debugBody.destroy();
          this.debugBody = null;
        }
      }
    });
    Object.defineProperty(b.Physics.P2.Body.prototype, "collideWorldBounds", {
      get: function () {
        return this._collideWorldBounds;
      },
      set: function (a) {
        if (a && !this._collideWorldBounds) {
          this._collideWorldBounds = true;
          this.updateCollisionMask();
        } else if (!a && this._collideWorldBounds) {
          this._collideWorldBounds = false;
          this.updateCollisionMask();
        }
      }
    });
    b.Physics.P2.BodyDebug = function (a, c, d) {
      b.Group.call(this, a);
      var e = {
        pixelsPerLengthUnit: a.physics.p2.mpx(1),
        debugPolygons: false,
        lineWidth: 1,
        alpha: .5
      };
      this.settings = b.Utils.extend(e, d);
      this.ppu = this.settings.pixelsPerLengthUnit;
      this.ppu = -1 * this.ppu;
      this.body = c;
      this.canvas = new b.Graphics(a);
      this.canvas.alpha = this.settings.alpha;
      this.add(this.canvas);
      this.draw();
      this.updateSpriteTransform();
    };
    b.Physics.P2.BodyDebug.prototype = Object.create(b.Group.prototype);
    b.Physics.P2.BodyDebug.prototype.constructor = b.Physics.P2.BodyDebug;
    b.Utils.extend(b.Physics.P2.BodyDebug.prototype, {
      updateSpriteTransform: function () {
        this.position.x = this.body.position[0] * this.ppu;
        this.position.y = this.body.position[1] * this.ppu;
        this.rotation = this.body.angle;
      },
      draw: function () {
        var a;
        var b;
        var c;
        var d;
        var e;
        var f;
        var g;
        var h;
        var i;
        var j;
        var k;
        var l;
        var m;
        var n;
        var o;
        h = this.body;
        j = this.canvas;
        j.clear();
        c = parseInt(this.randomPastelHex(), 16);
        f = 16711680;
        g = this.lineWidth;
        if (h instanceof p2.Body && h.shapes.length) {
          var p = h.shapes.length;
          for (d = 0; d !== p;) {
            b = h.shapes[d];
            i = b.position || 0;
            a = b.angle || 0;
            if (b instanceof p2.Circle) {
              this.drawCircle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.radius * this.ppu, c, g);
            } else if (b instanceof p2.Capsule) {
              this.drawCapsule(j, i[0] * this.ppu, i[1] * this.ppu, a, b.length * this.ppu, b.radius * this.ppu, 16711680, c, g);
            } else if (b instanceof p2.Plane) {
              this.drawPlane(j, i[0] * this.ppu, -i[1] * this.ppu, c, 16711680, 5 * g, 10 * g, 10 * g, 100 * this.ppu, a);
            } else if (b instanceof p2.Line) {
              this.drawLine(j, b.length * this.ppu, 16711680, g);
            } else if (b instanceof p2.Box) {
              this.drawRectangle(j, i[0] * this.ppu, i[1] * this.ppu, a, b.width * this.ppu, b.height * this.ppu, 16711680, c, g);
            } else if (b instanceof p2.Convex) {
              l = [];
              m = p2.vec2.create();
              e = n = 0;
              for (o = b.vertices.length; 0 <= o ? n < o : n > o; e = 0 <= o ? ++n : --n) {
                k = b.vertices[e];
                p2.vec2.rotate(m, k, a);
                l.push([(m[0] + i[0]) * this.ppu, -(m[1] + i[1]) * this.ppu]);
              }
              this.drawConvex(j, l, b.triangles, 16711680, c, g, this.settings.debugPolygons, [i[0] * this.ppu, -i[1] * this.ppu]);
            }
            d++;
          }
        }
      },
      drawRectangle: function (a, b, c, d, e, f, g, h, i) {
        if (undefined === i) {
          i = 1;
        }
        if (undefined === g) {
          g = 0;
        }
        a.lineStyle(i, g, 1);
        a.beginFill(h);
        a.drawRect(b - e / 2, c - f / 2, e, f);
      },
      drawCircle: function (a, b, c, d, e, f, g) {
        if (undefined === g) {
          g = 1;
        }
        if (undefined === f) {
          f = 16777215;
        }
        a.lineStyle(g, 0, 1);
        a.beginFill(f, 1);
        a.drawCircle(b, c, 2 * -e);
        a.endFill();
        a.moveTo(b, c);
        a.lineTo(b + e * Math.cos(-d), c + e * Math.sin(-d));
      },
      drawLine: function (a, b, c, d) {
        if (undefined === d) {
          d = 1;
        }
        if (undefined === c) {
          c = 0;
        }
        a.lineStyle(5 * d, c, 1);
        a.moveTo(-b / 2, 0);
        a.lineTo(b / 2, 0);
      },
      drawConvex: function (a, b, c, d, e, f, g, h) {
        var i;
        var j;
        var k;
        var l;
        var m;
        var n;
        var o;
        var p;
        var q;
        var r;
        var s;
        if (undefined === f) {
          f = 1;
        }
        if (undefined === d) {
          d = 0;
        }
        if (g) {
          i = [16711680, 65280, 255];
          for (j = 0; j !== b.length + 1;) {
            l = b[j % b.length];
            m = b[(j + 1) % b.length];
            o = l[0];
            r = l[1];
            p = m[0];
            s = m[1];
            a.lineStyle(f, i[j % i.length], 1);
            a.moveTo(o, -r);
            a.lineTo(p, -s);
            a.drawCircle(o, -r, 2 * f);
            j++;
          }
          a.lineStyle(f, 0, 1);
          return a.drawCircle(h[0], h[1], 2 * f);
        }
        a.lineStyle(f, d, 1);
        a.beginFill(e);
        for (j = 0; j !== b.length;) {
          k = b[j];
          n = k[0];
          q = k[1];
          if (0 === j) {
            a.moveTo(n, -q);
          } else {
            a.lineTo(n, -q);
          }
          j++;
        }
        a.endFill();
        if (b.length > 2) {
          a.moveTo(b[b.length - 1][0], -b[b.length - 1][1]);
          return a.lineTo(b[0][0], -b[0][1]);
        }
      },
      drawPath: function (a, b, c, d, e) {
        var g;
        var h;
        var i;
        var j;
        var k;
        var l;
        var m;
        var n;
        var o;
        var p;
        var q;
        var r;
        if (undefined === e) {
          e = 1;
        }
        if (undefined === c) {
          c = 0;
        }
        a.lineStyle(e, c, 1);
        if ("number" == typeof d) {
          a.beginFill(d);
        }
        h = null;
        i = null;
        for (g = 0; g < b.length;) {
          p = b[g];
          q = p[0];
          r = p[1];
          if (!(q === h && r === i)) {
            if (0 === g) {
              a.moveTo(q, r);
            } else {
              j = h;
              k = i;
              l = q;
              m = r;
              n = b[(g + 1) % b.length][0];
              o = b[(g + 1) % b.length][1];
              if (0 !== (q - h) * (o - i) - (n - h) * (r - i)) {
                a.lineTo(q, r);
              }
            }
            h = q;
            i = r;
          }
          g++;
        }
        if ("number" == typeof d) {
          a.endFill();
        }
        if (b.length > 2 && "number" == typeof d) {
          a.moveTo(b[b.length - 1][0], b[b.length - 1][1]);
          a.lineTo(b[0][0], b[0][1]);
        }
      },
      drawPlane: function (a, b, c, d, e, f, g, h, i, j) {
        var l;
        var m;
        if (undefined === f) {
          f = 1;
        }
        if (undefined === d) {
          d = 16777215;
        }
        a.lineStyle(f, e, 11);
        a.beginFill(d);
        a.moveTo(b, -c);
        l = b + Math.cos(j) * this.game.width;
        m = c + Math.sin(j) * this.game.height;
        a.lineTo(l, -m);
        a.moveTo(b, -c);
        l = b + Math.cos(j) * -this.game.width;
        m = c + Math.sin(j) * -this.game.height;
        a.lineTo(l, -m);
      },
      drawCapsule: function (a, b, c, d, e, f, g, h, i) {
        if (undefined === i) {
          i = 1;
        }
        if (undefined === g) {
          g = 0;
        }
        a.lineStyle(i, g, 1);
        var j = Math.cos(d);
        var k = Math.sin(d);
        a.beginFill(h, 1);
        a.drawCircle(-e / 2 * j + b, -e / 2 * k + c, 2 * -f);
        a.drawCircle(e / 2 * j + b, e / 2 * k + c, 2 * -f);
        a.endFill();
        a.lineStyle(i, g, 0);
        a.beginFill(h, 1);
        a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c);
        a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c);
        a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c);
        a.lineTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c);
        a.endFill();
        a.lineStyle(i, g, 1);
        a.moveTo(-e / 2 * j + f * k + b, -e / 2 * k + f * j + c);
        a.lineTo(e / 2 * j + f * k + b, e / 2 * k + f * j + c);
        a.moveTo(-e / 2 * j - f * k + b, -e / 2 * k - f * j + c);
        a.lineTo(e / 2 * j - f * k + b, e / 2 * k - f * j + c);
      },
      randomPastelHex: function () {
        var a;
        var b;
        var c;
        var d;
        c = [255, 255, 255];
        d = Math.floor(256 * Math.random());
        b = Math.floor(256 * Math.random());
        a = Math.floor(256 * Math.random());
        d = Math.floor((d + 3 * c[0]) / 4);
        b = Math.floor((b + 3 * c[1]) / 4);
        a = Math.floor((a + 3 * c[2]) / 4);
        return this.rgbToHex(d, b, a);
      },
      rgbToHex: function (a, b, c) {
        return this.componentToHex(a) + this.componentToHex(b) + this.componentToHex(c);
      },
      componentToHex: function (a) {
        var b;
        b = a.toString(16);
        return 2 === b.length ? b : b + "0";
      }
    });
    b.Physics.P2.Spring = function (a, b, c, d, e, f, g, h, i, j) {
      this.game = a.game;
      this.world = a;
      if (undefined === d) {
        d = 1;
      }
      if (undefined === e) {
        e = 100;
      }
      if (undefined === f) {
        f = 1;
      }
      d = a.pxm(d);
      var k = {
        restLength: d,
        stiffness: e,
        damping: f
      };
      if (undefined !== g && null !== g) {
        k.worldAnchorA = [a.pxm(g[0]), a.pxm(g[1])];
      }
      if (undefined !== h && null !== h) {
        k.worldAnchorB = [a.pxm(h[0]), a.pxm(h[1])];
      }
      if (undefined !== i && null !== i) {
        k.localAnchorA = [a.pxm(i[0]), a.pxm(i[1])];
      }
      if (undefined !== j && null !== j) {
        k.localAnchorB = [a.pxm(j[0]), a.pxm(j[1])];
      }
      this.data = new p2.LinearSpring(b, c, k);
      this.data.parent = this;
    };
    b.Physics.P2.Spring.prototype.constructor = b.Physics.P2.Spring;
    b.Physics.P2.RotationalSpring = function (a, b, c, d, e, f) {
      this.game = a.game;
      this.world = a;
      if (undefined === d) {
        d = null;
      }
      if (undefined === e) {
        e = 100;
      }
      if (undefined === f) {
        f = 1;
      }
      if (d) {
        d = a.pxm(d);
      }
      var g = {
        restAngle: d,
        stiffness: e,
        damping: f
      };
      this.data = new p2.RotationalSpring(b, c, g);
      this.data.parent = this;
    };
    b.Physics.P2.Spring.prototype.constructor = b.Physics.P2.Spring;
    b.Physics.P2.Material = function (a) {
      this.name = a;
      p2.Material.call(this);
    };
    b.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);
    b.Physics.P2.Material.prototype.constructor = b.Physics.P2.Material;
    b.Physics.P2.ContactMaterial = function (a, b, c) {
      p2.ContactMaterial.call(this, a, b, c);
    };
    b.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);
    b.Physics.P2.ContactMaterial.prototype.constructor = b.Physics.P2.ContactMaterial;
    b.Physics.P2.CollisionGroup = function (a) {
      this.mask = a;
    };
    b.Physics.P2.DistanceConstraint = function (a, b, c, d, e, f, g) {
      if (undefined === d) {
        d = 100;
      }
      if (undefined === e) {
        e = [0, 0];
      }
      if (undefined === f) {
        f = [0, 0];
      }
      if (undefined === g) {
        g = Number.MAX_VALUE;
      }
      this.game = a.game;
      this.world = a;
      d = a.pxm(d);
      e = [a.pxmi(e[0]), a.pxmi(e[1])];
      f = [a.pxmi(f[0]), a.pxmi(f[1])];
      var h = {
        distance: d,
        localAnchorA: e,
        localAnchorB: f,
        maxForce: g
      };
      p2.DistanceConstraint.call(this, b, c, h);
    };
    b.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);
    b.Physics.P2.DistanceConstraint.prototype.constructor = b.Physics.P2.DistanceConstraint;
    b.Physics.P2.GearConstraint = function (a, b, c, d, e) {
      if (undefined === d) {
        d = 0;
      }
      if (undefined === e) {
        e = 1;
      }
      this.game = a.game;
      this.world = a;
      var f = {
        angle: d,
        ratio: e
      };
      p2.GearConstraint.call(this, b, c, f);
    };
    b.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);
    b.Physics.P2.GearConstraint.prototype.constructor = b.Physics.P2.GearConstraint;
    b.Physics.P2.LockConstraint = function (a, b, c, d, e, f) {
      if (undefined === d) {
        d = [0, 0];
      }
      if (undefined === e) {
        e = 0;
      }
      if (undefined === f) {
        f = Number.MAX_VALUE;
      }
      this.game = a.game;
      this.world = a;
      d = [a.pxm(d[0]), a.pxm(d[1])];
      var g = {
        localOffsetB: d,
        localAngleB: e,
        maxForce: f
      };
      p2.LockConstraint.call(this, b, c, g);
    };
    b.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);
    b.Physics.P2.LockConstraint.prototype.constructor = b.Physics.P2.LockConstraint;
    b.Physics.P2.PrismaticConstraint = function (a, b, c, d, e, f, g, h) {
      if (undefined === d) {
        d = true;
      }
      if (undefined === e) {
        e = [0, 0];
      }
      if (undefined === f) {
        f = [0, 0];
      }
      if (undefined === g) {
        g = [0, 0];
      }
      if (undefined === h) {
        h = Number.MAX_VALUE;
      }
      this.game = a.game;
      this.world = a;
      e = [a.pxmi(e[0]), a.pxmi(e[1])];
      f = [a.pxmi(f[0]), a.pxmi(f[1])];
      var i = {
        localAnchorA: e,
        localAnchorB: f,
        localAxisA: g,
        maxForce: h,
        disableRotationalLock: !d
      };
      p2.PrismaticConstraint.call(this, b, c, i);
    };
    b.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);
    b.Physics.P2.PrismaticConstraint.prototype.constructor = b.Physics.P2.PrismaticConstraint;
    b.Physics.P2.RevoluteConstraint = function (a, b, c, d, e, f, g) {
      if (undefined === f) {
        f = Number.MAX_VALUE;
      }
      if (undefined === g) {
        g = null;
      }
      this.game = a.game;
      this.world = a;
      c = [a.pxmi(c[0]), a.pxmi(c[1])];
      e = [a.pxmi(e[0]), a.pxmi(e[1])];
      if (g) {
        g = [a.pxmi(g[0]), a.pxmi(g[1])];
      }
      var h = {
        worldPivot: g,
        localPivotA: c,
        localPivotB: e,
        maxForce: f
      };
      p2.RevoluteConstraint.call(this, b, d, h);
    };
    b.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);
    b.Physics.P2.RevoluteConstraint.prototype.constructor = b.Physics.P2.RevoluteConstraint;
    b.ImageCollection = function (a, b, c, d, e, f, g) {
      if (undefined === c || c <= 0) {
        c = 32;
      }
      if (undefined === d || d <= 0) {
        d = 32;
      }
      if (undefined === e) {
        e = 0;
      }
      if (undefined === f) {
        f = 0;
      }
      this.name = a;
      this.firstgid = 0 | b;
      this.imageWidth = 0 | c;
      this.imageHeight = 0 | d;
      this.imageMargin = 0 | e;
      this.imageSpacing = 0 | f;
      this.properties = g || {};
      this.images = [];
      this.total = 0;
    };
    b.ImageCollection.prototype = {
      containsImageIndex: function (a) {
        return a >= this.firstgid && a < this.firstgid + this.total;
      },
      addImage: function (a, b) {
        this.images.push({
          gid: a,
          image: b
        });
        this.total++;
      }
    };
    b.ImageCollection.prototype.constructor = b.ImageCollection;
    b.Tile = function (a, b, c, d, e, f) {
      this.layer = a;
      this.index = b;
      this.x = c;
      this.y = d;
      this.rotation = 0;
      this.flipped = false;
      this.worldX = c * e;
      this.worldY = d * f;
      this.width = e;
      this.height = f;
      this.centerX = Math.abs(e / 2);
      this.centerY = Math.abs(f / 2);
      this.alpha = 1;
      this.properties = {};
      this.scanned = false;
      this.faceTop = false;
      this.faceBottom = false;
      this.faceLeft = false;
      this.faceRight = false;
      this.collideLeft = false;
      this.collideRight = false;
      this.collideUp = false;
      this.collideDown = false;
      this.collisionCallback = null;
      this.collisionCallbackContext = this;
    };
    b.Tile.prototype = {
      containsPoint: function (a, b) {
        return !(a < this.worldX || b < this.worldY || a > this.right || b > this.bottom);
      },
      intersects: function (a, b, c, d) {
        return !(c <= this.worldX) && !(d <= this.worldY) && !(a >= this.worldX + this.width) && !(b >= this.worldY + this.height);
      },
      setCollisionCallback: function (a, b) {
        this.collisionCallback = a;
        this.collisionCallbackContext = b;
      },
      destroy: function () {
        this.collisionCallback = null;
        this.collisionCallbackContext = null;
        this.properties = null;
      },
      setCollision: function (a, b, c, d) {
        this.collideLeft = a;
        this.collideRight = b;
        this.collideUp = c;
        this.collideDown = d;
        this.faceLeft = a;
        this.faceRight = b;
        this.faceTop = c;
        this.faceBottom = d;
      },
      resetCollision: function () {
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.faceTop = false;
        this.faceBottom = false;
        this.faceLeft = false;
        this.faceRight = false;
      },
      isInteresting: function (a, b) {
        return a && b ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : a ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!b && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);
      },
      copy: function (a) {
        this.index = a.index;
        this.alpha = a.alpha;
        this.properties = a.properties;
        this.collideUp = a.collideUp;
        this.collideDown = a.collideDown;
        this.collideLeft = a.collideLeft;
        this.collideRight = a.collideRight;
        this.collisionCallback = a.collisionCallback;
        this.collisionCallbackContext = a.collisionCallbackContext;
      }
    };
    b.Tile.prototype.constructor = b.Tile;
    Object.defineProperty(b.Tile.prototype, "collides", {
      get: function () {
        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown;
      }
    });
    Object.defineProperty(b.Tile.prototype, "canCollide", {
      get: function () {
        return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback;
      }
    });
    Object.defineProperty(b.Tile.prototype, "left", {
      get: function () {
        return this.worldX;
      }
    });
    Object.defineProperty(b.Tile.prototype, "right", {
      get: function () {
        return this.worldX + this.width;
      }
    });
    Object.defineProperty(b.Tile.prototype, "top", {
      get: function () {
        return this.worldY;
      }
    });
    Object.defineProperty(b.Tile.prototype, "bottom", {
      get: function () {
        return this.worldY + this.height;
      }
    });
    b.Tilemap = function (a, c, d, e, f, g) {
      this.game = a;
      this.key = c;
      var h = b.TilemapParser.parse(this.game, c, d, e, f, g);
      if (null !== h) {
        this.width = h.width;
        this.height = h.height;
        this.tileWidth = h.tileWidth;
        this.tileHeight = h.tileHeight;
        this.orientation = h.orientation;
        this.format = h.format;
        this.version = h.version;
        this.properties = h.properties;
        this.widthInPixels = h.widthInPixels;
        this.heightInPixels = h.heightInPixels;
        this.layers = h.layers;
        this.tilesets = h.tilesets;
        this.imagecollections = h.imagecollections;
        this.tiles = h.tiles;
        this.objects = h.objects;
        this.collideIndexes = [];
        this.collision = h.collision;
        this.images = h.images;
        this.enableDebug = false;
        this.currentLayer = 0;
        this.debugMap = [];
        this._results = [];
        this._tempA = 0;
        this._tempB = 0;
      }
    };
    b.Tilemap.CSV = 0;
    b.Tilemap.TILED_JSON = 1;
    b.Tilemap.NORTH = 0;
    b.Tilemap.EAST = 1;
    b.Tilemap.SOUTH = 2;
    b.Tilemap.WEST = 3;
    b.Tilemap.prototype = {
      create: function (a, b, c, d, e, f) {
        if (undefined === f) {
          f = this.game.world;
        }
        this.width = b;
        this.height = c;
        this.setTileSize(d, e);
        this.layers.length = 0;
        return this.createBlankLayer(a, b, c, d, e, f);
      },
      setTileSize: function (a, b) {
        this.tileWidth = a;
        this.tileHeight = b;
        this.widthInPixels = this.width * a;
        this.heightInPixels = this.height * b;
      },
      addTilesetImage: function (a, c, d, e, f, g, h) {
        if (undefined === a) {
          return null;
        }
        if (undefined === d) {
          d = this.tileWidth;
        }
        if (undefined === e) {
          e = this.tileHeight;
        }
        if (undefined === f) {
          f = 0;
        }
        if (undefined === g) {
          g = 0;
        }
        if (undefined === h) {
          h = 0;
        }
        if (0 === d) {
          d = 32;
        }
        if (0 === e) {
          e = 32;
        }
        var i = null;
        if (!(undefined !== a && null !== a)) {
          c = a;
        }
        if (a instanceof b.BitmapData) {
          i = a.canvas;
        } else {
          if (!this.game.cache.checkImageKey(a)) {
            console.warn("Phaser.Tilemap.addTilesetImage: Invalid image key given: \"" + a + "\"");
            return null;
          }
          i = this.game.cache.getImage(a);
        }
        var j = this.getTilesetIndex(a);
        if (null === j && this.format === b.Tilemap.TILED_JSON) {
          console.warn("Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: \"" + a + "\"");
          return null;
        }
        if (this.tilesets[j]) {
          this.tilesets[j].setImage(i);
          return this.tilesets[j];
        }
        var k = new b.Tileset(a, h, d, e, f, g, {});
        k.setImage(i);
        this.tilesets.push(k);
        var l = this.tilesets.length - 1;
        var m = f;
        var n = f;
        var o = 0;
        var p = 0;
        var q = 0;
        for (var r = h; r < h + k.total && (this.tiles[r] = [m, n, l], m += d + g, ++o !== k.total) && (++p !== k.columns || (m = f, n += e + g, p = 0, ++q !== k.rows)); r++) {
          ;
        }
        return k;
      },
      createFromObjects: function (a, c, d, e, f, g, h, i, j) {
        if (undefined === f) {
          f = true;
        }
        if (undefined === g) {
          g = false;
        }
        if (undefined === h) {
          h = this.game.world;
        }
        if (undefined === i) {
          i = b.Sprite;
        }
        if (undefined === j) {
          j = true;
        }
        if (!this.objects[a]) {
          return void console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + a);
        }
        for (var k = 0; k < this.objects[a].length; k++) {
          var l = false;
          var m = this.objects[a][k];
          if (undefined !== m.gid && "number" == typeof c && m.gid === c) {
            l = true;
          } else if (undefined !== m.id && "number" == typeof c && m.id === c) {
            l = true;
          } else if (undefined !== m.name && "string" == typeof c && m.name === c) {
            l = true;
          }
          if (l) {
            var n = new i(this.game, parseFloat(m.x, 10), parseFloat(m.y, 10), d, e);
            n.name = m.name;
            n.visible = m.visible;
            n.autoCull = g;
            n.exists = f;
            if (m.width) {
              n.width = m.width;
            }
            if (m.height) {
              n.height = m.height;
            }
            if (m.rotation) {
              n.angle = m.rotation;
            }
            if (j) {
              n.y -= n.height;
            }
            h.add(n);
            for (var o in m.properties) h.set(n, o, m.properties[o], false, false, 0, true);
          }
        }
      },
      createFromTiles: function (a, c, d, e, f, g) {
        if ("number" == typeof a) {
          a = [a];
        }
        if (undefined === c || null === c) {
          c = [];
        } else if ("number" == typeof c) {
          c = [c];
        }
        e = this.getLayer(e);
        if (undefined === f) {
          f = this.game.world;
        }
        if (undefined === g) {
          g = {};
        }
        if (undefined === g.customClass) {
          g.customClass = b.Sprite;
        }
        if (undefined === g.adjustY) {
          g.adjustY = true;
        }
        var h = this.layers[e].width;
        var i = this.layers[e].height;
        this.copy(0, 0, h, i, e);
        if (this._results.length < 2) {
          return 0;
        }
        var k;
        var j = 0;
        var l = 1;
        for (var m = this._results.length; l < m; l++) {
          if (-1 !== a.indexOf(this._results[l].index)) {
            k = new g.customClass(this.game, this._results[l].worldX, this._results[l].worldY, d);
            for (var n in g) k[n] = g[n];
            f.add(k);
            j++;
          }
        }
        if (1 === c.length) {
          for (l = 0; l < a.length; l++) {
            this.replace(a[l], c[0], 0, 0, h, i, e);
          }
        } else if (c.length > 1) {
          for (l = 0; l < a.length; l++) {
            this.replace(a[l], c[l], 0, 0, h, i, e);
          }
        }
        return j;
      },
      createLayer: function (a, c, d, e) {
        if (undefined === c) {
          c = this.game.width;
        }
        if (undefined === d) {
          d = this.game.height;
        }
        if (undefined === e) {
          e = this.game.world;
        }
        var f = a;
        if ("string" == typeof a) {
          f = this.getLayerIndex(a);
        }
        if (null === f || f > this.layers.length) {
          return void console.warn("Tilemap.createLayer: Invalid layer ID given: " + f);
        }
        if (undefined === c || c <= 0) {
          c = Math.min(this.game.width, this.layers[f].widthInPixels);
        } else if (c > this.game.width) {
          c = this.game.width;
        }
        if (undefined === d || d <= 0) {
          d = Math.min(this.game.height, this.layers[f].heightInPixels);
        } else if (d > this.game.height) {
          d = this.game.height;
        }
        if (this.enableDebug) {
          console.group("Tilemap.createLayer");
          console.log("Name:", this.layers[f].name);
          console.log("Size:", c, "x", d);
          console.log("Tileset:", this.tilesets[0].name, "index:", f);
        }
        var g = e.add(new b.TilemapLayer(this.game, this, f, c, d));
        if (this.enableDebug) {
          console.groupEnd();
        }
        return g;
      },
      createBlankLayer: function (a, c, d, e, f, g) {
        if (undefined === g) {
          g = this.game.world;
        }
        if (null !== this.getLayerIndex(a)) {
          return void console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + a);
        }
        var i;
        var h = {
          name: a,
          x: 0,
          y: 0,
          width: c,
          height: d,
          widthInPixels: c * e,
          heightInPixels: d * f,
          alpha: 1,
          visible: true,
          properties: {},
          indexes: [],
          callbacks: [],
          bodies: [],
          data: null
        };
        var j = [];
        for (var k = 0; k < d; k++) {
          i = [];
          for (var l = 0; l < c; l++) {
            i.push(new b.Tile(h, -1, l, k, e, f));
          }
          j.push(i);
        }
        h.data = j;
        this.layers.push(h);
        this.currentLayer = this.layers.length - 1;
        var m = h.widthInPixels;
        var n = h.heightInPixels;
        if (m > this.game.width) {
          m = this.game.width;
        }
        if (n > this.game.height) {
          n = this.game.height;
        }
        var j = new b.TilemapLayer(this.game, this, this.layers.length - 1, m, n);
        j.name = a;
        return g.add(j);
      },
      getIndex: function (a, b) {
        for (var c = 0; c < a.length; c++) {
          if (a[c].name === b) {
            return c;
          }
        }
        return null;
      },
      getLayerIndex: function (a) {
        return this.getIndex(this.layers, a);
      },
      getTilesetIndex: function (a) {
        return this.getIndex(this.tilesets, a);
      },
      getImageIndex: function (a) {
        return this.getIndex(this.images, a);
      },
      setTileIndexCallback: function (a, b, c, d) {
        d = this.getLayer(d);
        if ("number" == typeof a) {
          this.layers[d].callbacks[a] = {
            callback: b,
            callbackContext: c
          };
        } else {
          var e = 0;
          for (var f = a.length; e < f; e++) {
            this.layers[d].callbacks[a[e]] = {
              callback: b,
              callbackContext: c
            };
          }
        }
      },
      setTileLocationCallback: function (a, b, c, d, e, f, g) {
        g = this.getLayer(g);
        this.copy(a, b, c, d, g);
        if (!(this._results.length < 2)) {
          for (var h = 1; h < this._results.length; h++) {
            this._results[h].setCollisionCallback(e, f);
          }
        }
      },
      setCollision: function (a, b, c, d) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === d) {
          d = true;
        }
        c = this.getLayer(c);
        if ("number" == typeof a) {
          return this.setCollisionByIndex(a, b, c, true);
        }
        if (Array.isArray(a)) {
          for (var e = 0; e < a.length; e++) {
            this.setCollisionByIndex(a[e], b, c, false);
          }
          if (d) {
            this.calculateFaces(c);
          }
        }
      },
      setCollisionBetween: function (a, b, c, d, e) {
        if (undefined === c) {
          c = true;
        }
        if (undefined === e) {
          e = true;
        }
        d = this.getLayer(d);
        if (!(a > b)) {
          for (var f = a; f <= b; f++) {
            this.setCollisionByIndex(f, c, d, false);
          }
          if (e) {
            this.calculateFaces(d);
          }
        }
      },
      setCollisionByExclusion: function (a, b, c, d) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === d) {
          d = true;
        }
        c = this.getLayer(c);
        var e = 0;
        for (var f = this.tiles.length; e < f; e++) {
          if (-1 === a.indexOf(e)) {
            this.setCollisionByIndex(e, b, c, false);
          }
        }
        if (d) {
          this.calculateFaces(c);
        }
      },
      setCollisionByIndex: function (a, b, c, d) {
        if (undefined === b) {
          b = true;
        }
        if (undefined === c) {
          c = this.currentLayer;
        }
        if (undefined === d) {
          d = true;
        }
        if (b) {
          this.collideIndexes.push(a);
        } else {
          var e = this.collideIndexes.indexOf(a);
          if (e > -1) {
            this.collideIndexes.splice(e, 1);
          }
        }
        for (var f = 0; f < this.layers[c].height; f++) {
          for (var g = 0; g < this.layers[c].width; g++) {
            var h = this.layers[c].data[f][g];
            if (h && h.index === a) {
              if (b) {
                h.setCollision(true, true, true, true);
              } else {
                h.resetCollision();
              }
              h.faceTop = b;
              h.faceBottom = b;
              h.faceLeft = b;
              h.faceRight = b;
            }
          }
        }
        if (d) {
          this.calculateFaces(c);
        }
        return c;
      },
      getLayer: function (a) {
        if (undefined === a) {
          a = this.currentLayer;
        } else if ("string" == typeof a) {
          a = this.getLayerIndex(a);
        } else if (a instanceof b.TilemapLayer) {
          a = a.index;
        }
        return a;
      },
      setPreventRecalculate: function (a) {
        if (true === a && true !== this.preventingRecalculate) {
          this.preventingRecalculate = true;
          this.needToRecalculate = {};
        }
        if (false === a && true === this.preventingRecalculate) {
          this.preventingRecalculate = false;
          for (var b in this.needToRecalculate) this.calculateFaces(b);
          this.needToRecalculate = false;
        }
      },
      calculateFaces: function (a) {
        if (this.preventingRecalculate) {
          return void (this.needToRecalculate[a] = true);
        }
        var b = null;
        var c = null;
        var d = null;
        var e = null;
        var f = 0;
        for (var g = this.layers[a].height; f < g; f++) {
          var h = 0;
          for (var i = this.layers[a].width; h < i; h++) {
            var j = this.layers[a].data[f][h];
            if (j) {
              b = this.getTileAbove(a, h, f);
              c = this.getTileBelow(a, h, f);
              d = this.getTileLeft(a, h, f);
              e = this.getTileRight(a, h, f);
              if (j.collides) {
                j.faceTop = true;
                j.faceBottom = true;
                j.faceLeft = true;
                j.faceRight = true;
              }
              if (b && b.collides) {
                j.faceTop = false;
              }
              if (c && c.collides) {
                j.faceBottom = false;
              }
              if (d && d.collides) {
                j.faceLeft = false;
              }
              if (e && e.collides) {
                j.faceRight = false;
              }
            }
          }
        }
      },
      getTileAbove: function (a, b, c) {
        return c > 0 ? this.layers[a].data[c - 1][b] : null;
      },
      getTileBelow: function (a, b, c) {
        return c < this.layers[a].height - 1 ? this.layers[a].data[c + 1][b] : null;
      },
      getTileLeft: function (a, b, c) {
        return b > 0 ? this.layers[a].data[c][b - 1] : null;
      },
      getTileRight: function (a, b, c) {
        return b < this.layers[a].width - 1 ? this.layers[a].data[c][b + 1] : null;
      },
      setLayer: function (a) {
        a = this.getLayer(a);
        if (this.layers[a]) {
          this.currentLayer = a;
        }
      },
      hasTile: function (a, b, c) {
        c = this.getLayer(c);
        return undefined !== this.layers[c].data[b] && undefined !== this.layers[c].data[b][a] && this.layers[c].data[b][a].index > -1;
      },
      removeTile: function (a, c, d) {
        d = this.getLayer(d);
        if (a >= 0 && a < this.layers[d].width && c >= 0 && c < this.layers[d].height && this.hasTile(a, c, d)) {
          var e = this.layers[d].data[c][a];
          this.layers[d].data[c][a] = new b.Tile(this.layers[d], -1, a, c, this.tileWidth, this.tileHeight);
          this.layers[d].dirty = true;
          this.calculateFaces(d);
          return e;
        }
      },
      removeTileWorldXY: function (a, b, c, d, e) {
        e = this.getLayer(e);
        a = this.game.math.snapToFloor(a, c) / c;
        b = this.game.math.snapToFloor(b, d) / d;
        return this.removeTile(a, b, e);
      },
      putTile: function (a, c, d, e) {
        if (null === a) {
          return this.removeTile(c, d, e);
        }
        e = this.getLayer(e);
        if (c >= 0 && c < this.layers[e].width && d >= 0 && d < this.layers[e].height) {
          var f;
          if (a instanceof b.Tile) {
            f = a.index;
            if (this.hasTile(c, d, e)) {
              this.layers[e].data[d][c].copy(a);
            } else {
              this.layers[e].data[d][c] = new b.Tile(e, f, c, d, a.width, a.height);
            }
          } else {
            f = a;
            if (this.hasTile(c, d, e)) {
              this.layers[e].data[d][c].index = f;
            } else {
              this.layers[e].data[d][c] = new b.Tile(this.layers[e], f, c, d, this.tileWidth, this.tileHeight);
            }
          }
          if (this.collideIndexes.indexOf(f) > -1) {
            this.layers[e].data[d][c].setCollision(true, true, true, true);
          } else {
            this.layers[e].data[d][c].resetCollision();
          }
          this.layers[e].dirty = true;
          this.calculateFaces(e);
          return this.layers[e].data[d][c];
        }
        return null;
      },
      putTileWorldXY: function (a, b, c, d, e, f) {
        f = this.getLayer(f);
        b = this.game.math.snapToFloor(b, d) / d;
        c = this.game.math.snapToFloor(c, e) / e;
        return this.putTile(a, b, c, f);
      },
      searchTileIndex: function (a, b, c, d) {
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = false;
        }
        d = this.getLayer(d);
        var e = 0;
        if (c) {
          for (var f = this.layers[d].height - 1; f >= 0; f--) {
            for (var g = this.layers[d].width - 1; g >= 0; g--) {
              if (this.layers[d].data[f][g].index === a) {
                if (e === b) {
                  return this.layers[d].data[f][g];
                }
                e++;
              }
            }
          }
        } else {
          for (var f = 0; f < this.layers[d].height; f++) {
            for (var g = 0; g < this.layers[d].width; g++) {
              if (this.layers[d].data[f][g].index === a) {
                if (e === b) {
                  return this.layers[d].data[f][g];
                }
                e++;
              }
            }
          }
        }
        return null;
      },
      getTile: function (a, b, c, d) {
        if (undefined === d) {
          d = false;
        }
        c = this.getLayer(c);
        return a >= 0 && a < this.layers[c].width && b >= 0 && b < this.layers[c].height ? -1 === this.layers[c].data[b][a].index ? d ? this.layers[c].data[b][a] : null : this.layers[c].data[b][a] : null;
      },
      getTileWorldXY: function (a, b, c, d, e, f) {
        if (undefined === c) {
          c = this.tileWidth;
        }
        if (undefined === d) {
          d = this.tileHeight;
        }
        e = this.getLayer(e);
        a = this.game.math.snapToFloor(a, c) / c;
        b = this.game.math.snapToFloor(b, d) / d;
        return this.getTile(a, b, e, f);
      },
      copy: function (a, b, c, d, e) {
        e = this.getLayer(e);
        if (!this.layers[e]) {
          return void (this._results.length = 0);
        }
        if (undefined === a) {
          a = 0;
        }
        if (undefined === b) {
          b = 0;
        }
        if (undefined === c) {
          c = this.layers[e].width;
        }
        if (undefined === d) {
          d = this.layers[e].height;
        }
        if (a < 0) {
          a = 0;
        }
        if (b < 0) {
          b = 0;
        }
        if (c > this.layers[e].width) {
          c = this.layers[e].width;
        }
        if (d > this.layers[e].height) {
          d = this.layers[e].height;
        }
        this._results.length = 0;
        this._results.push({
          x: a,
          y: b,
          width: c,
          height: d,
          layer: e
        });
        for (var f = b; f < b + d; f++) {
          for (var g = a; g < a + c; g++) {
            this._results.push(this.layers[e].data[f][g]);
          }
        }
        return this._results;
      },
      paste: function (a, b, c, d) {
        if (undefined === a) {
          a = 0;
        }
        if (undefined === b) {
          b = 0;
        }
        d = this.getLayer(d);
        if (c && !(c.length < 2)) {
          var e = a - c[1].x;
          var f = b - c[1].y;
          for (var g = 1; g < c.length; g++) {
            this.layers[d].data[f + c[g].y][e + c[g].x].copy(c[g]);
          }
          this.layers[d].dirty = true;
          this.calculateFaces(d);
        }
      },
      swap: function (a, b, c, d, e, f, g) {
        g = this.getLayer(g);
        this.copy(c, d, e, f, g);
        if (!(this._results.length < 2)) {
          this._tempA = a;
          this._tempB = b;
          this._results.forEach(this.swapHandler, this);
          this.paste(c, d, this._results, g);
        }
      },
      swapHandler: function (a) {
        if (a.index === this._tempA) {
          a.index = this._tempB;
        } else if (a.index === this._tempB) {
          a.index = this._tempA;
        }
      },
      forEach: function (a, b, c, d, e, f, g) {
        g = this.getLayer(g);
        this.copy(c, d, e, f, g);
        if (!(this._results.length < 2)) {
          this._results.forEach(a, b);
          this.paste(c, d, this._results, g);
        }
      },
      replace: function (a, b, c, d, e, f, g) {
        g = this.getLayer(g);
        this.copy(c, d, e, f, g);
        if (!(this._results.length < 2)) {
          for (var h = 1; h < this._results.length; h++) {
            if (this._results[h].index === a) {
              this._results[h].index = b;
            }
          }
          this.paste(c, d, this._results, g);
        }
      },
      random: function (a, b, c, d, e) {
        e = this.getLayer(e);
        this.copy(a, b, c, d, e);
        if (!(this._results.length < 2)) {
          var f = [];
          for (var g = 1; g < this._results.length; g++) {
            if (this._results[g].index) {
              var h = this._results[g].index;
              if (-1 === f.indexOf(h)) {
                f.push(h);
              }
            }
          }
          for (var i = 1; i < this._results.length; i++) {
            this._results[i].index = this.game.rnd.pick(f);
          }
          this.paste(a, b, this._results, e);
        }
      },
      shuffle: function (a, c, d, e, f) {
        f = this.getLayer(f);
        this.copy(a, c, d, e, f);
        if (!(this._results.length < 2)) {
          var g = [];
          for (var h = 1; h < this._results.length; h++) {
            if (this._results[h].index) {
              g.push(this._results[h].index);
            }
          }
          b.ArrayUtils.shuffle(g);
          for (var i = 1; i < this._results.length; i++) {
            this._results[i].index = g[i - 1];
          }
          this.paste(a, c, this._results, f);
        }
      },
      fill: function (a, b, c, d, e, f) {
        f = this.getLayer(f);
        this.copy(b, c, d, e, f);
        if (!(this._results.length < 2)) {
          for (var g = 1; g < this._results.length; g++) {
            this._results[g].index = a;
          }
          this.paste(b, c, this._results, f);
        }
      },
      removeAllLayers: function () {
        this.layers.length = 0;
        this.currentLayer = 0;
      },
      dump: function () {
        var a = "";
        var b = [""];
        for (var c = 0; c < this.layers[this.currentLayer].height; c++) {
          for (var d = 0; d < this.layers[this.currentLayer].width; d++) {
            a += "%c  ";
            if (this.layers[this.currentLayer].data[c][d] > 1) {
              if (this.debugMap[this.layers[this.currentLayer].data[c][d]]) {
                b.push("background: " + this.debugMap[this.layers[this.currentLayer].data[c][d]]);
              } else {
                b.push("background: #ffffff");
              }
            } else {
              b.push("background: rgb(0, 0, 0)");
            }
          }
          a += "\n";
        }
        b[0] = a;
        console.log.apply(console, b);
      },
      destroy: function () {
        this.removeAllLayers();
        this.data = [];
        this.game = null;
      }
    };
    b.Tilemap.prototype.constructor = b.Tilemap;
    Object.defineProperty(b.Tilemap.prototype, "layer", {
      get: function () {
        return this.layers[this.currentLayer];
      },
      set: function (a) {
        if (a !== this.currentLayer) {
          this.setLayer(a);
        }
      }
    });
    b.TilemapLayer = function (a, c, d, e, f) {
      e |= 0;
      f |= 0;
      b.Sprite.call(this, a, 0, 0);
      this.map = c;
      this.index = d;
      this.layer = c.layers[d];
      this.canvas = PIXI.CanvasPool.create(this, e, f);
      this.context = this.canvas.getContext("2d");
      this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas)));
      this.type = b.TILEMAPLAYER;
      this.physicsType = b.TILEMAPLAYER;
      this.renderSettings = {
        enableScrollDelta: false,
        overdrawRatio: .2,
        copyCanvas: null
      };
      this.debug = false;
      this.exists = true;
      this.debugSettings = {
        missingImageFill: "rgb(255,255,255)",
        debuggedTileOverfill: "rgba(0,255,0,0.4)",
        forceFullRedraw: true,
        debugAlpha: .5,
        facingEdgeStroke: "rgba(0,255,0,1)",
        collidingTileOverfill: "rgba(0,255,0,0.2)"
      };
      this.scrollFactorX = 1;
      this.scrollFactorY = 1;
      this.dirty = true;
      this.rayStepRate = 4;
      this._wrap = false;
      this._mc = {
        scrollX: 0,
        scrollY: 0,
        renderWidth: 0,
        renderHeight: 0,
        tileWidth: c.tileWidth,
        tileHeight: c.tileHeight,
        cw: c.tileWidth,
        ch: c.tileHeight,
        tilesets: []
      };
      this._scrollX = 0;
      this._scrollY = 0;
      this._results = [];
      if (!a.device.canvasBitBltShift) {
        this.renderSettings.copyCanvas = b.TilemapLayer.ensureSharedCopyCanvas();
      }
      this.fixedToCamera = true;
    };
    b.TilemapLayer.prototype = Object.create(b.Sprite.prototype);
    b.TilemapLayer.prototype.constructor = b.TilemapLayer;
    b.TilemapLayer.prototype.preUpdateCore = b.Component.Core.preUpdate;
    b.TilemapLayer.sharedCopyCanvas = null;
    b.TilemapLayer.ensureSharedCopyCanvas = function () {
      if (!this.sharedCopyCanvas) {
        this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2);
      }
      return this.sharedCopyCanvas;
    };
    b.TilemapLayer.prototype.preUpdate = function () {
      return this.preUpdateCore();
    };
    b.TilemapLayer.prototype.postUpdate = function () {
      if (this.fixedToCamera) {
        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
      }
      this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x;
      this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y;
    };
    b.TilemapLayer.prototype._renderCanvas = function (a) {
      if (this.fixedToCamera) {
        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
      }
      this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x;
      this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y;
      this.render();
      PIXI.Sprite.prototype._renderCanvas.call(this, a);
    };
    b.TilemapLayer.prototype._renderWebGL = function (a) {
      if (this.fixedToCamera) {
        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;
        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
      }
      this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x;
      this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y;
      this.render();
      PIXI.Sprite.prototype._renderWebGL.call(this, a);
    };
    b.TilemapLayer.prototype.destroy = function () {
      PIXI.CanvasPool.remove(this);
      b.Component.Destroy.prototype.destroy.call(this);
    };
    b.TilemapLayer.prototype.resize = function (a, b) {
      this.canvas.width = a;
      this.canvas.height = b;
      this.texture.frame.resize(a, b);
      this.texture.width = a;
      this.texture.height = b;
      this.texture.crop.width = a;
      this.texture.crop.height = b;
      this.texture.baseTexture.width = a;
      this.texture.baseTexture.height = b;
      this.texture.baseTexture.dirty();
      this.texture.requiresUpdate = true;
      this.texture._updateUvs();
      this.dirty = true;
    };
    b.TilemapLayer.prototype.resizeWorld = function () {
      this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y);
    };
    b.TilemapLayer.prototype._fixX = function (a) {
      return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? a : 0 === this.scrollFactorX && 0 !== this.position.x ? a - this.position.x : this._scrollX + (a - this._scrollX / this.scrollFactorX);
    };
    b.TilemapLayer.prototype._unfixX = function (a) {
      return 1 === this.scrollFactorX ? a : this._scrollX / this.scrollFactorX + (a - this._scrollX);
    };
    b.TilemapLayer.prototype._fixY = function (a) {
      return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? a : 0 === this.scrollFactorY && 0 !== this.position.y ? a - this.position.y : this._scrollY + (a - this._scrollY / this.scrollFactorY);
    };
    b.TilemapLayer.prototype._unfixY = function (a) {
      return 1 === this.scrollFactorY ? a : this._scrollY / this.scrollFactorY + (a - this._scrollY);
    };
    b.TilemapLayer.prototype.getTileX = function (a) {
      return Math.floor(this._fixX(a) / this._mc.tileWidth);
    };
    b.TilemapLayer.prototype.getTileY = function (a) {
      return Math.floor(this._fixY(a) / this._mc.tileHeight);
    };
    b.TilemapLayer.prototype.getTileXY = function (a, b, c) {
      c.x = this.getTileX(a);
      c.y = this.getTileY(b);
      return c;
    };
    b.TilemapLayer.prototype.getRayCastTiles = function (a, b, c, d) {
      if (!b) {
        b = this.rayStepRate;
      }
      if (undefined === c) {
        c = false;
      }
      if (undefined === d) {
        d = false;
      }
      var e = this.getTiles(a.x, a.y, a.width, a.height, c, d);
      if (0 === e.length) {
        return [];
      }
      var f = a.coordinatesOnLine(b);
      var g = [];
      for (var h = 0; h < e.length; h++) {
        for (var i = 0; i < f.length; i++) {
          var j = e[h];
          var k = f[i];
          if (j.containsPoint(k[0], k[1])) {
            g.push(j);
            break;
          }
        }
      }
      return g;
    };
    b.TilemapLayer.prototype.getTiles = function (a, b, c, d, e, f) {
      if (undefined === e) {
        e = false;
      }
      if (undefined === f) {
        f = false;
      }
      var g = !(e || f);
      a = this._fixX(a);
      b = this._fixY(b);
      var h = Math.floor(a / (this._mc.cw * this.scale.x));
      var i = Math.floor(b / (this._mc.ch * this.scale.y));
      var j = Math.ceil((a + c) / (this._mc.cw * this.scale.x)) - h;
      for (var k = Math.ceil((b + d) / (this._mc.ch * this.scale.y)) - i; this._results.length;) {
        this._results.pop();
      }
      for (var l = i; l < i + k; l++) {
        for (var m = h; m < h + j; m++) {
          var n = this.layer.data[l];
          if (n && n[m] && (g || n[m].isInteresting(e, f))) {
            this._results.push(n[m]);
          }
        }
      }
      return this._results.slice();
    };
    b.TilemapLayer.prototype.resolveTileset = function (a) {
      var b = this._mc.tilesets;
      if (a < 2e3) {
        for (; b.length < a;) {
          b.push(undefined);
        }
      }
      var c = this.map.tiles[a] && this.map.tiles[a][2];
      if (null !== c) {
        var d = this.map.tilesets[c];
        if (d && d.containsTileIndex(a)) {
          return b[a] = d;
        }
      }
      return b[a] = null;
    };
    b.TilemapLayer.prototype.resetTilesetCache = function () {
      for (var a = this._mc.tilesets; a.length;) {
        a.pop();
      }
    };
    b.TilemapLayer.prototype.setScale = function (a, b) {
      a = a || 1;
      b = b || a;
      for (var c = 0; c < this.layer.data.length; c++) {
        var d = this.layer.data[c];
        for (var e = 0; e < d.length; e++) {
          var f = d[e];
          f.width = this.map.tileWidth * a;
          f.height = this.map.tileHeight * b;
          f.worldX = f.x * f.width;
          f.worldY = f.y * f.height;
        }
      }
      this.scale.setTo(a, b);
    };
    b.TilemapLayer.prototype.shiftCanvas = function (a, b, c) {
      var d = a.canvas;
      var e = d.width - Math.abs(b);
      var f = d.height - Math.abs(c);
      var g = 0;
      var h = 0;
      var i = b;
      var j = c;
      if (b < 0) {
        g = -b;
        i = 0;
      }
      if (c < 0) {
        h = -c;
        j = 0;
      }
      var k = this.renderSettings.copyCanvas;
      if (k) {
        if (k.width < e || k.height < f) {
          k.width = e;
          k.height = f;
        }
        var l = k.getContext("2d");
        l.clearRect(0, 0, e, f);
        l.drawImage(d, g, h, e, f, 0, 0, e, f);
        a.clearRect(i, j, e, f);
        a.drawImage(k, 0, 0, e, f, i, j, e, f);
      } else {
        a.save();
        a.globalCompositeOperation = "copy";
        a.drawImage(d, g, h, e, f, i, j, e, f);
        a.restore();
      }
    };
    b.TilemapLayer.prototype.renderRegion = function (a, b, c, d, e, f) {
      var g = this.context;
      var h = this.layer.width;
      var i = this.layer.height;
      var j = this._mc.tileWidth;
      var k = this._mc.tileHeight;
      var l = this._mc.tilesets;
      var m = NaN;
      if (!this._wrap) {
        if (c <= e) {
          c = Math.max(0, c);
          e = Math.min(h - 1, e);
        }
        if (d <= f) {
          d = Math.max(0, d);
          f = Math.min(i - 1, f);
        }
      }
      var r;
      var s;
      var t;
      var u;
      var v;
      var w;
      var n = c * j - a;
      var o = d * k - b;
      var p = (c + 1048576 * h) % h;
      var q = (d + 1048576 * i) % i;
      u = q;
      w = f - d;
      for (s = o; w >= 0; u++, w--, s += k) {
        if (u >= i) {
          u -= i;
        }
        var x = this.layer.data[u];
        t = p;
        v = e - c;
        for (r = n; v >= 0; t++, v--, r += j) {
          if (t >= h) {
            t -= h;
          }
          var y = x[t];
          if (y && !(y.index < 0)) {
            var z = y.index;
            var A = l[z];
            if (undefined === A) {
              A = this.resolveTileset(z);
            }
            if (!(y.alpha === m || this.debug)) {
              g.globalAlpha = y.alpha;
              m = y.alpha;
            }
            if (A) {
              if (y.rotation || y.flipped) {
                g.save();
                g.translate(r + y.centerX, s + y.centerY);
                g.rotate(y.rotation);
                if (y.flipped) {
                  g.scale(-1, 1);
                }
                A.draw(g, -y.centerX, -y.centerY, z);
                g.restore();
              } else {
                A.draw(g, r, s, z);
              }
            } else if (this.debugSettings.missingImageFill) {
              g.fillStyle = this.debugSettings.missingImageFill;
              g.fillRect(r, s, j, k);
            }
            if (y.debug && this.debugSettings.debuggedTileOverfill) {
              g.fillStyle = this.debugSettings.debuggedTileOverfill;
              g.fillRect(r, s, j, k);
            }
          }
        }
      }
    };
    b.TilemapLayer.prototype.renderDeltaScroll = function (a, b) {
      var c = this._mc.scrollX;
      var d = this._mc.scrollY;
      var e = this.canvas.width;
      var f = this.canvas.height;
      var g = this._mc.tileWidth;
      var h = this._mc.tileHeight;
      var i = 0;
      var j = -g;
      var k = 0;
      var l = -h;
      if (a < 0) {
        i = e + a;
        j = e - 1;
      } else if (a > 0) {
        j = a;
      }
      if (b < 0) {
        k = f + b;
        l = f - 1;
      } else if (b > 0) {
        l = b;
      }
      this.shiftCanvas(this.context, a, b);
      i = Math.floor((i + c) / g);
      j = Math.floor((j + c) / g);
      k = Math.floor((k + d) / h);
      l = Math.floor((l + d) / h);
      if (i <= j) {
        this.context.clearRect(i * g - c, 0, (j - i + 1) * g, f);
        var m = Math.floor((0 + d) / h);
        var n = Math.floor((f - 1 + d) / h);
        this.renderRegion(c, d, i, m, j, n);
      }
      if (k <= l) {
        this.context.clearRect(0, k * h - d, e, (l - k + 1) * h);
        var o = Math.floor((0 + c) / g);
        var p = Math.floor((e - 1 + c) / g);
        this.renderRegion(c, d, o, k, p, l);
      }
    };
    b.TilemapLayer.prototype.renderFull = function () {
      var a = this._mc.scrollX;
      var b = this._mc.scrollY;
      var c = this.canvas.width;
      var d = this.canvas.height;
      var e = this._mc.tileWidth;
      var f = this._mc.tileHeight;
      var g = Math.floor(a / e);
      var h = Math.floor((c - 1 + a) / e);
      var i = Math.floor(b / f);
      var j = Math.floor((d - 1 + b) / f);
      this.context.clearRect(0, 0, c, d);
      this.renderRegion(a, b, g, i, h, j);
    };
    b.TilemapLayer.prototype.render = function () {
      var a = false;
      if (this.visible) {
        if (this.dirty || this.layer.dirty) {
          this.layer.dirty = false;
          a = true;
        }
        var b = this.canvas.width;
        var c = this.canvas.height;
        var d = 0 | this._scrollX;
        var e = 0 | this._scrollY;
        var f = this._mc;
        var g = f.scrollX - d;
        var h = f.scrollY - e;
        if (a || 0 !== g || 0 !== h || f.renderWidth !== b || f.renderHeight !== c) {
          this.context.save();
          f.scrollX = d;
          f.scrollY = e;
          if (!(f.renderWidth === b && f.renderHeight === c)) {
            f.renderWidth = b;
            f.renderHeight = c;
          }
          if (this.debug) {
            this.context.globalAlpha = this.debugSettings.debugAlpha;
            if (this.debugSettings.forceFullRedraw) {
              a = true;
            }
          }
          if (!a && this.renderSettings.enableScrollDelta && Math.abs(g) + Math.abs(h) < Math.min(b, c)) {
            this.renderDeltaScroll(g, h);
          } else {
            this.renderFull();
          }
          if (this.debug) {
            this.context.globalAlpha = 1;
            this.renderDebug();
          }
          this.texture.baseTexture.dirty();
          this.dirty = false;
          this.context.restore();
          return true;
        }
      }
    };
    b.TilemapLayer.prototype.renderDebug = function () {
      var r;
      var s;
      var t;
      var u;
      var v;
      var w;
      var a = this._mc.scrollX;
      var b = this._mc.scrollY;
      var c = this.context;
      var d = this.canvas.width;
      var e = this.canvas.height;
      var f = this.layer.width;
      var g = this.layer.height;
      var h = this._mc.tileWidth;
      var i = this._mc.tileHeight;
      var j = Math.floor(a / h);
      var k = Math.floor((d - 1 + a) / h);
      var l = Math.floor(b / i);
      var m = Math.floor((e - 1 + b) / i);
      var n = j * h - a;
      var o = l * i - b;
      var p = (j + 1048576 * f) % f;
      var q = (l + 1048576 * g) % g;
      c.strokeStyle = this.debugSettings.facingEdgeStroke;
      u = q;
      w = m - l;
      for (s = o; w >= 0; u++, w--, s += i) {
        if (u >= g) {
          u -= g;
        }
        var x = this.layer.data[u];
        t = p;
        v = k - j;
        for (r = n; v >= 0; t++, v--, r += h) {
          if (t >= f) {
            t -= f;
          }
          var y = x[t];
          if (!(!y || y.index < 0 || !y.collides)) {
            if (this.debugSettings.collidingTileOverfill) {
              c.fillStyle = this.debugSettings.collidingTileOverfill;
              c.fillRect(r, s, this._mc.cw, this._mc.ch);
            }
            if (this.debugSettings.facingEdgeStroke) {
              c.beginPath();
              if (y.faceTop) {
                c.moveTo(r, s);
                c.lineTo(r + this._mc.cw, s);
              }
              if (y.faceBottom) {
                c.moveTo(r, s + this._mc.ch);
                c.lineTo(r + this._mc.cw, s + this._mc.ch);
              }
              if (y.faceLeft) {
                c.moveTo(r, s);
                c.lineTo(r, s + this._mc.ch);
              }
              if (y.faceRight) {
                c.moveTo(r + this._mc.cw, s);
                c.lineTo(r + this._mc.cw, s + this._mc.ch);
              }
              c.closePath();
              c.stroke();
            }
          }
        }
      }
    };
    Object.defineProperty(b.TilemapLayer.prototype, "wrap", {
      get: function () {
        return this._wrap;
      },
      set: function (a) {
        this._wrap = a;
        this.dirty = true;
      }
    });
    Object.defineProperty(b.TilemapLayer.prototype, "scrollX", {
      get: function () {
        return this._scrollX;
      },
      set: function (a) {
        this._scrollX = a;
      }
    });
    Object.defineProperty(b.TilemapLayer.prototype, "scrollY", {
      get: function () {
        return this._scrollY;
      },
      set: function (a) {
        this._scrollY = a;
      }
    });
    Object.defineProperty(b.TilemapLayer.prototype, "collisionWidth", {
      get: function () {
        return this._mc.cw;
      },
      set: function (a) {
        this._mc.cw = 0 | a;
        this.dirty = true;
      }
    });
    Object.defineProperty(b.TilemapLayer.prototype, "collisionHeight", {
      get: function () {
        return this._mc.ch;
      },
      set: function (a) {
        this._mc.ch = 0 | a;
        this.dirty = true;
      }
    });
    b.TilemapParser = {
      INSERT_NULL: false,
      parse: function (a, c, d, e, f, g) {
        if (undefined === d) {
          d = 32;
        }
        if (undefined === e) {
          e = 32;
        }
        if (undefined === f) {
          f = 10;
        }
        if (undefined === g) {
          g = 10;
        }
        if (undefined === c) {
          return this.getEmptyData();
        }
        if (null === c) {
          return this.getEmptyData(d, e, f, g);
        }
        var h = a.cache.getTilemapData(c);
        if (h) {
          if (h.format === b.Tilemap.CSV) {
            return this.parseCSV(c, h.data, d, e);
          }
          if (!h.format || h.format === b.Tilemap.TILED_JSON) {
            return this.parseTiledJSON(h.data);
          }
        } else {
          console.warn("Phaser.TilemapParser.parse - No map data found for key " + c);
        }
      },
      parseCSV: function (a, c, d, e) {
        var f = this.getEmptyData();
        c = c.trim();
        var g = [];
        var h = c.split("\n");
        var i = h.length;
        var j = 0;
        for (var k = 0; k < h.length; k++) {
          g[k] = [];
          var l = h[k].split(",");
          for (var m = 0; m < l.length; m++) {
            g[k][m] = new b.Tile(f.layers[0], parseInt(l[m], 10), m, k, d, e);
          }
          if (0 === j) {
            j = l.length;
          }
        }
        f.format = b.Tilemap.CSV;
        f.name = a;
        f.width = j;
        f.height = i;
        f.tileWidth = d;
        f.tileHeight = e;
        f.widthInPixels = j * d;
        f.heightInPixels = i * e;
        f.layers[0].width = j;
        f.layers[0].height = i;
        f.layers[0].widthInPixels = f.widthInPixels;
        f.layers[0].heightInPixels = f.heightInPixels;
        f.layers[0].data = g;
        return f;
      },
      getEmptyData: function (a, b, c, d) {
        return {
          width: undefined !== c && null !== c ? c : 0,
          height: undefined !== d && null !== d ? d : 0,
          tileWidth: undefined !== a && null !== a ? a : 0,
          tileHeight: undefined !== b && null !== b ? b : 0,
          orientation: "orthogonal",
          version: "1",
          properties: {},
          widthInPixels: 0,
          heightInPixels: 0,
          layers: [{
            name: "layer",
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            widthInPixels: 0,
            heightInPixels: 0,
            alpha: 1,
            visible: true,
            properties: {},
            indexes: [],
            callbacks: [],
            bodies: [],
            data: []
          }],
          images: [],
          objects: {},
          collision: {},
          tilesets: [],
          tiles: []
        };
      },
      parseTiledJSON: function (a) {
        function G(a, b) {
          var c = {};
          for (var d in b) {
            var e = b[d];
            if (undefined !== a[e]) {
              c[e] = a[e];
            }
          }
          return c;
        }
        if ("orthogonal" !== a.orientation) {
          console.warn("TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser");
          return null;
        }
        var c = {
          width: a.width,
          height: a.height,
          tileWidth: a.tilewidth,
          tileHeight: a.tileheight,
          orientation: a.orientation,
          format: b.Tilemap.TILED_JSON,
          version: a.version,
          properties: a.properties,
          widthInPixels: a.width * a.tilewidth,
          heightInPixels: a.height * a.tileheight
        };
        var d = [];
        for (var e = 0; e < a.layers.length; e++) {
          if ("tilelayer" === a.layers[e].type) {
            var f = a.layers[e];
            if (!f.compression && f.encoding && "base64" === f.encoding) {
              var g = window.atob(f.data);
              var h = g.length;
              var i = new Array(h);
              for (var j = 0; j < h; j += 4) {
                i[j / 4] = (g.charCodeAt(j) | g.charCodeAt(j + 1) << 8 | g.charCodeAt(j + 2) << 16 | g.charCodeAt(j + 3) << 24) >>> 0;
              }
              f.data = i;
              delete f.encoding;
            } else if (f.compression) {
              console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + f.name + "'");
              continue;
            }
            var k = {
              name: f.name,
              x: f.x,
              y: f.y,
              width: f.width,
              height: f.height,
              widthInPixels: f.width * a.tilewidth,
              heightInPixels: f.height * a.tileheight,
              alpha: f.opacity,
              visible: f.visible,
              properties: {},
              indexes: [],
              callbacks: [],
              bodies: []
            };
            if (f.properties) {
              k.properties = f.properties;
            }
            var o;
            var p;
            var q;
            var r;
            var l = 0;
            var m = [];
            var n = [];
            var s = 0;
            for (var h = f.data.length; s < h; s++) {
              o = 0;
              p = false;
              r = f.data[s];
              q = 0;
              if (r > 536870912) {
                if (r > 2147483648) {
                  r -= 2147483648;
                  q += 4;
                }
                if (r > 1073741824) {
                  r -= 1073741824;
                  q += 2;
                }
                if (r > 536870912) {
                  r -= 536870912;
                  q += 1;
                }
                switch (q) {
                  case 5:
                    o = Math.PI / 2;
                    break;
                  case 6:
                    o = Math.PI;
                    break;
                  case 3:
                    o = 3 * Math.PI / 2;
                    break;
                  case 4:
                    o = 0;
                    p = true;
                    break;
                  case 7:
                    o = Math.PI / 2;
                    p = true;
                    break;
                  case 2:
                    o = Math.PI;
                    p = true;
                    break;
                  case 1:
                    o = 3 * Math.PI / 2;
                    p = true;
                }
              }
              if (r > 0) {
                var t = new b.Tile(k, r, l, n.length, a.tilewidth, a.tileheight);
                t.rotation = o;
                t.flipped = p;
                if (0 !== q) {
                  t.flippedVal = q;
                }
                m.push(t);
              } else if (b.TilemapParser.INSERT_NULL) {
                m.push(null);
              } else {
                m.push(new b.Tile(k, -1, l, n.length, a.tilewidth, a.tileheight));
              }
              l++;
              if (l === f.width) {
                n.push(m);
                l = 0;
                m = [];
              }
            }
            k.data = n;
            d.push(k);
          }
        }
        c.layers = d;
        var u = [];
        for (var e = 0; e < a.layers.length; e++) {
          if ("imagelayer" === a.layers[e].type) {
            var v = a.layers[e];
            var w = {
              name: v.name,
              image: v.image,
              x: v.x,
              y: v.y,
              alpha: v.opacity,
              visible: v.visible,
              properties: {}
            };
            if (v.properties) {
              w.properties = v.properties;
            }
            u.push(w);
          }
        }
        c.images = u;
        var x = [];
        var y = [];
        var z = null;
        for (var e = 0; e < a.tilesets.length; e++) {
          var A = a.tilesets[e];
          if (A.image) {
            var B = new b.Tileset(A.name, A.firstgid, A.tilewidth, A.tileheight, A.margin, A.spacing, A.properties);
            if (A.tileproperties) {
              B.tileProperties = A.tileproperties;
            }
            B.updateTileData(A.imagewidth, A.imageheight);
            x.push(B);
          } else {
            var C = new b.ImageCollection(A.name, A.firstgid, A.tilewidth, A.tileheight, A.margin, A.spacing, A.properties);
            for (var D in A.tiles) {
              var w = A.tiles[D].image;
              var r = A.firstgid + parseInt(D, 10);
              C.addImage(r, w);
            }
            y.push(C);
          }
          if (z) {
            z.lastgid = A.firstgid - 1;
          }
          z = A;
        }
        c.tilesets = x;
        c.imagecollections = y;
        var E = {};
        var F = {};
        for (var e = 0; e < a.layers.length; e++) {
          if ("objectgroup" === a.layers[e].type) {
            var H = a.layers[e];
            E[H.name] = [];
            F[H.name] = [];
            var I = 0;
            for (var h = H.objects.length; I < h; I++) {
              if (H.objects[I].gid) {
                var J = {
                  gid: H.objects[I].gid,
                  name: H.objects[I].name,
                  type: H.objects[I].hasOwnProperty("type") ? H.objects[I].type : "",
                  x: H.objects[I].x,
                  y: H.objects[I].y,
                  visible: H.objects[I].visible,
                  properties: H.objects[I].properties
                };
                if (H.objects[I].rotation) {
                  J.rotation = H.objects[I].rotation;
                }
                E[H.name].push(J);
              } else if (H.objects[I].polyline) {
                var J = {
                  name: H.objects[I].name,
                  type: H.objects[I].type,
                  x: H.objects[I].x,
                  y: H.objects[I].y,
                  width: H.objects[I].width,
                  height: H.objects[I].height,
                  visible: H.objects[I].visible,
                  properties: H.objects[I].properties
                };
                if (H.objects[I].rotation) {
                  J.rotation = H.objects[I].rotation;
                }
                J.polyline = [];
                for (var K = 0; K < H.objects[I].polyline.length; K++) {
                  J.polyline.push([H.objects[I].polyline[K].x, H.objects[I].polyline[K].y]);
                }
                F[H.name].push(J);
                E[H.name].push(J);
              } else if (H.objects[I].polygon) {
                var J = G(H.objects[I], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                J.polygon = [];
                for (var K = 0; K < H.objects[I].polygon.length; K++) {
                  J.polygon.push([H.objects[I].polygon[K].x, H.objects[I].polygon[K].y]);
                }
                E[H.name].push(J);
              } else if (H.objects[I].ellipse) {
                var J = G(H.objects[I], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                E[H.name].push(J);
              } else {
                var J = G(H.objects[I], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                J.rectangle = true;
                E[H.name].push(J);
              }
            }
          }
        }
        c.objects = E;
        c.collision = F;
        c.tiles = [];
        for (var e = 0; e < c.tilesets.length; e++) {
          var A = c.tilesets[e];
          var l = A.tileMargin;
          var L = A.tileMargin;
          var M = 0;
          var N = 0;
          var O = 0;
          for (var s = A.firstgid; s < A.firstgid + A.total && (c.tiles[s] = [l, L, e], l += A.tileWidth + A.tileSpacing, ++M !== A.total) && (++N !== A.columns || (l = A.tileMargin, L += A.tileHeight + A.tileSpacing, N = 0, ++O !== A.rows)); s++) {
            ;
          }
        }
        var k;
        var t;
        var P;
        var A;
        for (var e = 0; e < c.layers.length; e++) {
          k = c.layers[e];
          A = null;
          for (var j = 0; j < k.data.length; j++) {
            m = k.data[j];
            for (var Q = 0; Q < m.length; Q++) {
              if (!(null === (t = m[Q]) || t.index < 0)) {
                P = c.tiles[t.index][2];
                A = c.tilesets[P];
                if (A.tileProperties && A.tileProperties[t.index - A.firstgid]) {
                  t.properties = b.Utils.mixin(A.tileProperties[t.index - A.firstgid], t.properties);
                }
              }
            }
          }
        }
        return c;
      }
    };
    b.Tileset = function (a, b, c, d, e, f, g) {
      if (undefined === c || c <= 0) {
        c = 32;
      }
      if (undefined === d || d <= 0) {
        d = 32;
      }
      if (undefined === e) {
        e = 0;
      }
      if (undefined === f) {
        f = 0;
      }
      this.name = a;
      this.firstgid = 0 | b;
      this.tileWidth = 0 | c;
      this.tileHeight = 0 | d;
      this.tileMargin = 0 | e;
      this.tileSpacing = 0 | f;
      this.properties = g || {};
      this.image = null;
      this.rows = 0;
      this.columns = 0;
      this.total = 0;
      this.drawCoords = [];
    };
    b.Tileset.prototype = {
      draw: function (a, b, c, d) {
        var e = d - this.firstgid << 1;
        if (e >= 0 && e + 1 < this.drawCoords.length) {
          a.drawImage(this.image, this.drawCoords[e], this.drawCoords[e + 1], this.tileWidth, this.tileHeight, b, c, this.tileWidth, this.tileHeight);
        }
      },
      containsTileIndex: function (a) {
        return a >= this.firstgid && a < this.firstgid + this.total;
      },
      setImage: function (a) {
        this.image = a;
        this.updateTileData(a.width, a.height);
      },
      setSpacing: function (a, b) {
        this.tileMargin = 0 | a;
        this.tileSpacing = 0 | b;
        if (this.image) {
          this.updateTileData(this.image.width, this.image.height);
        }
      },
      updateTileData: function (a, b) {
        var c = (b - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing);
        var d = (a - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
        if (!(c % 1 == 0 && d % 1 == 0)) {
          console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size");
        }
        c = Math.floor(c);
        d = Math.floor(d);
        if (this.rows && this.rows !== c || this.columns && this.columns !== d) {
          console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ");
        }
        this.rows = c;
        this.columns = d;
        this.total = c * d;
        this.drawCoords.length = 0;
        var e = this.tileMargin;
        var f = this.tileMargin;
        for (var g = 0; g < this.rows; g++) {
          for (var h = 0; h < this.columns; h++) {
            this.drawCoords.push(e);
            this.drawCoords.push(f);
            e += this.tileWidth + this.tileSpacing;
          }
          e = this.tileMargin;
          f += this.tileHeight + this.tileSpacing;
        }
      }
    };
    b.Tileset.prototype.constructor = b.Tileset;
    b.Particle = function (a, c, d, e, f) {
      b.Sprite.call(this, a, c, d, e, f);
      this.autoScale = false;
      this.scaleData = null;
      this._s = 0;
      this.autoAlpha = false;
      this.alphaData = null;
      this._a = 0;
    };
    b.Particle.prototype = Object.create(b.Sprite.prototype);
    b.Particle.prototype.constructor = b.Particle;
    b.Particle.prototype.update = function () {
      if (this.autoScale) {
        this._s--;
        if (this._s) {
          this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
        } else {
          this.autoScale = false;
        }
      }
      if (this.autoAlpha) {
        this._a--;
        if (this._a) {
          this.alpha = this.alphaData[this._a].v;
        } else {
          this.autoAlpha = false;
        }
      }
    };
    b.Particle.prototype.onEmit = function () {};
    b.Particle.prototype.setAlphaData = function (a) {
      this.alphaData = a;
      this._a = a.length - 1;
      this.alpha = this.alphaData[this._a].v;
      this.autoAlpha = true;
    };
    b.Particle.prototype.setScaleData = function (a) {
      this.scaleData = a;
      this._s = a.length - 1;
      this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);
      this.autoScale = true;
    };
    b.Particle.prototype.reset = function (a, c, d) {
      b.Component.Reset.prototype.reset.call(this, a, c, d);
      this.alpha = 1;
      this.scale.set(1);
      this.autoScale = false;
      this.autoAlpha = false;
      return this;
    };
    b.Particles = function (a) {
      this.game = a;
      this.emitters = {};
      this.ID = 0;
    };
    b.Particles.prototype = {
      add: function (a) {
        this.emitters[a.name] = a;
        return a;
      },
      remove: function (a) {
        delete this.emitters[a.name];
      },
      update: function () {
        for (var a in this.emitters) if (this.emitters[a].exists) {
          this.emitters[a].update();
        }
      }
    };
    b.Particles.prototype.constructor = b.Particles;
    b.Particles.Arcade = {};
    b.Particles.Arcade.Emitter = function (a, c, d, e) {
      this.maxParticles = e || 50;
      b.Group.call(this, a);
      this.name = "emitter" + this.game.particles.ID++;
      this.type = b.EMITTER;
      this.physicsType = b.GROUP;
      this.area = new b.Rectangle(c, d, 1, 1);
      this.minParticleSpeed = new b.Point(-100, -100);
      this.maxParticleSpeed = new b.Point(100, 100);
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this.scaleData = null;
      this.minRotation = -360;
      this.maxRotation = 360;
      this.minParticleAlpha = 1;
      this.maxParticleAlpha = 1;
      this.alphaData = null;
      this.gravity = 100;
      this.particleClass = b.Particle;
      this.particleDrag = new b.Point();
      this.angularDrag = 0;
      this.frequency = 100;
      this.lifespan = 2e3;
      this.bounce = new b.Point();
      this.on = false;
      this.particleAnchor = new b.Point(.5, .5);
      this.blendMode = b.blendModes.NORMAL;
      this.emitX = c;
      this.emitY = d;
      this.autoScale = false;
      this.autoAlpha = false;
      this.particleBringToTop = false;
      this.particleSendToBack = false;
      this._minParticleScale = new b.Point(1, 1);
      this._maxParticleScale = new b.Point(1, 1);
      this._quantity = 0;
      this._timer = 0;
      this._counter = 0;
      this._flowQuantity = 0;
      this._flowTotal = 0;
      this._explode = true;
      this._frames = null;
    };
    b.Particles.Arcade.Emitter.prototype = Object.create(b.Group.prototype);
    b.Particles.Arcade.Emitter.prototype.constructor = b.Particles.Arcade.Emitter;
    b.Particles.Arcade.Emitter.prototype.update = function () {
      if (this.on && this.game.time.time >= this._timer) {
        this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion;
        if (0 !== this._flowTotal) {
          if (this._flowQuantity > 0) {
            for (var a = 0; a < this._flowQuantity; a++) {
              if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                this.on = false;
                break;
              }
            }
          } else if (this.emitParticle()) {
            this._counter++;
            if (-1 !== this._flowTotal && this._counter >= this._flowTotal) {
              this.on = false;
            }
          }
        } else if (this.emitParticle()) {
          this._counter++;
          if (this._quantity > 0 && this._counter >= this._quantity) {
            this.on = false;
          }
        }
      }
      for (var a = this.children.length; a--;) {
        if (this.children[a].exists) {
          this.children[a].update();
        }
      }
    };
    b.Particles.Arcade.Emitter.prototype.makeParticles = function (a, b, c, d, e) {
      if (undefined === b) {
        b = 0;
      }
      if (undefined === c) {
        c = this.maxParticles;
      }
      if (undefined === d) {
        d = false;
      }
      if (undefined === e) {
        e = false;
      }
      var f;
      var g = 0;
      var h = a;
      var i = b;
      this._frames = b;
      for (c > this.maxParticles && (this.maxParticles = c); g < c;) {
        if (Array.isArray(a)) {
          h = this.game.rnd.pick(a);
        }
        if (Array.isArray(b)) {
          i = this.game.rnd.pick(b);
        }
        f = new this.particleClass(this.game, 0, 0, h, i);
        this.game.physics.arcade.enable(f, false);
        if (d) {
          f.body.checkCollision.any = true;
          f.body.checkCollision.none = false;
        } else {
          f.body.checkCollision.none = true;
        }
        f.body.collideWorldBounds = e;
        f.body.skipQuadTree = true;
        f.exists = false;
        f.visible = false;
        f.anchor.copyFrom(this.particleAnchor);
        this.add(f);
        g++;
      }
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.kill = function () {
      this.on = false;
      this.alive = false;
      this.exists = false;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.revive = function () {
      this.alive = true;
      this.exists = true;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.explode = function (a, b) {
      this._flowTotal = 0;
      this.start(true, a, 0, b, false);
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.flow = function (a, b, c, d, e) {
      if (!(undefined !== c && 0 !== c)) {
        c = 1;
      }
      if (undefined === d) {
        d = -1;
      }
      if (undefined === e) {
        e = true;
      }
      if (c > this.maxParticles) {
        c = this.maxParticles;
      }
      this._counter = 0;
      this._flowQuantity = c;
      this._flowTotal = d;
      if (e) {
        this.start(true, a, b, c);
        this._counter += c;
        this.on = true;
        this._timer = this.game.time.time + b * this.game.time.slowMotion;
      } else {
        this.start(false, a, b, c);
      }
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.start = function (a, b, c, d, e) {
      if (undefined === a) {
        a = true;
      }
      if (undefined === b) {
        b = 0;
      }
      if (!(undefined !== c && null !== c)) {
        c = 250;
      }
      if (undefined === d) {
        d = 0;
      }
      if (undefined === e) {
        e = false;
      }
      if (d > this.maxParticles) {
        d = this.maxParticles;
      }
      this.revive();
      this.visible = true;
      this.lifespan = b;
      this.frequency = c;
      if (a || e) {
        for (var f = 0; f < d; f++) {
          this.emitParticle();
        }
      } else {
        this.on = true;
        this._quantity = d;
        this._counter = 0;
        this._timer = this.game.time.time + c * this.game.time.slowMotion;
      }
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.emitParticle = function (a, b, c, d) {
      if (undefined === a) {
        a = null;
      }
      if (undefined === b) {
        b = null;
      }
      var e = this.getFirstExists(false);
      if (null === e) {
        return false;
      }
      var f = this.game.rnd;
      if (undefined !== c && undefined !== d) {
        e.loadTexture(c, d);
      } else if (undefined !== c) {
        e.loadTexture(c);
      }
      var g = this.emitX;
      var h = this.emitY;
      if (null !== a) {
        g = a;
      } else if (this.width > 1) {
        g = f.between(this.left, this.right);
      }
      if (null !== b) {
        h = b;
      } else if (this.height > 1) {
        h = f.between(this.top, this.bottom);
      }
      e.reset(g, h);
      e.angle = 0;
      e.lifespan = this.lifespan;
      if (this.particleBringToTop) {
        this.bringToTop(e);
      } else if (this.particleSendToBack) {
        this.sendToBack(e);
      }
      if (this.autoScale) {
        e.setScaleData(this.scaleData);
      } else if (1 !== this.minParticleScale || 1 !== this.maxParticleScale) {
        e.scale.set(f.realInRange(this.minParticleScale, this.maxParticleScale));
      } else if (!(this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y)) {
        e.scale.set(f.realInRange(this._minParticleScale.x, this._maxParticleScale.x), f.realInRange(this._minParticleScale.y, this._maxParticleScale.y));
      }
      if (undefined === d) {
        if (Array.isArray(this._frames)) {
          e.frame = this.game.rnd.pick(this._frames);
        } else {
          e.frame = this._frames;
        }
      }
      if (this.autoAlpha) {
        e.setAlphaData(this.alphaData);
      } else {
        e.alpha = f.realInRange(this.minParticleAlpha, this.maxParticleAlpha);
      }
      e.blendMode = this.blendMode;
      var i = e.body;
      i.updateBounds();
      i.bounce.copyFrom(this.bounce);
      i.drag.copyFrom(this.particleDrag);
      i.velocity.x = f.between(this.minParticleSpeed.x, this.maxParticleSpeed.x);
      i.velocity.y = f.between(this.minParticleSpeed.y, this.maxParticleSpeed.y);
      i.angularVelocity = f.between(this.minRotation, this.maxRotation);
      i.gravity.y = this.gravity;
      i.angularDrag = this.angularDrag;
      e.onEmit();
      return true;
    };
    b.Particles.Arcade.Emitter.prototype.destroy = function () {
      this.game.particles.remove(this);
      b.Group.prototype.destroy.call(this, true, false);
    };
    b.Particles.Arcade.Emitter.prototype.setSize = function (a, b) {
      this.area.width = a;
      this.area.height = b;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.setXSpeed = function (a, b) {
      a = a || 0;
      b = b || 0;
      this.minParticleSpeed.x = a;
      this.maxParticleSpeed.x = b;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.setYSpeed = function (a, b) {
      a = a || 0;
      b = b || 0;
      this.minParticleSpeed.y = a;
      this.maxParticleSpeed.y = b;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.setRotation = function (a, b) {
      a = a || 0;
      b = b || 0;
      this.minRotation = a;
      this.maxRotation = b;
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.setAlpha = function (a, c, d, e, f) {
      if (undefined === a) {
        a = 1;
      }
      if (undefined === c) {
        c = 1;
      }
      if (undefined === d) {
        d = 0;
      }
      if (undefined === e) {
        e = b.Easing.Linear.None;
      }
      if (undefined === f) {
        f = false;
      }
      this.minParticleAlpha = a;
      this.maxParticleAlpha = c;
      this.autoAlpha = false;
      if (d > 0 && a !== c) {
        var g = {
          v: a
        };
        var h = this.game.make.tween(g).to({
          v: c
        }, d, e);
        h.yoyo(f);
        this.alphaData = h.generateData(60);
        this.alphaData.reverse();
        this.autoAlpha = true;
      }
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.setScale = function (a, c, d, e, f, g, h) {
      if (undefined === a) {
        a = 1;
      }
      if (undefined === c) {
        c = 1;
      }
      if (undefined === d) {
        d = 1;
      }
      if (undefined === e) {
        e = 1;
      }
      if (undefined === f) {
        f = 0;
      }
      if (undefined === g) {
        g = b.Easing.Linear.None;
      }
      if (undefined === h) {
        h = false;
      }
      this.minParticleScale = 1;
      this.maxParticleScale = 1;
      this._minParticleScale.set(a, d);
      this._maxParticleScale.set(c, e);
      this.autoScale = false;
      if (f > 0 && (a !== c || d !== e)) {
        var i = {
          x: a,
          y: d
        };
        var j = this.game.make.tween(i).to({
          x: c,
          y: e
        }, f, g);
        j.yoyo(h);
        this.scaleData = j.generateData(60);
        this.scaleData.reverse();
        this.autoScale = true;
      }
      return this;
    };
    b.Particles.Arcade.Emitter.prototype.at = function (a) {
      if (a.center) {
        this.emitX = a.center.x;
        this.emitY = a.center.y;
      } else {
        this.emitX = a.world.x + a.anchor.x * a.width;
        this.emitY = a.world.y + a.anchor.y * a.height;
      }
      return this;
    };
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "width", {
      get: function () {
        return this.area.width;
      },
      set: function (a) {
        this.area.width = a;
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "height", {
      get: function () {
        return this.area.height;
      },
      set: function (a) {
        this.area.height = a;
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "x", {
      get: function () {
        return this.emitX;
      },
      set: function (a) {
        this.emitX = a;
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "y", {
      get: function () {
        return this.emitY;
      },
      set: function (a) {
        this.emitY = a;
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "left", {
      get: function () {
        return Math.floor(this.x - this.area.width / 2);
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "right", {
      get: function () {
        return Math.floor(this.x + this.area.width / 2);
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "top", {
      get: function () {
        return Math.floor(this.y - this.area.height / 2);
      }
    });
    Object.defineProperty(b.Particles.Arcade.Emitter.prototype, "bottom", {
      get: function () {
        return Math.floor(this.y + this.area.height / 2);
      }
    });
    b.Weapon = function (a, c) {
      b.Plugin.call(this, a, c);
      this.bullets = null;
      this.autoExpandBulletsGroup = false;
      this.autofire = false;
      this.shots = 0;
      this.fireLimit = 0;
      this.fireRate = 100;
      this.fireRateVariance = 0;
      this.fireFrom = new b.Rectangle(0, 0, 1, 1);
      this.fireAngle = b.ANGLE_UP;
      this.bulletInheritSpriteSpeed = false;
      this.bulletAnimation = "";
      this.bulletFrameRandom = false;
      this.bulletFrameCycle = false;
      this.bulletWorldWrap = false;
      this.bulletWorldWrapPadding = 0;
      this.bulletAngleOffset = 0;
      this.bulletAngleVariance = 0;
      this.bulletSpeed = 200;
      this.bulletSpeedVariance = 0;
      this.bulletLifespan = 0;
      this.bulletKillDistance = 0;
      this.bulletGravity = new b.Point(0, 0);
      this.bulletRotateToVelocity = false;
      this.bulletKey = "";
      this.bulletFrame = "";
      this._bulletClass = b.Bullet;
      this._bulletCollideWorldBounds = false;
      this._bulletKillType = b.Weapon.KILL_WORLD_BOUNDS;
      this._data = {
        customBody: false,
        width: 0,
        height: 0,
        offsetX: 0,
        offsetY: 0
      };
      this.bounds = new b.Rectangle();
      this.bulletBounds = a.world.bounds;
      this.bulletFrames = [];
      this.bulletFrameIndex = 0;
      this.anims = {};
      this.onFire = new b.Signal();
      this.onKill = new b.Signal();
      this.onFireLimit = new b.Signal();
      this.trackedSprite = null;
      this.trackedPointer = null;
      this.trackRotation = false;
      this.trackOffset = new b.Point();
      this._nextFire = 0;
      this._rotatedPoint = new b.Point();
    };
    b.Weapon.prototype = Object.create(b.Plugin.prototype);
    b.Weapon.prototype.constructor = b.Weapon;
    b.Weapon.KILL_NEVER = 0;
    b.Weapon.KILL_LIFESPAN = 1;
    b.Weapon.KILL_DISTANCE = 2;
    b.Weapon.KILL_WEAPON_BOUNDS = 3;
    b.Weapon.KILL_CAMERA_BOUNDS = 4;
    b.Weapon.KILL_WORLD_BOUNDS = 5;
    b.Weapon.KILL_STATIC_BOUNDS = 6;
    b.Weapon.prototype.createBullets = function (a, c, d, e) {
      if (undefined === a) {
        a = 1;
      }
      if (undefined === e) {
        e = this.game.world;
      }
      if (!this.bullets) {
        this.bullets = this.game.add.physicsGroup(b.Physics.ARCADE, e);
        this.bullets.classType = this._bulletClass;
      }
      if (0 !== a) {
        if (-1 === a) {
          this.autoExpandBulletsGroup = true;
          a = 1;
        }
        this.bullets.createMultiple(a, c, d);
        this.bullets.setAll("data.bulletManager", this);
        this.bulletKey = c;
        this.bulletFrame = d;
      }
      return this;
    };
    b.Weapon.prototype.forEach = function (a, b) {
      this.bullets.forEachExists(a, b, arguments);
      return this;
    };
    b.Weapon.prototype.pauseAll = function () {
      this.bullets.setAll("body.enable", false);
      return this;
    };
    b.Weapon.prototype.resumeAll = function () {
      this.bullets.setAll("body.enable", true);
      return this;
    };
    b.Weapon.prototype.killAll = function () {
      this.bullets.callAllExists("kill", true);
      this.bullets.setAll("body.enable", true);
      return this;
    };
    b.Weapon.prototype.resetShots = function (a) {
      this.shots = 0;
      if (undefined !== a) {
        this.fireLimit = a;
      }
      return this;
    };
    b.Weapon.prototype.destroy = function () {
      this.parent.remove(this, false);
      this.bullets.destroy();
      this.game = null;
      this.parent = null;
      this.active = false;
      this.visible = false;
    };
    b.Weapon.prototype.update = function () {
      if (this._bulletKillType === b.Weapon.KILL_WEAPON_BOUNDS) {
        if (this.trackedSprite) {
          this.trackedSprite.updateTransform();
          this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y);
        } else if (this.trackedPointer) {
          this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY);
        }
      }
      if (this.autofire) {
        this.fire();
      }
    };
    b.Weapon.prototype.trackSprite = function (a, b, c, d) {
      if (undefined === b) {
        b = 0;
      }
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = false;
      }
      this.trackedPointer = null;
      this.trackedSprite = a;
      this.trackRotation = d;
      this.trackOffset.set(b, c);
      return this;
    };
    b.Weapon.prototype.trackPointer = function (a, b, c) {
      if (undefined === a) {
        a = this.game.input.activePointer;
      }
      if (undefined === b) {
        b = 0;
      }
      if (undefined === c) {
        c = 0;
      }
      this.trackedPointer = a;
      this.trackedSprite = null;
      this.trackRotation = false;
      this.trackOffset.set(b, c);
      return this;
    };
    b.Weapon.prototype.fire = function (a, c, d) {
      if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) {
        return false;
      }
      var e = this.bulletSpeed;
      if (0 !== this.bulletSpeedVariance) {
        e += b.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance);
      }
      if (a) {
        if (this.fireFrom.width > 1) {
          this.fireFrom.centerOn(a.x, a.y);
        } else {
          this.fireFrom.x = a.x;
          this.fireFrom.y = a.y;
        }
      } else if (this.trackedSprite) {
        if (this.trackRotation) {
          this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y);
          this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation);
          if (this.fireFrom.width > 1) {
            this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y);
          } else {
            this.fireFrom.x = this._rotatedPoint.x;
            this.fireFrom.y = this._rotatedPoint.y;
          }
        } else if (this.fireFrom.width > 1) {
          this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y);
        } else {
          this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x;
          this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y;
        }
        if (this.bulletInheritSpriteSpeed) {
          e += this.trackedSprite.body.speed;
        }
      } else if (this.trackedPointer) {
        if (this.fireFrom.width > 1) {
          this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y);
        } else {
          this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x;
          this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y;
        }
      }
      var f = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x;
      var g = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y;
      var h = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
      if (undefined !== c && undefined !== d) {
        h = this.game.math.radToDeg(Math.atan2(d - g, c - f));
      }
      if (0 !== this.bulletAngleVariance) {
        h += b.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance);
      }
      var i = 0;
      var j = 0;
      if (0 === h || 180 === h) {
        i = Math.cos(this.game.math.degToRad(h)) * e;
      } else if (90 === h || 270 === h) {
        j = Math.sin(this.game.math.degToRad(h)) * e;
      } else {
        i = Math.cos(this.game.math.degToRad(h)) * e;
        j = Math.sin(this.game.math.degToRad(h)) * e;
      }
      var k = null;
      if (this.autoExpandBulletsGroup) {
        k = this.bullets.getFirstExists(false, true, f, g, this.bulletKey, this.bulletFrame);
        k.data.bulletManager = this;
      } else {
        k = this.bullets.getFirstExists(false);
      }
      if (k) {
        k.reset(f, g);
        k.data.fromX = f;
        k.data.fromY = g;
        k.data.killType = this.bulletKillType;
        k.data.killDistance = this.bulletKillDistance;
        k.data.rotateToVelocity = this.bulletRotateToVelocity;
        if (this.bulletKillType === b.Weapon.KILL_LIFESPAN) {
          k.lifespan = this.bulletLifespan;
        }
        k.angle = h + this.bulletAngleOffset;
        if ("" !== this.bulletAnimation) {
          if (null === k.animations.getAnimation(this.bulletAnimation)) {
            var l = this.anims[this.bulletAnimation];
            k.animations.add(l.name, l.frames, l.frameRate, l.loop, l.useNumericIndex);
          }
          k.animations.play(this.bulletAnimation);
        } else if (this.bulletFrameCycle) {
          k.frame = this.bulletFrames[this.bulletFrameIndex];
          if (++this.bulletFrameIndex >= this.bulletFrames.length) {
            this.bulletFrameIndex = 0;
          }
        } else if (this.bulletFrameRandom) {
          k.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)];
        }
        if (k.data.bodyDirty) {
          if (this._data.customBody) {
            k.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY);
          }
          k.body.collideWorldBounds = this.bulletCollideWorldBounds;
          k.data.bodyDirty = false;
        }
        k.body.velocity.set(i, j);
        k.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y);
        if (0 !== this.bulletSpeedVariance) {
          var m = this.fireRate;
          m += b.Math.between(-this.fireRateVariance, this.fireRateVariance);
          if (m < 0) {
            m = 0;
          }
          this._nextFire = this.game.time.now + m;
        } else {
          this._nextFire = this.game.time.now + this.fireRate;
        }
        this.shots++;
        this.onFire.dispatch(k, this, e);
        if (this.fireLimit > 0 && this.shots === this.fireLimit) {
          this.onFireLimit.dispatch(this, this.fireLimit);
        }
      }
      return k;
    };
    b.Weapon.prototype.fireAtPointer = function (a) {
      if (undefined === a) {
        a = this.game.input.activePointer;
      }
      return this.fire(null, a.worldX, a.worldY);
    };
    b.Weapon.prototype.fireAtSprite = function (a) {
      return this.fire(null, a.world.x, a.world.y);
    };
    b.Weapon.prototype.fireAtXY = function (a, b) {
      return this.fire(null, a, b);
    };
    b.Weapon.prototype.setBulletBodyOffset = function (a, b, c, d) {
      if (undefined === c) {
        c = 0;
      }
      if (undefined === d) {
        d = 0;
      }
      this._data.customBody = true;
      this._data.width = a;
      this._data.height = b;
      this._data.offsetX = c;
      this._data.offsetY = d;
      this.bullets.callAll("body.setSize", "body", a, b, c, d);
      this.bullets.setAll("data.bodyDirty", false);
      return this;
    };
    b.Weapon.prototype.setBulletFrames = function (a, c, d, e) {
      if (undefined === d) {
        d = true;
      }
      if (undefined === e) {
        e = false;
      }
      this.bulletFrames = b.ArrayUtils.numberArray(a, c);
      this.bulletFrameIndex = 0;
      this.bulletFrameCycle = d;
      this.bulletFrameRandom = e;
      return this;
    };
    b.Weapon.prototype.addBulletAnimation = function (a, b, c, d, e) {
      this.anims[a] = {
        name: a,
        frames: b,
        frameRate: c,
        loop: d,
        useNumericIndex: e
      };
      this.bullets.callAll("animations.add", "animations", a, b, c, d, e);
      this.bulletAnimation = a;
      return this;
    };
    b.Weapon.prototype.debug = function (a, b, c) {
      if (undefined === a) {
        a = 16;
      }
      if (undefined === b) {
        b = 32;
      }
      if (undefined === c) {
        c = false;
      }
      this.game.debug.text("Weapon Plugin", a, b);
      this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, a, b + 24);
      if (c) {
        this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)");
      }
    };
    Object.defineProperty(b.Weapon.prototype, "bulletClass", {
      get: function () {
        return this._bulletClass;
      },
      set: function (a) {
        this._bulletClass = a;
        this.bullets.classType = this._bulletClass;
      }
    });
    Object.defineProperty(b.Weapon.prototype, "bulletKillType", {
      get: function () {
        return this._bulletKillType;
      },
      set: function (a) {
        switch (a) {
          case b.Weapon.KILL_STATIC_BOUNDS:
          case b.Weapon.KILL_WEAPON_BOUNDS:
            this.bulletBounds = this.bounds;
            break;
          case b.Weapon.KILL_CAMERA_BOUNDS:
            this.bulletBounds = this.game.camera.view;
            break;
          case b.Weapon.KILL_WORLD_BOUNDS:
            this.bulletBounds = this.game.world.bounds;
        }
        this._bulletKillType = a;
      }
    });
    Object.defineProperty(b.Weapon.prototype, "bulletCollideWorldBounds", {
      get: function () {
        return this._bulletCollideWorldBounds;
      },
      set: function (a) {
        this._bulletCollideWorldBounds = a;
        this.bullets.setAll("body.collideWorldBounds", a);
        this.bullets.setAll("data.bodyDirty", false);
      }
    });
    Object.defineProperty(b.Weapon.prototype, "x", {
      get: function () {
        return this.fireFrom.x;
      },
      set: function (a) {
        this.fireFrom.x = a;
      }
    });
    Object.defineProperty(b.Weapon.prototype, "y", {
      get: function () {
        return this.fireFrom.y;
      },
      set: function (a) {
        this.fireFrom.y = a;
      }
    });
    b.Bullet = function (a, c, d, e, f) {
      b.Sprite.call(this, a, c, d, e, f);
      this.anchor.set(.5);
      this.data = {
        bulletManager: null,
        fromX: 0,
        fromY: 0,
        bodyDirty: true,
        rotateToVelocity: false,
        killType: 0,
        killDistance: 0
      };
    };
    b.Bullet.prototype = Object.create(b.Sprite.prototype);
    b.Bullet.prototype.constructor = b.Bullet;
    b.Bullet.prototype.kill = function () {
      this.alive = false;
      this.exists = false;
      this.visible = false;
      this.data.bulletManager.onKill.dispatch(this);
      return this;
    };
    b.Bullet.prototype.update = function () {
      if (this.exists) {
        if (this.data.killType > b.Weapon.KILL_LIFESPAN) {
          if (this.data.killType === b.Weapon.KILL_DISTANCE) {
            if (this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, true) > this.data.killDistance) {
              this.kill();
            }
          } else if (!this.data.bulletManager.bulletBounds.intersects(this)) {
            this.kill();
          }
        }
        if (this.data.rotateToVelocity) {
          this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x);
        }
        if (this.data.bulletManager.bulletWorldWrap) {
          this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding);
        }
      }
    };
    b.Video = function (a, c, d) {
      if (undefined === c) {
        c = null;
      }
      if (undefined === d) {
        d = null;
      }
      this.game = a;
      this.key = c;
      this.width = 0;
      this.height = 0;
      this.type = b.VIDEO;
      this.disableTextureUpload = false;
      this.touchLocked = false;
      this.onPlay = new b.Signal();
      this.onChangeSource = new b.Signal();
      this.onComplete = new b.Signal();
      this.onAccess = new b.Signal();
      this.onError = new b.Signal();
      this.onTimeout = new b.Signal();
      this.timeout = 15e3;
      this._timeOutID = null;
      this.video = null;
      this.videoStream = null;
      this.isStreaming = false;
      this.retryLimit = 20;
      this.retry = 0;
      this.retryInterval = 500;
      this._retryID = null;
      this._codeMuted = false;
      this._muted = false;
      this._codePaused = false;
      this._paused = false;
      this._pending = false;
      this._autoplay = false;
      this._endCallback = null;
      this._playCallback = null;
      if (c && this.game.cache.checkVideoKey(c)) {
        var e = this.game.cache.getVideo(c);
        if (e.isBlob) {
          this.createVideoFromBlob(e.data);
        } else {
          this.video = e.data;
        }
        this.width = this.video.videoWidth;
        this.height = this.video.videoHeight;
      } else if (d) {
        this.createVideoFromURL(d, false);
      }
      if (this.video && !d) {
        this.baseTexture = new PIXI.BaseTexture(this.video);
        this.baseTexture.forceLoaded(this.width, this.height);
      } else {
        this.baseTexture = new PIXI.BaseTexture(b.Cache.DEFAULT.baseTexture.source);
        this.baseTexture.forceLoaded(this.width, this.height);
      }
      this.texture = new PIXI.Texture(this.baseTexture);
      this.textureFrame = new b.Frame(0, 0, 0, this.width, this.height, "video");
      this.texture.setFrame(this.textureFrame);
      this.texture.valid = false;
      if (null !== c && this.video) {
        this.texture.valid = this.video.canplay;
      }
      this.snapshot = null;
      if (b.BitmapData) {
        this.snapshot = new b.BitmapData(this.game, "", this.width, this.height);
      }
      if (!this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) {
        this.setTouchLock();
      } else if (e) {
        e.locked = false;
      }
    };
    b.Video.prototype = {
      connectToMediaStream: function (a, b) {
        if (a && b) {
          this.video = a;
          this.videoStream = b;
          this.isStreaming = true;
          this.baseTexture.source = this.video;
          this.updateTexture(null, this.video.videoWidth, this.video.videoHeight);
          this.onAccess.dispatch(this);
        }
        return this;
      },
      startMediaStream: function (a, b, c) {
        if (undefined === a) {
          a = false;
        }
        if (undefined === b) {
          b = null;
        }
        if (undefined === c) {
          c = null;
        }
        if (!this.game.device.getUserMedia) {
          this.onError.dispatch(this, "No getUserMedia");
          return false;
        }
        if (null !== this.videoStream) {
          if (this.videoStream.active) {
            this.videoStream.active = false;
          } else {
            this.videoStream.stop();
          }
        }
        this.removeVideoElement();
        this.video = document.createElement("video");
        this.video.setAttribute("autoplay", "autoplay");
        if (null !== b) {
          this.video.width = b;
        }
        if (null !== c) {
          this.video.height = c;
        }
        this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
        try {
          navigator.getUserMedia({
            audio: a,
            video: true
          }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
        } catch (a) {
          this.getUserMediaError(a);
        }
        return this;
      },
      getUserMediaTimeout: function () {
        clearTimeout(this._timeOutID);
        this.onTimeout.dispatch(this);
      },
      getUserMediaError: function (a) {
        clearTimeout(this._timeOutID);
        this.onError.dispatch(this, a);
      },
      getUserMediaSuccess: function (a) {
        clearTimeout(this._timeOutID);
        this.videoStream = a;
        if (undefined !== this.video.mozSrcObject) {
          this.video.mozSrcObject = a;
        } else {
          this.video.src = window.URL && window.URL.createObjectURL(a) || a;
        }
        var b = this;
        this.video.onloadeddata = function () {
          function c() {
            if (a > 0) {
              if (b.video.videoWidth > 0) {
                var d = b.video.videoWidth;
                var e = b.video.videoHeight;
                if (isNaN(b.video.videoHeight)) {
                  e = d / 1.3333333333333333;
                }
                b.video.play();
                b.isStreaming = true;
                b.baseTexture.source = b.video;
                b.updateTexture(null, d, e);
                b.onAccess.dispatch(b);
              } else {
                window.setTimeout(c, 500);
              }
            } else {
              console.warn("Unable to connect to video stream. Webcam error?");
            }
            a--;
          }
          var a = 10;
          c();
        };
      },
      createVideoFromBlob: function (a) {
        var b = this;
        this.video = document.createElement("video");
        this.video.controls = false;
        this.video.setAttribute("autoplay", "autoplay");
        this.video.addEventListener("loadeddata", function (a) {
          b.updateTexture(a);
        }, true);
        this.video.src = window.URL.createObjectURL(a);
        this.video.canplay = true;
        return this;
      },
      createVideoFromURL: function (a, b) {
        if (undefined === b) {
          b = false;
        }
        if (this.texture) {
          this.texture.valid = false;
        }
        this.video = document.createElement("video");
        this.video.controls = false;
        if (b) {
          this.video.setAttribute("autoplay", "autoplay");
        }
        this.video.src = a;
        this.video.canplay = true;
        this.video.load();
        this.retry = this.retryLimit;
        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
        this.key = a;
        return this;
      },
      updateTexture: function (a, b, c) {
        var d = false;
        if (!(undefined !== b && null !== b)) {
          b = this.video.videoWidth;
          d = true;
        }
        if (!(undefined !== c && null !== c)) {
          c = this.video.videoHeight;
        }
        this.width = b;
        this.height = c;
        if (this.baseTexture.source !== this.video) {
          this.baseTexture.source = this.video;
        }
        this.baseTexture.forceLoaded(b, c);
        this.texture.frame.resize(b, c);
        this.texture.width = b;
        this.texture.height = c;
        this.texture.valid = true;
        if (this.snapshot) {
          this.snapshot.resize(b, c);
        }
        if (d && null !== this.key) {
          this.onChangeSource.dispatch(this, b, c);
          if (this._autoplay) {
            this.video.play();
            this.onPlay.dispatch(this, this.loop, this.playbackRate);
          }
        }
      },
      complete: function () {
        this.onComplete.dispatch(this);
      },
      play: function (a, b) {
        if (undefined === a) {
          a = false;
        }
        if (undefined === b) {
          b = 1;
        }
        if (this.game.sound.onMute) {
          this.game.sound.onMute.add(this.setMute, this);
          this.game.sound.onUnMute.add(this.unsetMute, this);
          if (this.game.sound.mute) {
            this.setMute();
          }
        }
        this.game.onPause.add(this.setPause, this);
        this.game.onResume.add(this.setResume, this);
        this._endCallback = this.complete.bind(this);
        this.video.addEventListener("ended", this._endCallback, true);
        this.video.addEventListener("webkitendfullscreen", this._endCallback, true);
        this.video.loop = a ? "loop" : "";
        this.video.playbackRate = b;
        if (this.touchLocked) {
          this._pending = true;
        } else {
          this._pending = false;
          if (null !== this.key) {
            if (4 !== this.video.readyState) {
              this.retry = this.retryLimit;
              this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
            } else {
              this._playCallback = this.playHandler.bind(this);
              this.video.addEventListener("playing", this._playCallback, true);
            }
          }
          this.video.play();
          this.onPlay.dispatch(this, a, b);
        }
        return this;
      },
      playHandler: function () {
        this.video.removeEventListener("playing", this._playCallback, true);
        this.updateTexture();
      },
      stop: function () {
        if (this.game.sound.onMute) {
          this.game.sound.onMute.remove(this.setMute, this);
          this.game.sound.onUnMute.remove(this.unsetMute, this);
        }
        this.game.onPause.remove(this.setPause, this);
        this.game.onResume.remove(this.setResume, this);
        if (this.isStreaming) {
          if (this.video.mozSrcObject) {
            this.video.mozSrcObject.stop();
            this.video.src = null;
          } else {
            this.video.src = "";
            if (this.videoStream.active) {
              this.videoStream.active = false;
            } else if (this.videoStream.getTracks) {
              this.videoStream.getTracks().forEach(function (a) {
                a.stop();
              });
            } else {
              this.videoStream.stop();
            }
          }
          this.videoStream = null;
          this.isStreaming = false;
        } else {
          this.video.removeEventListener("ended", this._endCallback, true);
          this.video.removeEventListener("webkitendfullscreen", this._endCallback, true);
          this.video.removeEventListener("playing", this._playCallback, true);
          if (this.touchLocked) {
            this._pending = false;
          } else {
            this.video.pause();
          }
        }
        return this;
      },
      add: function (a) {
        if (Array.isArray(a)) {
          for (var b = 0; b < a.length; b++) {
            if (a[b].loadTexture) {
              a[b].loadTexture(this);
            }
          }
        } else {
          a.loadTexture(this);
        }
        return this;
      },
      addToWorld: function (a, b, c, d, e, f) {
        e = e || 1;
        f = f || 1;
        var g = this.game.add.image(a, b, this);
        g.anchor.set(c, d);
        g.scale.set(e, f);
        return g;
      },
      render: function () {
        if (!this.disableTextureUpload && this.playing) {
          this.baseTexture.dirty();
        }
      },
      setMute: function () {
        if (!this._muted) {
          this._muted = true;
          this.video.muted = true;
        }
      },
      unsetMute: function () {
        if (this._muted && !this._codeMuted) {
          this._muted = false;
          this.video.muted = false;
        }
      },
      setPause: function () {
        if (!(this._paused || this.touchLocked)) {
          this._paused = true;
          this.video.pause();
        }
      },
      setResume: function () {
        if (!(!this._paused || this._codePaused || this.touchLocked)) {
          this._paused = false;
          if (!this.video.ended) {
            this.video.play();
          }
        }
      },
      changeSource: function (a, b) {
        if (undefined === b) {
          b = true;
        }
        this.texture.valid = false;
        this.video.pause();
        this.retry = this.retryLimit;
        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
        this.video.src = a;
        this.video.load();
        this._autoplay = b;
        if (!b) {
          this.paused = true;
        }
        return this;
      },
      checkVideoProgress: function () {
        if (4 === this.video.readyState) {
          this.updateTexture();
        } else {
          this.retry--;
          if (this.retry > 0) {
            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
          } else {
            console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming);
          }
        }
      },
      setTouchLock: function () {
        this.game.input.touch.addTouchLockCallback(this.unlock, this);
        this.touchLocked = true;
      },
      unlock: function () {
        this.touchLocked = false;
        this.video.play();
        this.onPlay.dispatch(this, this.loop, this.playbackRate);
        if (this.key) {
          var a = this.game.cache.getVideo(this.key);
          if (a && !a.isBlob) {
            a.locked = false;
          }
        }
        return true;
      },
      grab: function (a, b, c) {
        if (undefined === a) {
          a = false;
        }
        if (undefined === b) {
          b = 1;
        }
        if (undefined === c) {
          c = null;
        }
        return null === this.snapshot ? void console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable") : (a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, b, c), this.snapshot);
      },
      removeVideoElement: function () {
        if (this.video) {
          for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) {
            this.video.removeChild(this.video.firstChild);
          }
          this.video.removeAttribute("autoplay");
          this.video.removeAttribute("src");
          this.video = null;
        }
      },
      destroy: function () {
        this.stop();
        this.removeVideoElement();
        if (this.touchLocked) {
          this.game.input.touch.removeTouchLockCallback(this.unlock, this);
        }
        if (this._retryID) {
          window.clearTimeout(this._retryID);
        }
      }
    };
    Object.defineProperty(b.Video.prototype, "currentTime", {
      get: function () {
        return this.video ? this.video.currentTime : 0;
      },
      set: function (a) {
        this.video.currentTime = a;
      }
    });
    Object.defineProperty(b.Video.prototype, "duration", {
      get: function () {
        return this.video ? this.video.duration : 0;
      }
    });
    Object.defineProperty(b.Video.prototype, "progress", {
      get: function () {
        return this.video ? this.video.currentTime / this.video.duration : 0;
      }
    });
    Object.defineProperty(b.Video.prototype, "mute", {
      get: function () {
        return this._muted;
      },
      set: function (a) {
        if (a = a || null) {
          if (this._muted) {
            return;
          }
          this._codeMuted = true;
          this.setMute();
        } else {
          if (!this._muted) {
            return;
          }
          this._codeMuted = false;
          this.unsetMute();
        }
      }
    });
    Object.defineProperty(b.Video.prototype, "paused", {
      get: function () {
        return this._paused;
      },
      set: function (a) {
        a = a || null;
        if (!this.touchLocked) {
          if (a) {
            if (this._paused) {
              return;
            }
            this._codePaused = true;
            this.setPause();
          } else {
            if (!this._paused) {
              return;
            }
            this._codePaused = false;
            this.setResume();
          }
        }
      }
    });
    Object.defineProperty(b.Video.prototype, "volume", {
      get: function () {
        return this.video ? this.video.volume : 1;
      },
      set: function (a) {
        if (a < 0) {
          a = 0;
        } else if (a > 1) {
          a = 1;
        }
        if (this.video) {
          this.video.volume = a;
        }
      }
    });
    Object.defineProperty(b.Video.prototype, "playbackRate", {
      get: function () {
        return this.video ? this.video.playbackRate : 1;
      },
      set: function (a) {
        if (this.video) {
          this.video.playbackRate = a;
        }
      }
    });
    Object.defineProperty(b.Video.prototype, "loop", {
      get: function () {
        return !!this.video && this.video.loop;
      },
      set: function (a) {
        if (a && this.video) {
          this.video.loop = "loop";
        } else if (this.video) {
          this.video.loop = "";
        }
      }
    });
    Object.defineProperty(b.Video.prototype, "playing", {
      get: function () {
        return !(this.video.paused && this.video.ended);
      }
    });
    b.Video.prototype.constructor = b.Video;
    if (undefined === PIXI.blendModes) {
      PIXI.blendModes = b.blendModes;
    }
    if (undefined === PIXI.scaleModes) {
      PIXI.scaleModes = b.scaleModes;
    }
    if (undefined === PIXI.Texture.emptyTexture) {
      PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture());
    }
    if (undefined === PIXI.DisplayObject._tempMatrix) {
      PIXI.DisplayObject._tempMatrix = new PIXI.Matrix();
    }
    if (undefined === PIXI.RenderTexture.tempMatrix) {
      PIXI.RenderTexture.tempMatrix = new PIXI.Matrix();
    }
    if (PIXI.Graphics && undefined === PIXI.Graphics.POLY) {
      PIXI.Graphics.POLY = b.POLYGON;
      PIXI.Graphics.RECT = b.RECTANGLE;
      PIXI.Graphics.CIRC = b.CIRCLE;
      PIXI.Graphics.ELIP = b.ELLIPSE;
      PIXI.Graphics.RREC = b.ROUNDEDRECTANGLE;
    }
    PIXI.TextureSilentFail = true;
    if ("undefined" != typeof exports) {
      if ("undefined" != typeof module && module.exports) {
        exports = module.exports = b;
      }
      exports.Phaser = b;
    } else if ("undefined" != typeof define && define.amd) {
      define("Phaser", function () {
        return a.Phaser = b;
      }());
    } else {
      a.Phaser = b;
    }
    return b;
  }).call(this);
  var ParkingFury = {
    render_textures_created: null,
    s_menu: null,
    s_ingame: null,
    s_splash: null,
    s_check: null,
    s_hit: null,
    s_engine: null,
    s_star: null,
    sound_enabled: null,
    score: null,
    levels: null,
    currentLevel: null,
    currentStars: null,
    levelsStars: null,
    save: null,
    load: null,
    sound_ON_OFF: null,
    mobile_browser: null,
    allLevelsUnlocked: null
  };
  ParkingFury.Boot = function (a) {};
  unlockAllLevels = function () {
    console.log("UNLOCK ALL");
    for (var a = 0; a < levelsStars.length; a++) {
      if (levelsStars[a] < 0) {
        levelsStars[a] = 0;
      }
    }
    allLevelsUnlocked = true;
  };
  ParkingFury.Boot.prototype = {
    init: function () {
      s_menu = null;
      s_ingame = null;
      s_splash = null;
      s_check = null;
      s_hit = null;
      s_engine = null;
      s_star = null;
      sound_enabled = true;
      if (this.game.device.desktop) {
        mobile_browser = false;
      } else {
        mobile_browser = true;
        if (navigator.userAgent.match(/Windows NT/i)) {
          mobile_browser = false;
        }
      }
      sound_ON_OFF = function () {
        sound_enabled = !sound_enabled;
        s_menu.mute = !sound_enabled;
        s_ingame.mute = !sound_enabled;
        s_splash.mute = !sound_enabled;
        s_check.mute = !sound_enabled;
        s_hit.mute = !sound_enabled;
        s_engine.mute = !sound_enabled;
        s_star.mute = !sound_enabled;
      };
      save = function () {
        try {
          localStorage.setItem("ParkingFury2_01", JSON.stringify(levelsStars));
        } catch (a) {
          console.log("Your web browser does not support storing settings locally. In Safari, the most common cause of this is using \"Private Browsing Mode\". Some settings may not save or some features may not work properly for you.");
        }
      };
      load = function () {
        var a = localStorage.getItem("ParkingFury2_01");
        if (a) {
          console.log("Seves Exist");
          levelsStars = JSON.parse(a);
        } else {
          console.log("Saves Not Exist");
        }
      };
      this.game.tweens.frameBased = true;
      render_textures_created = false;
      currentLevel = 0;
      currentStars = 0;
      levelsStars = [0, -1, -1, -1, -1, -1, -1, -1, -1, -1];
      allLevelsUnlocked = false;
      score = 66;
      this.input.maxPointers = 2;
      this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
      this.game.scale.pageAlignHorizontally = true;
      this.game.scale.pageAlignVertically = true;
      load();
    },
    preload: function () {
      this.load.image("preloaderBackground", "assets/background_menu.png");
      this.load.image("preloaderBar", "assets/loader.png");
      this.load.image("game_logo", "assets/game_logo.png");
      this.load.image("game_logo_number", "assets/game_logo_number.png");
    },
    create: function () {
      this.state.start("Preloader");
    }
  };
  ParkingFury.Preloader = function (a) {
    this.background = null;
    this.preloadBar = null;
    this.ready = false;
  };
  ParkingFury.Preloader.prototype = {
    preload: function () {
      this.background = this.add.sprite(0, 0, "preloaderBackground");
      this.background.anchor.setTo(.5, .5);
      this.background.x = 320;
      this.background.y = 240;
      var a = this.add.sprite(280, 130, "game_logo");
      a.scale.setTo(.8, .8);
      a.anchor.setTo(.5, .5);
      var b = this.add.sprite(470, 110, "game_logo_number");
      b.scale.setTo(.8, .8);
      b.anchor.setTo(.5, .5);
      this.preloadBar = this.add.sprite(90, 400, "preloaderBar");
      this.load.setPreloadSprite(this.preloadBar);
      this.load.image("btn_play", "assets/btn_play.png");
      this.load.image("btn_more", "assets/btn_more_games.png");
      this.load.image("btn_credits", "assets/btn_credits.png");
      this.load.image("btn_home", "assets/btn_home.png");
      this.load.image("btn_restart", "assets/btn_restart.png");
      this.load.image("btn_back", "assets/btn_back.png");
      this.load.image("bkg_pattern", "assets/bkg_pattern.png");
      this.load.image("btn_levels", "assets/btn_levels.png");
      this.load.image("logo105", "assets/logo105.png");
      this.load.image("car_shadow", "assets/cars/car_shadow.png");
      this.load.image("car_wheel", "assets/cars/car_wheel.png");
      this.load.image("c2_1.png", "assets/cars/c2_1.png");
      this.load.image("c2_2.png", "assets/cars/c2_2.png");
      this.load.image("c3_1.png", "assets/cars/c3_1.png");
      this.load.image("c3_2.png", "assets/cars/c3_2.png");
      this.load.image("c3_3.png", "assets/cars/c3_3.png");
      this.load.image("c3_4.png", "assets/cars/c3_4.png");
      this.load.image("c4_1.png", "assets/cars/c4_1.png");
      this.load.image("c4_2.png", "assets/cars/c4_2.png");
      this.load.image("c4_3.png", "assets/cars/c4_3.png");
      this.load.image("c5_1.png", "assets/cars/c5_1.png");
      this.load.image("c5_2.png", "assets/cars/c5_2.png");
      this.load.image("c5_3.png", "assets/cars/c5_3.png");
      this.load.image("c6_1.png", "assets/cars/c6_1.png");
      this.load.image("c6_2.png", "assets/cars/c6_2.png");
      this.load.image("c6_3.png", "assets/cars/c6_3.png");
      this.load.image("hero_car_1.png", "assets/cars/hero_car_1.png");
      this.load.image("hero_car_2.png", "assets/cars/hero_car_2.png");
      this.load.image("bus_school.png", "assets/cars/bus_school.png");
      this.load.image("gruz.png", "assets/cars/gruz.png");
      this.load.image("car_n_0.png", "assets/cars/car_n_0.png");
      this.load.image("car_n_1.png", "assets/cars/car_n_1.png");
      this.load.image("car_n_2.png", "assets/cars/car_n_2.png");
      this.load.image("car_n_3.png", "assets/cars/car_n_3.png");
      this.load.image("car_n_5.png", "assets/cars/car_n_5.png");
      this.load.image("car_n_6.png", "assets/cars/car_n_6.png");
      this.load.image("car_n_7.png", "assets/cars/car_n_7.png");
      this.load.image("car_n_8.png", "assets/cars/car_n_8.png");
      this.load.image("car_n_9.png", "assets/cars/car_n_9.png");
      this.load.image("car_n_10.png", "assets/cars/car_n_10.png");
      this.load.image("car_n_11.png", "assets/cars/car_n_11.png");
      this.load.image("car_n_12.png", "assets/cars/car_n_12.png");
      this.load.image("car_n_13.png", "assets/cars/car_n_13.png");
      this.load.image("car_n_14.png", "assets/cars/car_n_14.png");
      this.load.image("car_n_15.png", "assets/cars/car_n_15.png");
      this.load.image("car_n_16.png", "assets/cars/car_n_16.png");
      this.load.image("car_n_17.png", "assets/cars/car_n_17.png");
      this.load.image("car_n_18.png", "assets/cars/car_n_18.png");
      this.load.image("trailer_1.png", "assets/cars/trailer_1.png");
      this.load.image("gruz_pricep.png", "assets/cars/gruz_pricep.png");
      this.game.load.json("car_1", "assets/json/cars/car_1.json");
      this.game.load.json("car_2", "assets/json/cars/car_2.json");
      this.game.load.json("car_3", "assets/json/cars/car_3.json");
      this.game.load.json("car_4", "assets/json/cars/car_4.json");
      this.game.load.json("car_5", "assets/json/cars/car_5.json");
      this.game.load.json("car_6", "assets/json/cars/car_6.json");
      this.game.load.json("car_7", "assets/json/cars/car_7.json");
      this.game.load.json("car_8", "assets/json/cars/car_8.json");
      this.game.load.json("car_9", "assets/json/cars/car_9.json");
      this.game.load.json("car_10", "assets/json/cars/car_10.json");
      this.game.load.json("car_11", "assets/json/cars/car_11.json");
      this.game.load.json("car_12", "assets/json/cars/car_12.json");
      this.game.load.json("car_13", "assets/json/cars/car_13.json");
      this.game.load.json("car_14", "assets/json/cars/car_14.json");
      this.game.load.json("car_15", "assets/json/cars/car_15.json");
      this.game.load.json("car_16", "assets/json/cars/car_16.json");
      this.game.load.json("car_17", "assets/json/cars/car_17.json");
      this.game.load.json("car_18", "assets/json/cars/car_18.json");
      this.game.load.json("car_19", "assets/json/cars/car_19.json");
      this.game.load.json("car_20", "assets/json/cars/car_20.json");
      this.game.load.json("car_21", "assets/json/cars/car_21.json");
      this.game.load.json("car_22", "assets/json/cars/car_22.json");
      this.game.load.json("car_23", "assets/json/cars/car_23.json");
      this.game.load.json("car_24", "assets/json/cars/car_24.json");
      this.game.load.json("car_25", "assets/json/cars/car_25.json");
      this.game.load.json("car_26", "assets/json/cars/car_26.json");
      this.game.load.json("car_27", "assets/json/cars/car_27.json");
      this.game.load.json("car_28", "assets/json/cars/car_28.json");
      this.game.load.json("car_29", "assets/json/cars/car_29.json");
      this.game.load.json("car_30", "assets/json/cars/car_30.json");
      this.game.load.json("car_31", "assets/json/cars/car_31.json");
      this.game.load.json("car_32", "assets/json/cars/car_32.json");
      this.game.load.json("car_33", "assets/json/cars/car_33.json");
      this.game.load.json("car_34", "assets/json/cars/car_34.json");
      this.game.load.json("car_35", "assets/json/cars/car_35.json");
      this.game.load.json("car_36", "assets/json/cars/car_36.json");
      this.game.load.json("car_37", "assets/json/cars/car_37.json");
      this.game.load.json("car_38", "assets/json/cars/car_38.json");
      this.game.load.json("car_39", "assets/json/cars/car_39.json");
      this.game.load.json("car_40", "assets/json/cars/car_40.json");
      this.game.load.json("pricep_1", "assets/json/cars/pricep_1.json");
      this.game.load.json("pricep_3", "assets/json/cars/pricep_3.json");
      this.game.load.json("level_0", "assets/json/levels/level_0.json");
      this.game.load.json("level_0_ground", "assets/json/levels/level_0_ground.json");
      this.game.load.json("level_0_decals", "assets/json/levels/level_0_decals.json");
      this.game.load.json("level_0_missions", "assets/json/levels/level_0_missions.json");
      this.game.load.json("level_0_phys", "assets/json/levels/level_0_phys.json");
      this.game.load.json("level_1", "assets/json/levels/level_1.json");
      this.game.load.json("level_1_ground", "assets/json/levels/level_1_ground.json");
      this.game.load.json("level_1_decals", "assets/json/levels/level_1_decals.json");
      this.game.load.json("level_1_missions", "assets/json/levels/level_1_missions.json");
      this.game.load.json("level_1_phys", "assets/json/levels/level_1_phys.json");
      this.game.load.json("level_2", "assets/json/levels/level_2.json");
      this.game.load.json("level_2_ground", "assets/json/levels/level_2_ground.json");
      this.game.load.json("level_2_decals", "assets/json/levels/level_2_decals.json");
      this.game.load.json("level_2_missions", "assets/json/levels/level_2_missions.json");
      this.game.load.json("level_2_phys", "assets/json/levels/level_2_phys.json");
      this.game.load.json("level_3", "assets/json/levels/level_3.json");
      this.game.load.json("level_3_ground", "assets/json/levels/level_3_ground.json");
      this.game.load.json("level_3_decals", "assets/json/levels/level_3_decals.json");
      this.game.load.json("level_3_missions", "assets/json/levels/level_3_missions.json");
      this.game.load.json("level_3_phys", "assets/json/levels/level_3_phys.json");
      this.game.load.json("level_4", "assets/json/levels/level_4.json");
      this.game.load.json("level_4_ground", "assets/json/levels/level_4_ground.json");
      this.game.load.json("level_4_decals", "assets/json/levels/level_4_decals.json");
      this.game.load.json("level_4_missions", "assets/json/levels/level_4_missions.json");
      this.game.load.json("level_4_phys", "assets/json/levels/level_4_phys.json");
      this.game.load.json("level_5", "assets/json/levels/level_5.json");
      this.game.load.json("level_5_ground", "assets/json/levels/level_5_ground.json");
      this.game.load.json("level_5_decals", "assets/json/levels/level_5_decals.json");
      this.game.load.json("level_5_missions", "assets/json/levels/level_5_missions.json");
      this.game.load.json("level_5_phys", "assets/json/levels/level_5_phys.json");
      this.game.load.json("level_6", "assets/json/levels/level_6.json");
      this.game.load.json("level_6_ground", "assets/json/levels/level_6_ground.json");
      this.game.load.json("level_6_decals", "assets/json/levels/level_6_decals.json");
      this.game.load.json("level_6_missions", "assets/json/levels/level_6_missions.json");
      this.game.load.json("level_6_phys", "assets/json/levels/level_6_phys.json");
      this.game.load.json("level_7", "assets/json/levels/level_7.json");
      this.game.load.json("level_7_ground", "assets/json/levels/level_7_ground.json");
      this.game.load.json("level_7_decals", "assets/json/levels/level_7_decals.json");
      this.game.load.json("level_7_missions", "assets/json/levels/level_7_missions.json");
      this.game.load.json("level_7_phys", "assets/json/levels/level_7_phys.json");
      this.game.load.json("level_8", "assets/json/levels/level_8.json");
      this.game.load.json("level_8_ground", "assets/json/levels/level_8_ground.json");
      this.game.load.json("level_8_decals", "assets/json/levels/level_8_decals.json");
      this.game.load.json("level_8_missions", "assets/json/levels/level_8_missions.json");
      this.game.load.json("level_8_phys", "assets/json/levels/level_8_phys.json");
      this.game.load.json("level_9", "assets/json/levels/level_9.json");
      this.game.load.json("level_9_ground", "assets/json/levels/level_9_ground.json");
      this.game.load.json("level_9_decals", "assets/json/levels/level_9_decals.json");
      this.game.load.json("level_9_missions", "assets/json/levels/level_9_missions.json");
      this.game.load.json("level_9_phys", "assets/json/levels/level_9_phys.json");
      this.game.load.json("map_part_plitka_1.json", "assets/json/clips/map_part_plitka_1.json");
      this.game.load.json("map_part_plitka_2.json", "assets/json/clips/map_part_plitka_2.json");
      this.game.load.json("map_part_plitka_3.json", "assets/json/clips/map_part_plitka_3.json");
      this.game.load.json("map_part_plitka_4.json", "assets/json/clips/map_part_plitka_4.json");
      this.game.load.json("map_part_trava_1.json", "assets/json/clips/map_part_trava_1.json");
      this.game.load.json("map_part_trava_2.json", "assets/json/clips/map_part_trava_2.json");
      this.game.load.json("map_part_trava_3.json", "assets/json/clips/map_part_trava_3.json");
      this.game.load.json("map_part_trava_4.json", "assets/json/clips/map_part_trava_4.json");
      this.load.image("flare", "assets/flare.png");
      this.load.image("asphalt_1.jpg", "assets/textures/asphalt_1.jpg");
      this.load.image("Bruk.png", "assets/textures/Bruk.png");
      this.load.image("asphalt_2.png", "assets/textures/asphalt_2.png");
      this.load.image("Trotuar.jpg", "assets/textures/Trotuar.jpg");
      this.load.image("Trava.jpg", "assets/textures/Trava.jpg");
      this.load.image("House.jpg", "assets/textures/House.jpg");
      this.load.image("roof.jpg", "assets/textures/roof.jpg");
      this.load.image("Tree1.png", "assets/textures/Tree1.png");
      this.load.image("Tree2.png", "assets/textures/Tree2.png");
      this.load.image("Barrels.png", "assets/textures/Barrels.png");
      this.load.image("Barrels2.png", "assets/textures/Barrels2.png");
      this.load.image("beton.png", "assets/textures/beton.png");
      this.load.image("Car.png", "assets/textures/Car.png");
      this.load.image("Door.png", "assets/textures/Door.png");
      this.load.image("Klumba.jpg", "assets/textures/Klumba.jpg");
      this.load.image("Musor1.png", "assets/textures/Musor1.png");
      this.load.image("Musor2.png", "assets/textures/Musor2.png");
      this.load.image("Zabor_X1.jpg", "assets/textures/Zabor_X1.jpg");
      this.load.image("Zabor_X1_2.jpg", "assets/textures/Zabor_X1_2.jpg");
      this.load.image("Zabor_X3.jpg", "assets/textures/Zabor_X3.jpg");
      this.load.image("wood_box.png", "assets/textures/wood_box.png");
      this.load.image("Bordur_Long.jpg", "assets/textures/Bordur_Long.jpg");
      this.load.image("Bordur_rot.png", "assets/textures/Bordur_rot.png");
      this.load.image("Bordur_Short.jpg", "assets/textures/Bordur_Short.jpg");
      this.load.image("Zebra.png", "assets/textures/Zebra.png");
      this.load.image("razmetka.png", "assets/textures/razmetka.png");
      this.load.image("decal_wood_box.png", "assets/textures/decal_wood_box.png");
      this.load.image("decal_01.png", "assets/textures/decal_01.png");
      this.load.image("decal_02.png", "assets/textures/decal_02.png");
      this.load.image("decal_03.png", "assets/textures/decal_03.png");
      this.load.image("decal_04.png", "assets/textures/decal_04.png");
      this.load.image("decal_05.png", "assets/textures/decal_05.png");
      this.load.image("decal_06.png", "assets/textures/decal_06.png");
      this.load.image("decal_07.png", "assets/textures/decal_07.png");
      this.load.image("decal_08.png", "assets/textures/decal_08.png");
      this.load.image("decal_09.png", "assets/textures/decal_09.png");
      this.load.image("decal_10.png", "assets/textures/decal_10.png");
      this.load.image("decal_paleta.png", "assets/textures/decal_paleta.png");
      this.load.image("arrow_direct.png", "assets/textures/arrow_direct.png");
      this.load.image("arrow_fin.png", "assets/textures/arrow_fin.png");
      this.load.image("arrow_turn.png", "assets/textures/arrow_turn.png");
      this.load.spritesheet("btn_sound", "assets/btn_sound_frames.png", 92, 91);
      this.load.spritesheet("star", "assets/star_frames.png", 96, 92);
      this.load.image("gui_stars_bkg", "assets/gui_stars_bkg.png");
      this.load.image("gui_mission_complete", "assets/gui_mission_complete.png");
      this.load.image("check", "assets/check.png");
      this.load.image("fail", "assets/fail.png");
      this.load.image("gui_wheel", "assets/gui_wheel.png");
      this.load.image("gui_pedal_gas", "assets/gui_pedal_gas.png");
      this.load.image("gui_pedal_brake", "assets/gui_pedal_brake.png");
      this.load.bitmapFont("myfont", "assets/font.png", "assets/font.fnt");
      this.load.audio("music_menu", ["assets/sounds/menu_music.ogg", "assets/sounds/menu_music.mp3"]);
      this.load.audio("music_game", ["assets/sounds/ingame_FunkGameLoop.ogg", "assets/sounds/ingame_FunkGameLoop.mp3"]);
      this.load.audio("music_splash", ["assets/sounds/splash.ogg", "assets/sounds/splash.mp3"]);
      this.load.audio("music_check", ["assets/sounds/check.ogg", "assets/sounds/check.mp3"]);
      this.load.audio("music_hit", ["assets/sounds/HitSound.ogg", "assets/sounds/HitSound.mp3"]);
      this.load.audio("music_engine", ["assets/sounds/engine_rev.ogg", "assets/sounds/engine_rev.mp3"]);
      this.load.audio("music_star", ["assets/sounds/star.ogg", "assets/sounds/star.mp3"]);
      this.load.atlas("spark", "assets/spark_frames.png", "assets/spark_frames.json");
      this.load.image("coolmath_logo", "assets/coolmath_logo.png");
    },
    create: function () {
      console.log("PRELOADER");
      this.preloadBar.cropEnabled = false;
    },
    startMainMenu: function () {
      console.log("Start MainMenu");
      this.game.state.start("MainMenu", true, false, "splash");
    },
    update: function () {
      if (this.cache.isSoundDecoded("music_menu") && 0 == this.ready) {
        this.ready = true;
        this.startMainMenu();
      }
    }
  };
  ParkingFury.MainMenu = function (a) {
    this.background;
    this.menu_splash;
    this.menu_main;
    this.menu_result;
    this.menu_levels;
    this.menu_credits;
    this.star_r_1;
    this.star_r_2;
    this.star_r_3;
    this.result_score_text;
    this.result_flare;
    this.menu_to_show;
    this.levels_buttons;
  };
  ParkingFury.MainMenu.prototype = {
    init: function (a) {
      this.game.stage.disableVisibilityChange = true;
      this.menu_to_show = 0;
      if (a) {
        this.menu_to_show = "result" == a ? 1 : "splash" == a ? 2 : 0;
      }
      this.levels_buttons = [];
    },
    create: function () {
      if (!s_menu) {
        s_menu = this.game.add.audio("music_menu");
        s_menu.volume = 1;
        s_menu.loop = true;
        s_ingame = this.game.add.audio("music_game");
        s_ingame.volume = 1;
        s_ingame.loop = true;
        s_check = this.game.add.audio("music_check");
        s_hit = this.game.add.audio("music_hit");
        s_hit.volume = .8;
        s_engine = this.game.add.audio("music_engine");
        s_engine.volume = .7;
        s_splash = this.game.add.audio("music_splash");
        s_star = this.game.add.audio("music_star");
      }
      s_menu.play();
      this.game.world.scale.set(1);
      this.background = this.add.sprite(0, 0, "preloaderBackground");
      this.background.anchor.setTo(.1, .1);
      this.menu_splash = this.game.add.group();
      this.menu_splash.position.x = 320;
      this.menu_splash.position.y = 240;
      this.splash_graphics = this.game.add.graphics(-320, -240);
      this.splash_graphics.beginFill(0);
      this.splash_graphics.drawRect(0, 0, 640, 480);
      this.splash_graphics.endFill();
      this.menu_splash.addChild(this.splash_graphics);
      this.splash_logo = this.menu_splash.create(0, 0, "coolmath_logo");
      this.splash_logo.scale.setTo(.7, .7);
      this.splash_logo.anchor.setTo(.5, .5);
      this.menu_main = this.game.add.group();
      this.menu_main.create(44, -23, "game_logo");
      this.menu_main.create(445, 21, "game_logo_number");
      var c = this.menu_main.create(442, 278, "btn_play");
      c.anchor.setTo(.5, .5);
      c.inputEnabled = true;
      c.input.useHandCursor = true;
      c.events.onInputOver.add(this.over, this);
      c.events.onInputOut.add(this.out, this);
      c.events.onInputDown.add(this.play_pressed, this);
      var d = this.menu_main.create(495, 400, "btn_credits");
      d.anchor.setTo(.5, .5);
      d.inputEnabled = true;
      d.input.useHandCursor = true;
      d.events.onInputOver.add(this.over, this);
      d.events.onInputOut.add(this.out, this);
      d.events.onInputDown.add(this.credits_pressed, this);
      var e = this.menu_main.create(568, 316, "btn_sound");
      e.anchor.setTo(.5, .5);
      e.inputEnabled = true;
      e.input.useHandCursor = true;
      e.events.onInputOver.add(this.over, this);
      e.events.onInputOut.add(this.out, this);
      e.events.onInputDown.add(this.sound_pressed, this);
      if (sound_enabled) {
        e.frame = 0;
      } else {
        e.frame = 1;
      }
      this.menu_result = this.game.add.group();
      var f = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
      this.menu_result.addChild(f);
      var g = this.game.add.graphics(0, 76.1);
      this.menu_result.addChild(g);
      g.beginFill(16569617);
      g.drawRect(0, 0, 640, 6.7);
      g.endFill();
      var h = this.game.add.bitmapText(208, 37, "myfont", "LEVEL RESULT", 28);
      this.menu_result.addChild(h);
      var i = this.game.add.tileSprite(144.95, 104, 360, 229, "bkg_pattern");
      this.menu_result.addChild(i);
      this.star_r_1 = this.menu_result.create(320, 186.25, "star");
      this.star_r_1.anchor.setTo(.5, .5);
      this.star_r_1.frame = 0;
      this.star_r_2 = this.menu_result.create(241.3, 211.8, "star");
      this.star_r_2.anchor.setTo(.5, .5);
      this.star_r_2.scale.setTo(.9, .9);
      this.star_r_2.frame = 1;
      this.star_r_3 = this.menu_result.create(398.25, 211.8, "star");
      this.star_r_3.anchor.setTo(.5, .5);
      this.star_r_3.scale.setTo(.9, .9);
      this.star_r_3.frame = 2;
      var k = this.game.add.graphics(155, 310);
      this.menu_result.addChild(k);
      k.beginFill(16569617);
      k.drawRect(0, 0, 340, 6.7);
      k.endFill();
      var l = this.menu_result.create(75.3, 420.3, "btn_home");
      l.anchor.setTo(.5, .5);
      l.inputEnabled = true;
      l.input.useHandCursor = true;
      l.events.onInputOver.add(this.over, this);
      l.events.onInputOut.add(this.out, this);
      l.events.onInputDown.add(this.result_home_pressed, this);
      var m = this.menu_result.create(570.35, 420.3, "btn_back");
      m.scale.setTo(-1, 1);
      m.anchor.setTo(.5, .5);
      m.inputEnabled = true;
      m.input.useHandCursor = true;
      m.events.onInputOver.add(this.over, this);
      m.events.onInputOut.add(this.out, this);
      m.events.onInputDown.add(this.result_next_pressed, this);
      this.result_flare = this.menu_result.create(220, 220, "flare");
      this.result_flare.anchor.setTo(.5, .5);
      this.result_flare.tint = 16776960;
      this.result_flare.blendMode = PIXI.blendModes.ADD;
      this.menu_levels = this.game.add.group();
      var f = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
      this.menu_levels.addChild(f);
      var g = this.game.add.graphics(0, 76.1);
      this.menu_levels.addChild(g);
      g.beginFill(16569617);
      g.drawRect(0, 0, 640, 6.7);
      g.endFill();
      var n = this.game.add.bitmapText(208, 37, "myfont", "SELECT LEVEL", 28);
      this.menu_levels.addChild(n);
      for (var o = 0; o < 10; o++) {
        var p = 301;
        if (o < 5) {
          p = 174;
        }
        var q = 116;
        q += o < 5 ? 105 * o : 105 * (o - 5);
        var r = this.menu_levels.create(q, p, "btn_levels");
        r.anchor.setTo(.5, .5);
        r.inputEnabled = true;
        r.input.useHandCursor = true;
        r.events.onInputOver.add(this.over, this);
        r.events.onInputOut.add(this.out, this);
        r.events.onInputDown.add(this.levelPressed, this);
        var s = this.game.add.bitmapText(0, 0, "myfont", o + 1, 34);
        s.anchor.setTo(.56, .4);
        r.addChild(s);
        var t = this.game.add.group();
        t.y = -39;
        r.addChild(t);
        var u = t.create(0, -4.25, "star");
        u.anchor.setTo(.5, .5);
        u.scale.setTo(.4, .4);
        u.frame = 0;
        var v = t.create(-27.85, 5.95, "star");
        v.anchor.setTo(.5, .5);
        v.scale.setTo(.35, .35);
        v.frame = 0;
        var w = t.create(27.85, 5.95, "star");
        w.anchor.setTo(.5, .5);
        w.scale.setTo(.35, .35);
        w.frame = 0;
        r.label = s;
        r.level = o;
        r.s_1 = u;
        r.s_2 = v;
        r.s_3 = w;
        r.open = true;
        this.levels_buttons[o] = r;
      }
      var x = this.menu_levels.create(75.3, 420.3, "btn_home");
      x.anchor.setTo(.5, .5);
      x.inputEnabled = true;
      x.input.useHandCursor = true;
      x.events.onInputOver.add(this.over, this);
      x.events.onInputOut.add(this.out, this);
      x.events.onInputDown.add(this.levels_home_pressed, this);
      this.initLevels();
      this.menu_credits = this.game.add.group();
      var f = this.game.add.tileSprite(0, 24, 640, 66, "bkg_pattern");
      this.menu_credits.addChild(f);
      var g = this.game.add.graphics(0, 76.1);
      this.menu_credits.addChild(g);
      g.beginFill(16569617);
      g.drawRect(0, 0, 640, 6.7);
      g.endFill();
      var h = this.game.add.bitmapText(320, 37, "myfont", "CREDITS", 28);
      h.anchor.setTo(.5, 0);
      this.menu_credits.addChild(h);
      var i = this.game.add.tileSprite(144.95, 104, 360, 229, "bkg_pattern");
      this.menu_credits.addChild(i);
      var y = this.menu_credits.create(75.3, 420.3, "btn_home");
      y.anchor.setTo(.5, .5);
      y.inputEnabled = true;
      y.input.useHandCursor = true;
      y.events.onInputOver.add(this.over, this);
      y.events.onInputOut.add(this.out, this);
      y.events.onInputDown.add(this.credits_home_pressed, this);
      var h = this.game.add.bitmapText(320, 137, "myfont", "GAME DESIGN AND DEVELOPMENT\nANDRIY PIDVIRNYY\nAKA\nFREES\n\nMUSIC BY\nKEVIN MACLEOD", 16);
      h.align = "center";
      h.anchor.setTo(.5, 0);
      this.menu_credits.addChild(h);
      this.menu_levels.y = -800;
      this.menu_credits.y = -800;
      if (0 == this.menu_to_show) {
        this.menu_result.y = -800;
        this.menu_splash.y = -800;
      } else if (1 == this.menu_to_show) {
        this.menu_main.y = -800;
        this.menu_splash.y = -800;
        this.setResult();
      } else if (2 == this.menu_to_show) {
        this.menu_main.y = -800;
        this.menu_result.y = -800;
        var z = this.game.add.tween(this.splash_logo).to({
          alpha: 0
        }, 150, "Linear", false);
        z.delay(2e3);
        z.start();
        var A = this.game.add.tween(this.splash_graphics).to({
          alpha: 0
        }, 100, "Linear", false);
        A.delay(2150);
        A.onComplete.add(this.spalsh_alpha_callback, this);
        A.start();
      }
    },
    spalsh_alpha_callback: function () {
      this.menu_splash.y = -800;
      this.menu_splash.visible = false;
      this.swap_menus(null, this.menu_main);
    },
    shutdown: function () {
      this.background.destroy();
      this.background = null;
      this.menu_main.destroy();
      this.menu_main = null;
      this.menu_result.destroy();
      this.menu_result = null;
      this.menu_credits.destroy();
      this.menu_credits = null;
      this.menu_levels.destroy();
      this.menu_levels = null;
      this.menu_splash.destroy();
      this.menu_splash = null;
    },
    sound_pressed: function (a, b) {
      sound_ON_OFF();
      if (sound_enabled) {
        a.frame = 0;
      } else {
        a.frame = 1;
      }
    },
    initLevels: function () {
      for (var a = 0; a < 10; a++) {
        if (levelsStars[a] >= 0) {
          this.levels_buttons[a].label.alpha = 1;
          this.levels_buttons[a].open = true;
          if (!(1 != levelsStars[a] && 2 != levelsStars[a])) {
            this.levels_buttons[a].s_1.frame = levelsStars[a];
            this.levels_buttons[a].s_2.frame = 0;
            this.levels_buttons[a].s_3.frame = 0;
          }
          if (!(3 != levelsStars[a] && 4 != levelsStars[a])) {
            this.levels_buttons[a].s_1.frame = 2;
            this.levels_buttons[a].s_2.frame = levelsStars[a] - 2;
            this.levels_buttons[a].s_3.frame = 0;
          }
          if (!(5 != levelsStars[a] && 6 != levelsStars[a])) {
            this.levels_buttons[a].s_1.frame = 2;
            this.levels_buttons[a].s_2.frame = 2;
            this.levels_buttons[a].s_3.frame = levelsStars[a] - 4;
          }
        } else {
          this.levels_buttons[a].label.alpha = .4;
          this.levels_buttons[a].open = false;
          this.levels_buttons[a].s_1.frame = 0;
          this.levels_buttons[a].s_2.frame = 0;
          this.levels_buttons[a].s_3.frame = 0;
        }
      }
    },
    levelPressed: function (a, b) {
      if (a.open) {
        s_menu.stop();
        currentLevel = a.level;
        if (parent.cmgGameEvent) {
          parent.cmgGameEvent("start", "" + (currentLevel + 1));
        }
        this.state.start("Game", true, false);
      }
    },
    setResult: function () {
      this.star_r_1.frame = 0;
      this.star_r_2.frame = 0;
      this.star_r_3.frame = 0;
      var a = 0;
      if (1 == currentStars || 2 == currentStars) {
        var b = this.game.add.tween(this.star_r_1.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        b.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        b.delay(200);
        b.onStart.add(this.star_appear, this);
        b.start();
        this.game.add.tween(this.star_r_1).to({
          frame: currentStars
        }, 1, "Linear", true, 300);
        a = 450;
      }
      if (3 == currentStars || 4 == currentStars) {
        var b = this.game.add.tween(this.star_r_1.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        b.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        b.delay(200);
        b.onStart.add(this.star_appear, this);
        b.start();
        this.game.add.tween(this.star_r_1).to({
          frame: 2
        }, 1, "Linear", true, 300);
        var d = this.game.add.tween(this.star_r_2.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        d.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        d.delay(650);
        d.onStart.add(this.star_appear, this);
        d.start();
        this.game.add.tween(this.star_r_2).to({
          frame: currentStars - 2
        }, 1, "Linear", true, 750);
        a = 900;
      }
      if (5 == currentStars || 6 == currentStars) {
        var b = this.game.add.tween(this.star_r_1.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        b.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        b.delay(200);
        b.onStart.add(this.star_appear, this);
        b.start();
        this.game.add.tween(this.star_r_1).to({
          frame: 2
        }, 1, "Linear", true, 300);
        var d = this.game.add.tween(this.star_r_2.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        d.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        d.delay(650);
        d.onStart.add(this.star_appear, this);
        d.start();
        this.game.add.tween(this.star_r_2).to({
          frame: 2
        }, 1, "Linear", true, 750);
        var f = this.game.add.tween(this.star_r_3.scale).to({
          x: 0,
          y: 0
        }, 100, "Linear", false);
        f.to({
          x: 1,
          y: 1
        }, 400, Phaser.Easing.Elastic.Out, false);
        f.delay(1100);
        f.onStart.add(this.star_appear, this);
        f.start();
        this.game.add.tween(this.star_r_3).to({
          frame: currentStars - 4
        }, 1, "Linear", true, 1200);
        a = 1400;
      }
      this.result_flare.scale.setTo(0, 0);
      this.result_flare.x = 200;
      var h = this.game.add.tween(this.result_flare.scale).to({
        x: 1,
        y: 1
      }, 100, "Linear", false);
      h.to({
        x: 0,
        y: 0
      }, 100, "Linear", false);
      h.delay(a);
      h.start();
      var i = this.game.add.tween(this.result_flare).to({
        x: 440
      }, 100, "Linear", false);
      i.delay(a);
      i.start();
      levelsStars[currentLevel] = currentStars;
      if (currentLevel < 9) {
        currentLevel += 1;
        if (levelsStars[currentLevel] < 0) {
          levelsStars[currentLevel] = 0;
        }
      }
      save();
    },
    star_appear: function () {
      s_star.play();
    },
    result_home_pressed: function (a, b) {
      this.swap_menus(this.menu_result, this.menu_main);
    },
    credits_home_pressed: function (a, b) {
      this.swap_menus(this.menu_credits, this.menu_main);
    },
    levels_home_pressed: function (a, b) {
      this.swap_menus(this.menu_levels, this.menu_main);
    },
    result_next_pressed: function (a, b) {
      this.swap_menus(this.menu_result, this.menu_levels);
      this.initLevels();
    },
    credits_pressed: function (a, b) {
      this.swap_menus(this.menu_main, this.menu_credits);
    },
    play_pressed: function (a, b) {
      if (parent.cmgGameEvent) {
        parent.cmgGameEvent("start");
      }
      this.swap_menus(this.menu_main, this.menu_levels);
      this.initLevels();
    },
    over: function (a, b) {
      if (!(a.label && !a.open)) {
        if (!a.scaleOrig) {
          a.scaleOrig = new Phaser.Point(a.scale.x, a.scale.y);
        }
        a.scale.setTo(1.05 * a.scaleOrig.x, 1.05 * a.scaleOrig.y);
      }
    },
    out: function (a, b) {
      if (!(a.label && !a.open)) {
        a.scale.setTo(a.scaleOrig.x, a.scaleOrig.y);
      }
    },
    swap_menus: function (a, b) {
      s_splash.play();
      this.game.add.tween(a).to({
        y: -800
      }, 200, "Linear", true);
      b.x = 0;
      b.y = -800;
      this.game.add.tween(b).to({
        y: 0
      }, 200, "Linear", true, 200);
    },
    update: function () {
      if (allLevelsUnlocked) {
        this.initLevels();
        allLevelsUnlocked = false;
      }
      var a = 0 - .05 * (this.game.input.x - 320);
      var b = 0 - .05 * (this.game.input.y - 240);
      this.background.x = .15 * a + .85 * this.background.x;
      this.background.y = .15 * b + .85 * this.background.y;
    },
    startGame: function (a) {}
  };
  ParkingFury.BlankState = function (a) {};
  ParkingFury.BlankState.prototype = {
    create: function () {
      this.game.world.scale.set(1);
      this.state.start("Game", true, false);
    }
  };
  ParkingFury.Game = function (a) {
    this.gamePaused = false;
    this.pressTimer = 0;
    this.asphalt;
    this.spark;
    this.car;
    this.carSpeed;
    this.cursors;
    this.wasd;
    this.worldScale = .8;
    this.globalGroup;
    this.globalBmp;
    this.globalBmpImage;
    this.carIndex = 0;
    this.cars = [];
    this.parkZone = null;
    this.parkZones = [];
    this.parkZonesPositions = [];
    this.parkPolys = [];
    this.missions = [];
    this.contactsCount = 0;
    this.missionMessage = false;
    this.stars = 6;
    this.hitTimer = 0;
    this.gui;
    this.gui_stars;
    this.gui_star_1;
    this.gui_star_2;
    this.gui_star_3;
    this.gui_complete;
    this.gui_complete_check;
    this.gui_complete_fail;
    this.text_complete;
    this.check_fail_rect;
    this.check_fail_inProgress = false;
    this.gui_pause;
    this.gui_pause_btn;
    this.up_bmp;
    this.up_bmp_image;
    this.levelFinished;
    this.gui_wheel;
    this.gui_gas;
    this.gui_brake;
    this.gui_gas_pressed = false;
    this.gui_brake_pressed = false;
    this.gui_wheel_pressed = false;
    this.wheel_left = false;
    this.wheel_right = false;
    this.wheelPointer = null;
    this.wheelTouchPosition = null;
    this.invertedControl = false;
    this.music_engine_played = false;
    this.temp_textures = [];
  };
  ParkingFury.Game.prototype = {
    create: function () {
      this.game.world.scale.set(1);
      this.game.time.desiredFps = 60;
      s_ingame.play();
      this.gamePaused = false;
      this.pressTimer = 0;
      this.carSpeed = 0;
      this.worldScale = .8;
      this.carIndex = 0;
      this.cars = [];
      this.parkZone = null;
      this.parkZones = [];
      this.parkZonesPositions = [];
      this.parkPolys = [];
      this.missions = [];
      this.contactsCount = 0;
      this.missionMessage = false;
      this.stars = 6;
      this.hitTimer = 0;
      this.missionMessage = false;
      this.check_fail_inProgress = false;
      this.levelFinished = false;
      this.music_engine_played = false;
      this.game.time.advancedTiming = true;
      this.game.world.setBounds(0, 0, 3e3, 3e3);
      this.game.physics.startSystem(Phaser.Physics.P2JS);
      this.asphalt = this.game.add.tileSprite(0, 0, 3e3, 3e3, "asphalt_1.jpg");
      this.globalBmp = this.game.add.bitmapData(3e3, 3e3);
      this.globalBmpImage = this.globalBmp.addToWorld();
      this.globalBmp.smoothed = false;
      this.globalGroup = this.game.make.group();
      this.cursors = this.game.input.keyboard.createCursorKeys();
      this.wasd = {
        up: this.game.input.keyboard.addKey(Phaser.Keyboard.W),
        down: this.game.input.keyboard.addKey(Phaser.Keyboard.S),
        left: this.game.input.keyboard.addKey(Phaser.Keyboard.A),
        right: this.game.input.keyboard.addKey(Phaser.Keyboard.D)
      };
      this.prepare_render_textures();
      this.load_json_level_decals(currentLevel);
      this.load_json_ground_layer(currentLevel);
      this.load_json_missions(currentLevel);
      this.load_json_level_physics(currentLevel);
      this.load_json_level_objects(currentLevel);
      this.game.camera.follow(this.car.camPoint, Phaser.Camera.FOLLOW_LOCKON, .1, .1);
      this.load_json_level_up(currentLevel);
      this.globalBmp.shadow();
      this.spark = this.game.add.sprite(-300, -200, "spark");
      this.spark.animations.add("blam");
      this.spark.anchor.setTo(.5, .5);
      this.spark.animations.play("blam", 30, false);
      this.gui = this.game.add.group();
      this.game.stage.addChild(this.gui);
      this.gui_stars = this.game.make.group();
      this.gui_stars.create(0, 5, "gui_stars_bkg");
      this.gui_star_1 = this.gui_stars.create(32.9, 23.95, "star");
      this.gui_star_1.anchor.setTo(.5, .5);
      this.gui_star_1.scale.setTo(.324, .324);
      this.gui_star_1.frame = 2;
      this.gui_star_2 = this.gui_stars.create(70.7, 23.95, "star");
      this.gui_star_2.anchor.setTo(.5, .5);
      this.gui_star_2.scale.setTo(.324, .324);
      this.gui_star_2.frame = 2;
      this.gui_star_3 = this.gui_stars.create(107.75, 23.95, "star");
      this.gui_star_3.anchor.setTo(.5, .5);
      this.gui_star_3.scale.setTo(.324, .324);
      this.gui_star_3.frame = 2;
      this.gui.addChild(this.gui_stars);
      if (mobile_browser) {
        this.gui_pause_btn = this.gui.create(640, 5);
        var c = this.game.add.sprite(0, 0, "gui_stars_bkg");
        this.gui_pause_btn.addChild(c);
        c.scale.setTo(-1, 1);
        var d = this.game.add.bitmapText(-110, 7, "myfont", "PAUSE", 22);
        this.gui_pause_btn.addChild(d);
        this.gui_pause_btn.inputEnabled = true;
        this.gui_pause_btn.input.useHandCursor = true;
        this.gui_pause_btn.events.onInputOver.add(this.over, this);
        this.gui_pause_btn.events.onInputOut.add(this.out, this);
        this.gui_pause_btn.events.onInputDown.add(this.pause_pressed, this);
      }
      this.gui_complete = this.game.make.group();
      this.gui_complete.position.setTo(170, -240);
      this.gui_complete.create(-45, -45, "gui_mission_complete");
      this.gui_complete_check = this.gui_complete.create(-22, -38, "check");
      this.gui_complete_fail = this.gui_complete.create(-33, -38, "fail");
      this.text_complete = this.game.add.bitmapText(190, 5, "myfont", "MISSION COMPLETE!", 22);
      this.text_complete.anchor.setTo(.5, .5);
      this.gui_complete.addChild(this.text_complete);
      this.check_fail_rect = new Phaser.Rectangle(0, 0, 0, 74);
      this.gui_complete_check.crop(this.check_fail_rect);
      this.gui_complete_fail.crop(this.check_fail_rect);
      this.gui.addChild(this.gui_complete);
      this.gui_pause = this.game.make.group();
      this.gui_pause.position.setTo(320, -240);
      this.gui_pause.create(-195, -45, "gui_mission_complete");
      var g = this.gui_pause.create(-80, 50, "btn_home");
      g.inputEnabled = true;
      g.input.useHandCursor = true;
      g.events.onInputOver.add(this.over, this);
      g.events.onInputOut.add(this.out, this);
      g.events.onInputDown.add(this.home_pressed, this);
      var h = this.gui_pause.create(40, 50, "btn_restart");
      h.inputEnabled = true;
      h.input.useHandCursor = true;
      h.events.onInputOver.add(this.over, this);
      h.events.onInputOut.add(this.out, this);
      h.events.onInputDown.add(this.restart_pressed, this);
      var i = this.game.add.bitmapText(40, 5, "myfont", "GAME PAUSED", 22);
      i.anchor.setTo(.5, .5);
      this.gui_pause.addChild(i);
      this.gui.addChild(this.gui_pause);
      if (mobile_browser) {
        this.gui_wheel = this.gui.create(95, 390);
        this.gui_wheel.anchor.setTo(.5, .5);
        this.gui_wheel.alpha = .9;
        this.gui_wheel.inputEnabled = true;
        this.gui_wheel.input.useHandCursor = true;
        this.gui_wheel.events.onInputDown.add(this.wheel_down, this);
        this.gui_wheel.events.onInputOut.add(this.wheel_up, this);
        this.gui_wheel.events.onInputUp.add(this.wheel_up, this);
        this.gui_wheel.hitArea = new Phaser.Rectangle(-110, -110, 220, 220);
        var j = this.game.add.sprite(0, 0, "gui_wheel");
        j.anchor.setTo(.5, .5);
        this.gui_wheel.addChild(j);
        this.gui_wheel.label = j;
        this.gui_gas = this.gui.create(590, 400);
        this.gui_gas.anchor.setTo(.5, .5);
        this.gui_gas.alpha = .9;
        this.gui_gas.inputEnabled = true;
        this.gui_gas.input.useHandCursor = true;
        this.gui_gas.events.onInputDown.add(this.gas_down, this);
        this.gui_gas.events.onInputOut.add(this.gas_up, this);
        this.gui_gas.events.onInputUp.add(this.gas_up, this);
        this.gui_gas.hitArea = new Phaser.Rectangle(-45, -80, 90, 160);
        var k = this.game.add.sprite(0, 0, "gui_pedal_gas");
        k.anchor.setTo(.5, .5);
        this.gui_gas.addChild(k);
        this.gui_gas.label = k;
        this.gui_brake = this.gui.create(495, 428);
        this.gui_brake.anchor.setTo(.5, .5);
        this.gui_brake.alpha = .9;
        this.gui_brake.inputEnabled = true;
        this.gui_brake.input.useHandCursor = true;
        this.gui_brake.events.onInputDown.add(this.brake_down, this);
        this.gui_brake.events.onInputOut.add(this.brake_up, this);
        this.gui_brake.events.onInputUp.add(this.brake_up, this);
        this.gui_brake.hitArea = new Phaser.Rectangle(-45, -55, 90, 110);
        var l = this.game.add.sprite(0, 0, "gui_pedal_brake");
        l.anchor.setTo(.5, .5);
        this.gui_brake.addChild(l);
        this.gui_brake.label = l;
      }
      this.game.world.scale.set(this.worldScale);
      this.blinkFlares();
    },
    gas_down: function (a, b) {
      this.gui_gas_pressed = true;
      a.label.scale.setTo(.94, .94);
    },
    gas_up: function (a, b) {
      this.gui_gas_pressed = false;
      a.label.scale.setTo(1, 1);
    },
    brake_down: function (a, b) {
      this.gui_brake_pressed = true;
      a.label.scale.setTo(.94, .94);
    },
    brake_up: function (a, b) {
      this.gui_brake_pressed = false;
      a.label.scale.setTo(1, 1);
    },
    wheel_down: function (a, b) {
      this.gui_wheel_pressed = true;
      this.wheelPointer = b;
      this.wheelTouchPosition = new Phaser.Point(b.x, b.y);
    },
    wheel_up: function (a, b) {
      this.gui_wheel_pressed = false;
      this.wheelPointer = null;
      this.wheelTouchPosition = null;
    },
    over: function (a, b) {
      a.scale.x = 1.05;
      a.scale.y = 1.05;
    },
    out: function (a, b) {
      a.scale.x = 1;
      a.scale.y = 1;
    },
    home_pressed: function (a, b) {
      this.missionMessage = true;
      this.game.state.start("MainMenu", true, false);
    },
    restart_pressed: function (a, b) {
      if (parent.cmgGameEvent) {
        parent.cmgGameEvent("replay", "" + (currentLevel + 1));
      }
      this.missionMessage = true;
      this.game.state.start("BlankState", true, false);
    },
    pause_pressed: function (a, b) {
      this.pause_ON_OFF();
    },
    shutdown: function () {
      s_ingame.stop();
      this.up_bmp.destroy();
      this.up_bmp_image.destroy();
      this.up_bmp = null;
      this.up_bmp_image = null;
      this.gui.removeChild(this.gui_stars);
      this.gui.removeChild(this.gui_complete);
      this.gui.removeChild(this.gui_pause);
      this.game.stage.removeChild(this.gui);
      this.gui_stars.destroy();
      this.gui_stars = null;
      this.gui_complete.destroy();
      this.gui_complete = null;
      this.gui_pause.destroy();
      this.gui_pause = null;
      if (mobile_browser) {
        this.gui.removeChild(this.gui_wheel);
        this.gui.removeChild(this.gui_gas);
        this.gui.removeChild(this.gui_brake);
        this.gui_wheel.destroy();
        this.gui_wheel = null;
        this.gui_gas.destroy();
        this.gui_gas = null;
        this.gui_brake.destroy();
        this.gui_brake = null;
      }
      this.gui.destroy();
      this.gui = null;
      this.asphalt.destroy();
      this.asphalt = null;
      this.spark.destroy();
      this.spark = null;
      this.globalGroup.destroy();
      this.globalBmp.destroy();
      this.globalBmpImage.destroy();
      this.globalGroup = null;
      this.globalBmp = null;
      this.globalBmpImage = null;
      this.cars[0].destroy();
      this.cars = null;
      this.parkZone = null;
      this.parkZones = null;
      this.parkZonesPositions = null;
      this.parkPolys = null;
      this.missions = null;
      this.car.destroy();
      this.car = null;
    },
    gui_show_mission_complete: function () {
      this.gui_complete_check.visible = true;
      this.gui_complete_fail.visible = false;
      if (this.levelFinished) {
        this.text_complete.text = "LEVEL CLEARED!";
      } else {
        this.text_complete.text = "MISSION COMPLETE!";
      }
      this.gui_complete.y = -240;
      var a = this.game.add.tween(this.gui_complete).to({
        y: 240
      }, 200, "Linear", false);
      a.to({
        y: 720
      }, 300, "Linear", false, 1200);
      a.onComplete.add(this.mission_message_disabled, this);
      a.start();
      this.check_fail_rect.width = 0;
      this.check_fail_rect.height = 74;
      var b = this.game.add.tween(this.check_fail_rect).to({
        width: 86
      }, 150, "Linear", false);
      b.delay(400);
      b.onComplete.add(this.gui_check_fail_tween_complete, this);
      b.onStart.add(this.gui_check_fail_tween_start, this);
      b.start();
      this.check_fail_inProgress = true;
      this.missionMessage = true;
    },
    gui_show_failed: function () {
      this.gui_complete_check.visible = false;
      this.gui_complete_fail.visible = true;
      this.text_complete.text = "LEVEL FAILED :(";
      this.gui_complete.y = -240;
      var a = this.game.add.tween(this.gui_complete).to({
        y: 240
      }, 200, "Linear", false);
      a.to({
        y: 720
      }, 300, "Linear", false, 1200);
      a.onComplete.add(this.mission_message_disabled, this);
      a.start();
      this.check_fail_rect.width = 0;
      this.check_fail_rect.height = 77;
      var b = this.game.add.tween(this.check_fail_rect).to({
        width: 67
      }, 150, "Linear", false);
      b.delay(400);
      b.onComplete.add(this.gui_check_fail_tween_complete, this);
      b.onStart.add(this.gui_check_fail_tween_start, this);
      b.start();
      this.check_fail_inProgress = true;
      this.missionMessage = true;
    },
    gui_check_fail_tween_start: function () {
      s_check.play();
    },
    gui_check_fail_tween_complete: function () {
      this.check_fail_inProgress = false;
    },
    mission_message_disabled: function () {
      if (this.stars <= 0) {
        if (parent.cmgGameEvent) {
          parent.cmgGameEvent("replay", "" + (currentLevel + 1));
        }
        this.game.state.start("BlankState", true, false);
      } else if (this.levelFinished) {
        currentStars = this.stars;
        this.game.state.start("MainMenu", true, false, "result");
      } else {
        this.missionMessage = false;
        this.missions[this.carIndex - 1].visible = false;
        this.missions[this.carIndex].visible = true;
        this.game.camera.follow(this.car.camPoint, Phaser.Camera.FOLLOW_LOCKON, .1, .1);
        this.blinkFlares();
      }
    },
    prepare_render_textures: function () {
      if (!render_textures_created) {
        this.make_texture("map_part_plitka_1.json", "map_part_plitka_1");
        this.make_texture("map_part_plitka_2.json", "map_part_plitka_2");
        this.make_texture("map_part_plitka_3.json", "map_part_plitka_3");
        this.make_texture("map_part_plitka_4.json", "map_part_plitka_4");
        this.make_texture("map_part_trava_1.json", "map_part_trava_1");
        this.make_texture("map_part_trava_2.json", "map_part_trava_2");
        this.make_texture("map_part_trava_3.json", "map_part_trava_3");
        this.make_texture("map_part_trava_4.json", "map_part_trava_4");
        render_textures_created = true;
      }
    },
    make_texture: function (a, b) {
      var c = this.game.cache.getJSON(a);
      var d = this.game.make.group();
      var e = this.game.make.tileSprite(c.base_sprite.x, c.base_sprite.y, c.base_sprite.w, c.base_sprite.h, c.base_sprite.texture);
      d.addChild(e);
      var f = this.game.add.graphics(1500, 1500);
      f.beginFill(16777215);
      for (i in c.shape_points) if (0 == i) {
        f.moveTo(c.shape_points[i][0] + c.base_sprite.fixX, c.shape_points[i][1] + c.base_sprite.fixY);
      } else {
        f.lineTo(c.shape_points[i][0] + c.base_sprite.fixX, c.shape_points[i][1] + c.base_sprite.fixY);
      }
      f.endFill();
      e.mask = f;
      for (i in c.bordurs) {
        var g = d.create(c.bordurs[i].x, c.bordurs[i].y, c.bordurs[i].name);
        g.angle = c.bordurs[i].rotation;
        g.scale.setTo(c.bordurs[i].scaleX, c.bordurs[i].scaleY);
      }
      var h = d.generateTexture();
      this.game.world.remove(d, true);
      d = null;
      this.game.world.remove(f, true);
      f = null;
      this.game.cache.addImage(b, null, h.getCanvas());
      h = null;
      c = null;
    },
    load_json_missions: function (a) {
      var b = this.game.cache.getJSON("level_" + a + "_missions");
      for (i in b.frames) {
        var c = this.game.add.group();
        for (ii in b.frames[i].objects) {
          var d = c.create(b.frames[i].objects[ii].x, b.frames[i].objects[ii].y, b.frames[i].objects[ii].name);
          d.angle = b.frames[i].objects[ii].rotation;
          d.scale.setTo(b.frames[i].objects[ii].scaleX, b.frames[i].objects[ii].scaleY);
        }
        this.missions[i] = c;
        c.visible = false;
      }
      this.missions[0].visible = true;
      b = null;
    },
    load_json_level_objects: function (a) {
      var b = this.game.cache.getJSON("level_" + a);
      var c = this.game.make.group();
      for (i in b.objects) {
        var d = c.create(b.objects[i].x, b.objects[i].y, b.objects[i].name);
        d.angle = b.objects[i].rotation;
        d.scale.setTo(b.objects[i].scaleX, b.objects[i].scaleY);
      }
      this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1);
      this.game.stage.updateTransform();
      this.globalBmp.drawGroup(c);
      this.globalBmp.shadow();
      d = null;
      this.game.world.remove(c, true);
      c.destroy();
      c = null;
      b = null;
    },
    load_json_ground_layer: function (a) {
      var b = this.game.cache.getJSON("level_" + a + "_ground");
      var c = this.game.make.group();
      for (var d = 0; d < b.ground_objects.length; d++) {
        if ("bitmap" == b.ground_objects[d].type) {
          var e = c.create(b.ground_objects[d].x, b.ground_objects[d].y, b.ground_objects[d].name);
          e.angle = b.ground_objects[d].rotation;
          e.scale.setTo(b.ground_objects[d].scaleX, b.ground_objects[d].scaleY);
          e.anchor.setTo(.5, .5);
          e = null;
        } else {
          var f = this.game.make.group();
          var g = this.game.add.tileSprite(b.ground_objects[d].x, b.ground_objects[d].y, b.ground_objects[d].w, b.ground_objects[d].h, b.ground_objects[d].texture);
          f.addChild(g);
          var h = this.game.add.graphics(0, 0);
          h.beginFill(16777215);
          for (ii in b.ground_objects[d].points) if (0 == ii) {
            h.moveTo(b.ground_objects[d].points[ii][0] - b.ground_objects[d].x, b.ground_objects[d].points[ii][1] - b.ground_objects[d].y);
          } else {
            h.lineTo(b.ground_objects[d].points[ii][0] - b.ground_objects[d].x, b.ground_objects[d].points[ii][1] - b.ground_objects[d].y);
          }
          h.endFill();
          g.mask = h;
          var i = f.generateTexture();
          this.game.world.remove(h, true);
          h.destroy();
          h = null;
          this.game.world.remove(g, true);
          g.destroy();
          g = null;
          this.game.world.remove(f, true);
          f.destroy();
          f = null;
          c.create(b.ground_objects[d].x, b.ground_objects[d].y, i);
          this.temp_textures.push(i);
        }
      }
      if (mobile_browser) {
        this.globalBmp.shadow();
        this.game.stage.updateTransform();
        this.globalBmp.drawGroup(c);
        this.globalBmp.shadow();
        this.game.world.remove(c, true);
        c.destroy();
        c = null;
      } else {
        var j = this.game.add.bitmapData(3e3, 3e3);
        var k = j.addToWorld();
        this.game.stage.updateTransform();
        j.smoothed = false;
        j.drawGroup(c);
        this.game.world.remove(c, true);
        c.destroy();
        c = null;
        this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1);
        this.game.stage.updateTransform();
        this.globalBmp.draw(k);
        this.globalBmp.shadow();
        this.game.world.remove(k, true);
        k.destroy();
        j.destroy();
        k = null;
        j = null;
      }
      for (; this.temp_textures.length > 0;) {
        var l = this.temp_textures.pop();
        l.destroy(true);
        l = null;
      }
      this.temp_textures = [];
      b = null;
    },
    load_json_level_decals: function (a) {
      var b = this.game.cache.getJSON("level_" + a + "_decals");
      var c = this.game.make.group();
      for (i in b.shapes) {
        var d = this.game.make.group();
        var e = this.game.add.tileSprite(b.shapes[i].x, b.shapes[i].y, b.shapes[i].w, b.shapes[i].h, b.shapes[i].texture);
        d.addChild(e);
        var f = this.game.add.graphics(0, 0);
        f.beginFill(16777215);
        for (ii in b.shapes[i].points) if (0 == ii) {
          f.moveTo(b.shapes[i].points[ii][0] - b.shapes[i].x, b.shapes[i].points[ii][1] - b.shapes[i].y);
        } else {
          f.lineTo(b.shapes[i].points[ii][0] - b.shapes[i].x, b.shapes[i].points[ii][1] - b.shapes[i].y);
        }
        f.endFill();
        e.mask = f;
        var g = d.generateTexture();
        this.game.world.remove(f, true);
        f.destroy();
        f = null;
        this.game.world.remove(e, true);
        e.destroy();
        e = null;
        this.game.world.remove(d, true);
        d.destroy();
        d = null;
        var h = c.create(b.shapes[i].x, b.shapes[i].y, g);
      }
      for (i in b.decals) {
        var h = c.create(b.decals[i].x, b.decals[i].y, b.decals[i].name);
        h.scale.setTo(b.decals[i].scaleX, b.decals[i].scaleY);
        h.angle = b.decals[i].rotation;
      }
      for (i in b.decals_additional) {
        var h = c.create(b.decals_additional[i].x, b.decals_additional[i].y, b.decals_additional[i].name);
        h.scale.setTo(b.decals_additional[i].scaleX, b.decals_additional[i].scaleY);
        h.angle = b.decals_additional[i].rotation;
      }
      this.globalBmp.shadow();
      this.game.stage.updateTransform();
      this.globalBmp.drawGroup(c);
      this.game.world.remove(c);
      c.destroy();
      c = null;
      b = null;
    },
    load_json_level_up: function (a) {
      var b = this.game.cache.getJSON("level_" + a);
      var c = this.game.make.group();
      for (i in b.up) {
        c.create(b.up[i].x, b.up[i].y, b.up[i].name).angle = b.up[i].rotation;
      }
      if (!mobile_browser) {
        this.globalBmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1);
        this.game.stage.updateTransform();
        this.globalBmp.drawGroup(c);
        this.globalBmp.shadow();
      }
      this.up_bmp = this.game.add.bitmapData(3e3, 3e3);
      this.up_bmp_image = this.up_bmp.addToWorld();
      this.up_bmp.shadow("rgba(0,0,0,0.9)", 30, 1, 1);
      this.game.stage.updateTransform();
      this.up_bmp.smoothed = false;
      this.up_bmp.drawGroup(c);
      this.up_bmp.shadow();
      this.game.world.remove(c);
      c.destroy(true);
      c = null;
      b = null;
    },
    load_json_level_physics: function (a) {
      var c = this.game.cache.getJSON("level_" + a + "_phys");
      var d = 0;
      for (d in c.boxes) {
        var e = this.game.add.sprite(c.boxes[d].x, c.boxes[d].y);
        this.game.physics.p2.enable(e, false);
        e.body.clearShapes();
        e.body.addRectangle(c.boxes[d].scaleX, c.boxes[d].scaleY, 0, 0, 0);
        e.body.static = true;
        e.body.angle = c.boxes[d].rotation;
      }
      var d = 0;
      for (d in c.circles) {
        var f = this.game.add.sprite(c.circles[d].x, c.circles[d].y);
        this.game.physics.p2.enable(f, false);
        f.body.clearShapes();
        f.body.addCircle(c.circles[d].radius, 0, 0, 0);
        f.body.static = true;
      }
      this.parkZone = this.game.add.sprite(100, 0);
      this.game.physics.p2.enable(this.parkZone, false);
      this.parkZone.body.clearShapes();
      this.parkZone.body.addRectangle(110, 230, 0, 0, 0).sensor = true;
      this.parkZone.body.static = true;
      this.parkZone.body.angle = 0;
      var d = 0;
      for (d in c.park) {
        var h = new Object();
        h.x = c.park[d].x;
        h.y = c.park[d].y;
        h.angle = c.park[d].rotation;
        this.parkZonesPositions[c.park[d].order - 1] = h;
        var i = new Phaser.Polygon([c.park[d].points[0], c.park[d].points[1], c.park[d].points[2], c.park[d].points[3]]);
        this.parkPolys[c.park[d].order - 1] = i;
      }
      this.parkZone.body.x = this.parkZonesPositions[0].x;
      this.parkZone.body.y = this.parkZonesPositions[0].y;
      this.parkZone.body.angle = this.parkZonesPositions[0].angle;
      var d = 0;
      for (d in c.cars) if (c.cars[d].pricep) {
        var j = this.load_json_pricep(c.cars[d].pricepX, c.cars[d].pricepY, c.cars[d].pricepRotation, c.cars[d].pricepType);
        this.load_json_car(c.cars[d].x, c.cars[d].y, c.cars[d].rotation, c.cars[d].order, c.cars[d].type, j);
      } else {
        this.load_json_car(c.cars[d].x, c.cars[d].y, c.cars[d].rotation, c.cars[d].order, c.cars[d].type, null);
      }
      this.car = this.cars[0];
      this.car.body.mass = 1;
      this.car.body.onBeginContact.add(this.carOnContact, this);
      this.car.body.onEndContact.add(this.carOnEndContact, this);
      if (this.car.pricep) {
        this.car.pricep.body.onBeginContact.add(this.pricepOnContact, this);
      }
      this.invertedControl = this.car.invertedControl;
      c = null;
    },
    load_json_pricep: function (a, b, c, d) {
      var f;
      var e = this.game.cache.getJSON("pricep_" + d);
      f = this.game.add.sprite(a, b);
      this.game.physics.p2.enable(f, false);
      var g = 0;
      for (g in e.shadow) {
        var h = this.game.make.sprite(e.shadow[g].x, e.shadow[g].y, "car_shadow");
        h.scale.setTo(e.shadow[g].scaleX, e.shadow[g].scaleY);
        f.addChild(h);
      }
      var i = this.game.make.sprite(e.car_image.x, e.car_image.y, e.car_image.image);
      if (e.car_image.scaleX) {
        i.scale.setTo(e.car_image.scaleX, e.car_image.scaleY);
      }
      i.anchor.setTo(1, 0);
      if (e.car_image.angle) {
        i.angle = e.car_image.angle;
        i.anchor.setTo(0, 1);
      } else {
        i.angle = -90;
      }
      f.addChild(i);
      f.body.clearShapes();
      var g = 0;
      for (g in e.boxes) f.body.addRectangle(e.boxes[g].scaleX, e.boxes[g].scaleY, e.boxes[g].x, e.boxes[g].y, 0);
      f.body.angularDamping = .999;
      f.body.damping = .999;
      f.body.rotation = .017453292519 * c;
      f.body.mass = 3;
      f.linkPoint = new Phaser.Point(e.link_point.x, e.link_point.y);
      e = null;
      return f;
    },
    load_json_car: function (a, b, c, d, e, f) {
      var h;
      var g = this.game.cache.getJSON("car_" + e);
      h = this.game.add.sprite(a, b);
      this.game.physics.p2.enable(h, false);
      var j = this.game.make.sprite(g.wheels.wheel_l_x, g.wheels.wheel_l_y, "car_wheel");
      var k = this.game.make.sprite(g.wheels.wheel_r_x, g.wheels.wheel_r_y, "car_wheel");
      j.anchor.setTo(.5, .5);
      k.anchor.setTo(.5, .5);
      h.addChild(j);
      h.addChild(k);
      h.wheel_l = j;
      h.wheel_r = k;
      var l = this.game.make.sprite(g.shadow.x, g.shadow.y, "car_shadow");
      l.scale.setTo(g.shadow.scaleX, g.shadow.scaleY);
      h.addChild(l);
      var m = this.game.make.sprite(g.car_image.x, g.car_image.y, g.car_image.image);
      m.anchor.setTo(1, 0);
      if (g.car_image.angle) {
        m.angle = g.car_image.angle;
        m.anchor.setTo(0, 1);
      } else {
        m.angle = -90;
      }
      if (!(1 != e && 2 != e)) {
        m.scale.setTo(.92, .92);
      }
      h.addChild(m);
      if (g.additional_img) {
        var n = this.game.make.sprite(g.additional_img.x, g.additional_img.y, g.additional_img.image);
        n.anchor.setTo(.5, .5);
        n.angle = g.additional_img.angle;
        n.scale.setTo(g.additional_img.scaleX, g.additional_img.scaleY);
        h.addChild(n);
      }
      h.body.clearShapes();
      for (i in g.boxes) if (g.boxes[i].angle) {
        h.body.addRectangle(g.boxes[i].scaleX, g.boxes[i].scaleY, g.boxes[i].x, g.boxes[i].y, .017453292519 * g.boxes[i].angle);
      } else {
        h.body.addRectangle(g.boxes[i].scaleX, g.boxes[i].scaleY, g.boxes[i].x, g.boxes[i].y, 0);
      }
      for (i in g.circles) h.body.addCircle(g.circles[i].radius, g.circles[i].x, g.circles[i].y, 0);
      h.body.angularDamping = .999;
      h.body.damping = .999;
      h.body.rotation = .017453292519 * c;
      h.body.mass = 30;
      this.cars[d - 1] = h;
      var o = this.game.make.sprite(g.cam_point.x, g.cam_point.y);
      h.addChild(o);
      h.camPoint = o;
      var p = this.game.make.sprite(g.hitpoints[0][0], g.hitpoints[0][1]);
      h.addChild(p);
      var q = this.game.make.sprite(g.hitpoints[1][0], g.hitpoints[1][1]);
      h.addChild(q);
      var r = this.game.make.sprite(g.hitpoints[2][0], g.hitpoints[2][1]);
      h.addChild(r);
      var s = this.game.make.sprite(g.hitpoints[3][0], g.hitpoints[3][1]);
      h.addChild(s);
      h.pPoints = [p, q, r, s];
      h.flares = [];
      for (i in g.flares) {
        var t = this.game.make.sprite(g.flares[i][0], g.flares[i][1], "flare");
        t.anchor.setTo(.5, .5);
        t.scale.setTo(.5, .5);
        t.blendMode = PIXI.blendModes.ADD;
        t.tint = 16737792;
        h.addChild(t);
        h.flares[i] = t;
        t.visible = false;
        if (0 == i || 1 == i) {
          var u = this.game.make.sprite(g.flares[i][0], g.flares[i][1], "flare");
          u.anchor.setTo(.5, .5);
          u.scale.setTo(.5, .5);
          u.blendMode = PIXI.blendModes.ADD;
          u.tint = 16711680;
          h.addChild(u);
          if (0 == i) {
            h.flares[4] = u;
          } else {
            h.flares[5] = u;
          }
          u.visible = false;
        }
      }
      if (g.inverted) {
        h.invertedControl = true;
      } else {
        h.invertedControl = false;
      }
      if (f) {
        var v = this.game.physics.p2.createRevoluteConstraint(f, [f.linkPoint.x, f.linkPoint.y], h, [g.link_point.x, g.link_point.y], 2e4);
        v.upperLimitEnabled = true;
        v.upperLimit = 1.2;
        v.lowerLimitEnabled = true;
        v.lowerLimit = -1.2;
        v.collideConnected = false;
        if (g.link_point.pricep_on_top) {
          f.bringToTop();
        }
        h.pricep = f;
      }
      g = null;
      return h;
    },
    blinkFlares: function () {
      for (var a = 0; a < 4; a++) {
        this.car.flares[a].tint = 16737792;
        this.car.flares[a].visible = true;
        this.car.flares[a].alpha = 0;
        var b = this.game.add.tween(this.car.flares[a]).to({
          alpha: 1
        }, 300, "Linear", false);
        b.to({
          alpha: 0
        }, 300, "Linear", false, 0);
        b.to({
          alpha: 1
        }, 300, "Linear", false, 0);
        b.to({
          alpha: 0
        }, 300, "Linear", false, 0);
        b.start();
      }
    },
    changeCar: function () {
      this.carIndex += 1;
      if (this.carIndex == this.cars.length) {
        this.carIndex -= 1;
        this.levelFinished = true;
        this.gui_show_mission_complete();
      } else {
        this.gui_show_mission_complete();
        this.car.body.mass = 30;
        this.car.body.onBeginContact.remove(this.carOnContact, this);
        this.car.body.onEndContact.remove(this.carOnEndContact, this);
        if (this.car.pricep) {
          this.car.pricep.body.onBeginContact.remove(this.pricepOnContact, this);
        }
        this.contactsCount = 0;
        this.car.flares[4].visible = false;
        this.car.flares[5].visible = false;
        this.car = this.cars[this.carIndex];
        this.car.body.onBeginContact.add(this.carOnContact, this);
        this.car.body.onEndContact.add(this.carOnEndContact, this);
        if (this.car.pricep) {
          this.car.pricep.body.onBeginContact.add(this.pricepOnContact, this);
        }
        this.car.body.mass = 1;
        this.car.body.setZeroVelocity();
        this.carSpeed = 0;
        this.invertedControl = this.car.invertedControl;
        this.parkZone.body.x = this.parkZonesPositions[this.carIndex].x;
        this.parkZone.body.y = this.parkZonesPositions[this.carIndex].y;
        this.parkZone.body.angle = this.parkZonesPositions[this.carIndex].angle;
      }
    },
    pricepOnContact: function (a, b, c, d, e) {
      if (a) {
        if (a.data.shapes[0].sensor) {
          return;
        }
        if (this.hitTimer < 0) {
          this.hitTimer = 30;
          this.stars -= 1;
          s_hit.play();
          if (e[0]) {
            var f = e[0].bodyA.position;
            var g = e[0].contactPointA;
            var h = this.game.physics.p2.mpxi(f[0] + g[0]);
            var i = this.game.physics.p2.mpxi(f[1] + g[1]);
            this.spark.x = h;
            this.spark.y = i;
            this.spark.animations.play("blam", 30, false);
          }
          if (5 == this.stars) {
            this.gui_star_3.frame = 1;
            this.gui_star_3.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_3.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (4 == this.stars) {
            this.gui_star_3.frame = 0;
            this.gui_star_3.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_3.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (3 == this.stars) {
            this.gui_star_2.frame = 1;
            this.gui_star_2.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_2.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (2 == this.stars) {
            this.gui_star_2.frame = 0;
            this.gui_star_2.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_2.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (1 == this.stars) {
            this.gui_star_1.frame = 1;
            this.gui_star_1.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_1.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (0 == this.stars) {
            this.gui_star_1.frame = 0;
            this.gui_star_1.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_1.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
            this.gui_show_failed();
          }
        }
      }
    },
    carOnContact: function (a, b, c, d, e) {
      if (a) {
        if (a.data.shapes[0].sensor) {
          this.contactsCount += 1;
        } else if (this.hitTimer < 0) {
          this.hitTimer = 30;
          this.stars -= 1;
          s_hit.play();
          if (e[0]) {
            var f = e[0].bodyA.position;
            var g = e[0].contactPointA;
            var h = this.game.physics.p2.mpxi(f[0] + g[0]);
            var i = this.game.physics.p2.mpxi(f[1] + g[1]);
            this.spark.x = h;
            this.spark.y = i;
            this.spark.animations.play("blam", 30, false);
          }
          if (5 == this.stars) {
            this.gui_star_3.frame = 1;
            this.gui_star_3.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_3.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (4 == this.stars) {
            this.gui_star_3.frame = 0;
            this.gui_star_3.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_3.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (3 == this.stars) {
            this.gui_star_2.frame = 1;
            this.gui_star_2.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_2.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (2 == this.stars) {
            this.gui_star_2.frame = 0;
            this.gui_star_2.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_2.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (1 == this.stars) {
            this.gui_star_1.frame = 1;
            this.gui_star_1.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_1.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
          }
          if (0 == this.stars) {
            this.gui_star_1.frame = 0;
            this.gui_star_1.scale.setTo(0, 0);
            this.game.add.tween(this.gui_star_1.scale).to({
              x: .324,
              y: .324
            }, 500, Phaser.Easing.Elastic.Out, true);
            this.gui_show_failed();
          }
        }
      } else {
        console.log("You last hit: The wall :)");
      }
    },
    carOnEndContact: function (a, b, c, d, e) {
      if (!this.missionMessage) {
        if (a && a.data.shapes[0].sensor) {
          this.contactsCount -= 1;
          if (this.contactsCount < 0) {
            this.contactsCount = 0;
          }
        }
      }
    },
    pause_ON_OFF: function () {
      if (!this.missionMessage && !this.levelFinished) {
        this.gamePaused = !this.gamePaused;
        if (this.gamePaused) {
          this.gui_pause.y = -240;
          var a = this.game.add.tween(this.gui_pause).to({
            y: 140
          }, 150, "Linear", false);
          a.start();
        }
        if (!this.gamePaused) {
          var a = this.game.add.tween(this.gui_pause).to({
            y: 740
          }, 200, "Linear", false);
          a.start();
        }
      }
    },
    update: function () {
      this.pressTimer -= 1;
      if ((this.game.input.keyboard.isDown(Phaser.Keyboard.P) || this.game.input.keyboard.isDown(Phaser.Keyboard.ESC)) && this.pressTimer < 0) {
        this.pressTimer = 20;
        this.pause_ON_OFF();
      }
      if (!this.gamePaused) {
        if (this.check_fail_inProgress) {
          this.gui_complete_check.updateCrop();
          this.gui_complete_fail.updateCrop();
        }
        this.hitTimer -= 1;
        for (var a = 0; a < 6; a++) {
          this.car.flares[a].rotation = 0 - this.car.body.rotation;
        }
        if (this.contactsCount > 0 && !this.missionMessage && this.carSpeed > -.4 && this.carSpeed < .4) {
          var b = 0;
          for (var a = 0; a < 4; a++) {
            if (this.parkPolys[this.carIndex].contains(this.car.pPoints[a].world.x * (1 / this.worldScale), this.car.pPoints[a].world.y * (1 / this.worldScale))) {
              b += 1;
            }
          }
          if (4 == b) {
            this.changeCar();
          }
        }
        this.car.body.setZeroVelocity();
        if (this.gui_wheel_pressed) {
          if (this.wheelPointer) {
            var c = this.gui_wheel.label.angle;
            var d = this.wheelPointer.x - this.wheelTouchPosition.x;
            var e = this.wheelPointer.y - this.wheelTouchPosition.y;
            if (this.wheelTouchPosition.x < this.gui_wheel.x) {
              e = -e;
            }
            if (this.wheelTouchPosition.y > this.gui_wheel.y) {
              d = -d;
            }
            var f = (d + e) / 2;
            this.gui_wheel.label.angle = f + c;
            if (this.gui_wheel.label.angle > 90) {
              this.gui_wheel.label.angle = 90;
            }
            if (this.gui_wheel.label.angle < -90) {
              this.gui_wheel.label.angle = -90;
            }
            this.wheelTouchPosition.x = this.wheelPointer.x;
            this.wheelTouchPosition.y = this.wheelPointer.y;
          } else {
            this.wheel_right = false;
            this.wheel_left = false;
            console.log("wheel pressed but pointer == null");
          }
        } else if (mobile_browser) {
          this.gui_wheel.label.angle *= .92;
          if (this.gui_wheel.label.angle <= 2 && this.gui_wheel.label.angle >= -2) {
            this.gui_wheel.label.angle = 0;
          }
        }
        if (mobile_browser) {
          if (this.invertedControl) {
            this.car.wheel_l.angle = -.44 * this.gui_wheel.label.angle;
            this.car.wheel_r.angle = this.car.wheel_l.angle;
          } else {
            this.car.wheel_l.angle = .44 * this.gui_wheel.label.angle;
            this.car.wheel_r.angle = this.car.wheel_l.angle;
          }
        } else if (this.cursors.left.isDown && !this.missionMessage || this.wasd.left.isDown && !this.missionMessage || this.wheel_left && !this.missionMessage) {
          if (this.invertedControl) {
            if (this.car.wheel_l.angle < 40) {
              this.car.wheel_l.angle = this.car.wheel_r.angle += 2;
            }
          } else if (this.car.wheel_l.angle > -40) {
            this.car.wheel_l.angle = this.car.wheel_r.angle -= 2;
          }
        } else if (this.cursors.right.isDown && !this.missionMessage || this.wasd.right.isDown && !this.missionMessage || this.wheel_right && !this.missionMessage) {
          if (this.invertedControl) {
            if (this.car.wheel_l.angle > -40) {
              this.car.wheel_l.angle = this.car.wheel_r.angle -= 2;
            }
          } else if (this.car.wheel_l.angle < 40) {
            this.car.wheel_l.angle = this.car.wheel_r.angle += 2;
          }
        } else {
          this.car.wheel_l.angle *= .92;
          if (this.car.wheel_l.angle <= 3 && this.car.wheel_l.angle >= -3) {
            this.car.wheel_l.angle = 0;
          }
          this.car.wheel_r.angle = this.car.wheel_l.angle;
        }
        if (this.cursors.up.isDown && !this.missionMessage || this.gui_gas_pressed && !this.missionMessage || this.wasd.up.isDown && !this.missionMessage) {
          if (!this.music_engine_played) {
            this.music_engine_played = true;
            s_engine.play();
          }
          this.carSpeed += this.carSpeed < 4 ? .08 : 0;
        } else if (this.cursors.down.isDown && !this.missionMessage || this.gui_brake_pressed && !this.missionMessage || this.wasd.down.isDown && !this.missionMessage) {
          if (!this.music_engine_played) {
            this.music_engine_played = true;
            s_engine.play();
          }
          this.carSpeed += this.carSpeed > -2.8 ? this.carSpeed > .3 ? -.3 : -.1 : 0;
          this.car.flares[4].visible = true;
          this.car.flares[5].visible = true;
        } else {
          this.music_engine_played = false;
          if (this.carSpeed <= -.1) {
            this.carSpeed += .1;
          }
          if (this.carSpeed >= .1) {
            this.carSpeed -= .1;
          }
          if (this.carSpeed > -.1 && this.carSpeed < .1) {
            this.carSpeed = 0;
          }
          if (!this.missionMessage) {
            this.car.flares[4].visible = false;
            this.car.flares[5].visible = false;
          }
        }
        this.car.body.rotation += this.car.wheel_l.angle * this.carSpeed / this.car.wheel_l.x * .017453292519;
        var g = 0;
        g = this.car.body.rotation + this.car.wheel_l.rotation;
        var h = this.carSpeed * Math.cos(g);
        var i = this.carSpeed * Math.sin(g);
        var j = new Phaser.Point(h, i);
        var k = new Phaser.Point();
        k.x = 1;
        k.y = 0;
        var l = Math.cos(this.car.body.rotation);
        var m = Math.sin(this.car.body.rotation);
        k = new Phaser.Point(l * k.x - m * k.y, m * k.x + l * k.y);
        var n = k.dot(j);
        j.x = k.x * n;
        j.y = k.y * n;
        this.car.body.applyImpulse([-3 * j.x, -3 * j.y], 0, 0);
        if (this.car.pricep) {
          var j = new Phaser.Point(this.car.pricep.body.velocity.x, this.car.pricep.body.velocity.y);
          var k = new Phaser.Point(1, 0);
          var l = Math.cos(this.car.pricep.body.rotation);
          var m = Math.sin(this.car.pricep.body.rotation);
          k = new Phaser.Point(l * k.x - m * k.y, m * k.x + l * k.y);
          var n = k.dot(j);
          this.car.pricep.body.velocity.x = k.x * n;
          this.car.pricep.body.velocity.y = k.y * n;
        }
      }
    }
  };